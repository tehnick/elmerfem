!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Misc utilities
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 01 Oct 1996
! *
! *****************************************************************************/

MODULE GeneralUtils

USE Types

IMPLICIT NONE

INTERFACE AllocateVector
  MODULE PROCEDURE AllocateRealVector, AllocateIntegerVector, &
                   AllocateComplexVector, AllocateLogicalVector, &
                   AllocateElementVector
END INTERFACE

INTERFACE AllocateArray
  MODULE PROCEDURE AllocateRealArray, AllocateIntegerArray, &
                   AllocateComplexArray, AllocateLogicalArray
END INTERFACE

INTERFACE ComponentName
   MODULE PROCEDURE ComponentNameStr, ComponentNameVar
END INTERFACE

    REAL(KIND=dp), PRIVATE :: AdvanceTime1, AdvanceTime2

CONTAINS

!------------------------------------------------------------------------------
  SUBROUTINE StartAdvanceOutput( SolverName, OutputType )
!------------------------------------------------------------------------------
     CHARACTER(LEN=*) :: SolverName, OutputType
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: RealTime

     AdvanceTime1 = RealTime()
     AdvanceTime2 = RealTime()
     CALL Info( SolverName, OutputType, Level=5 )
!------------------------------------------------------------------------------
  END SUBROUTINE StartAdvanceOutput
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AdvanceOutput(t,n,dot_t,percent_t)
!------------------------------------------------------------------------------
     INTEGER :: t,n
     REAL(KIND=dp), OPTIONAL :: dot_t,percent_t
!------------------------------------------------------------------------------
     INTEGER :: i
     REAL(KIND=dp) :: RealTime, d_t, p_t
!------------------------------------------------------------------------------
     d_t = 1._dp
     p_t = 20._dp
     IF ( PRESENT(dot_t) ) d_t = dot_t
     IF ( PRESENT(percent_t) ) p_t = percent_t

     IF ( RealTime() - AdvanceTime1 > d_t ) THEN
       CALL Info( '', '.', Level=5, noAdvance=.TRUE. )

       IF ( RealTime() - AdvanceTime2 > p_t ) THEN
         i = NINT(t*100.0/n)
         WRITE(Message, '(i3,a)' ) i, '%'
         CALL Info( '', Message, Level=5 )
         AdvanceTime2 = RealTime()
       END IF
       AdvanceTime1 = RealTime()
     END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AdvanceOutput
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   PURE FUNCTION lentrim(str) RESULT(n)
!------------------------------------------------------------------------------
     CHARACTER(LEN=*), INTENT(IN) :: str
     INTEGER :: n
     DO n=LEN(str),1,-1
       IF ( str(n:n) /= ' ' ) EXIT
     END DO
!------------------------------------------------------------------------------
   END FUNCTION lentrim
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION i2s(value) RESULT(string)
!------------------------------------------------------------------------------
    INTEGER :: value
    CHARACTER(LEN=16) :: string
!------------------------------------------------------------------------------
    INTEGER :: val
    INTEGER :: i,n,t
!------------------------------------------------------------------------------

     string = ' '
     val = value
     IF ( value > 0 ) THEN
       n = LOG10(REAL(value))+1
     ELSE
       n = 1
     END IF

     DO i=n-1,0,-1
      t = val / 10**i
      val = val - t*10**i
      string(n-i:n-i) = CHAR(t+ICHAR('0'))
     END DO
!------------------------------------------------------------------------------
  END FUNCTION i2s
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SystemCommand( cmd ) 
!------------------------------------------------------------------------------
    CHARACTER(LEN=*) :: cmd
    CALL SystemC( TRIM(cmd) // CHAR(0) )
!------------------------------------------------------------------------------
  END SUBROUTINE SystemCommand
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION FormatDate() RESULT( date )
!------------------------------------------------------------------------------
    CHARACTER( LEN=20 ) :: date
    INTEGER :: dates(8)

    CALL DATE_AND_TIME( VALUES=dates )
    WRITE( date, &
     '(I4,"/",I2.2,"/",I2.2," ",I2.2,":",I2.2,":",I2.2)' ) &
                dates(1),dates(2),dates(3),dates(5),dates(6),dates(7)
!------------------------------------------------------------------------------
  END FUNCTION FormatDate
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE Sort( n,a )
!------------------------------------------------------------------------------
     INTEGER :: n,a(:)
!------------------------------------------------------------------------------

     INTEGER :: i,j,l,ir,ra
!------------------------------------------------------------------------------

      IF ( n <= 1 ) RETURN
 
      l = n / 2 + 1
      ir = n
      DO WHILE( .TRUE. )
        IF ( l > 1 ) THEN
          l = l - 1
          ra = a(l)
        ELSE
         ra = a(ir)
         a(ir) = a(1)
         ir = ir - 1
         IF ( ir == 1 ) THEN
           a(1) = ra
           RETURN
         END IF
        END IF
        i = l
        j = l + l
        DO WHILE( j <= ir )
          IF ( j<ir ) THEN
            IF ( a(j)<a(j+1) ) j = j+1
          END IF

          IF ( ra<a(j) ) THEN
            a(i) = a(j)
            i = j
            j =  j + i
          ELSE
            j = ir + 1
          END IF
          a(i) = ra
       END DO
     END DO

!------------------------------------------------------------------------------
   END SUBROUTINE Sort
!------------------------------------------------------------------------------

!
! Sort int array?
!------------------------------------------------------------------------------
   SUBROUTINE SortI( n,a,b )
!------------------------------------------------------------------------------
     INTEGER :: n,a(:),b(:)
!------------------------------------------------------------------------------

     INTEGER :: i,j,l,ir,ra,rb
!------------------------------------------------------------------------------

      IF ( n <= 1 ) RETURN
 
      l = n / 2 + 1
      ir = n
      DO WHILE( .TRUE. )
        IF ( l > 1 ) THEN
          l = l - 1
          ra = a(l)
          rb = b(l)
        ELSE
         ra = a(ir)
         rb = b(ir)
         a(ir) = a(1)
         b(ir) = b(1)
         ir = ir - 1
         IF ( ir == 1 ) THEN
           a(1) = ra
           b(1) = rb
           RETURN
         END IF
        END IF
        i = l
        j = l + l
        DO WHILE( j <= ir )
          IF ( j<ir  ) THEN
             IF ( a(j)<a(j+1) ) j = j+1
          END IF
          IF ( ra<a(j) ) THEN
            a(i) = a(j)
            b(i) = b(j)
            i = j
            j =  j + i
          ELSE
            j = ir + 1
          END IF
          a(i) = ra
          b(i) = rb
       END DO
     END DO

!------------------------------------------------------------------------------
   END SUBROUTINE SortI
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE SortF( n,a,b )
!------------------------------------------------------------------------------
     INTEGER :: n,a(:)
     REAL(KIND=dp) :: b(:)
!------------------------------------------------------------------------------

     INTEGER :: i,j,l,ir,ra
     REAL(KIND=dp) :: rb
!------------------------------------------------------------------------------

      IF ( n <= 1 ) RETURN
 
      l = n / 2 + 1
      ir = n
      DO WHILE( .TRUE. )

        IF ( l > 1 ) THEN
          l = l - 1
          ra = a(l)
          rb = b(l)
        ELSE
          ra = a(ir)
          rb = b(ir)
          a(ir) = a(1)
          b(ir) = b(1)
          ir = ir - 1
          IF ( ir == 1 ) THEN
            a(1) = ra
            b(1) = rb
            RETURN
          END IF
        END IF
        i = l
        j = l + l
        DO WHILE( j <= ir )
          IF ( j<ir  ) THEN
            IF ( a(j)<a(j+1) ) j = j+1
          END IF
          IF ( ra<a(j) ) THEN
            a(i) = a(j)
            b(i) = b(j)
            i = j
            j = j + i
          ELSE
            j = ir + 1
          END IF
          a(i) = ra
          b(i) = rb
       END DO
     END DO

!------------------------------------------------------------------------------
   END SUBROUTINE SortF
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE SortC( n,a,b )
!------------------------------------------------------------------------------
     INTEGER :: n,b(:)
     COMPLEX(KIND=dp):: a(:)
!------------------------------------------------------------------------------

     INTEGER :: i,j,l,ir,rb
     COMPLEX(KIND=dp) :: ra
!------------------------------------------------------------------------------

      IF ( n <= 1 ) RETURN
 
      l = n / 2 + 1
      ir = n
      DO WHILE( .TRUE. )
        IF ( l > 1 ) THEN
          l = l - 1
          ra = a(l)
          rb = b(l)
        ELSE
          ra = a(ir)
          rb = b(ir)
          a(ir) = a(1)
          b(ir) = b(1)
          ir = ir - 1
          IF ( ir == 1 ) THEN
            a(1) = ra
            b(1) = rb
            RETURN
          END IF
        END IF
        i = l
        j = l + l
        DO WHILE( j <= ir )
          IF ( j<ir ) THEN
             IF ( ABS(a(j))<ABS(a(j+1)) ) j = j+1
          END IF
          IF ( ABS(ra)<ABS(a(j)) ) THEN
            a(i) = a(j)
            b(i) = b(j)
            i = j
            j = j + i
          ELSE
            j = ir + 1
          END IF
          a(i) = ra
          b(i) = rb
       END DO
     END DO

!------------------------------------------------------------------------------
   END SUBROUTINE SortC
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Order real components in b in a decreasing order and return the new order
! of indexes in a.
!------------------------------------------------------------------------------
   SUBROUTINE SortR( n,a,b )
!------------------------------------------------------------------------------
     INTEGER :: n,a(:)
     REAL(KIND=dp) :: b(:)
!------------------------------------------------------------------------------

     INTEGER :: i,j,l,ir,ra
     REAL(KIND=dp) :: rb
!------------------------------------------------------------------------------

      IF ( n <= 1 ) RETURN
 
      l = n / 2 + 1
      ir = n
      DO WHILE( .TRUE. )

        IF ( l > 1 ) THEN
          l = l - 1
          ra = a(l)
          rb = b(l)
        ELSE
          ra = a(ir)
          rb = b(ir)
          a(ir) = a(1)
          b(ir) = b(1)
          ir = ir - 1
          IF ( ir == 1 ) THEN
            a(1) = ra
            b(1) = rb
            RETURN
          END IF
        END IF
        i = l
        j = l + l
        DO WHILE( j <= ir )
          IF ( j<ir  ) THEN
             IF ( b(j) > b(j+1) ) j = j+1
          END IF
          IF ( rb > b(j) ) THEN
            a(i) = a(j)
            b(i) = b(j)
            i = j
            j = j + i
          ELSE
            j = ir + 1
          END IF
          a(i) = ra
          b(i) = rb
       END DO
     END DO

!------------------------------------------------------------------------------
   END SUBROUTINE SortR
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  FUNCTION Search( N,Array,Value ) RESULT ( INDEX )
!------------------------------------------------------------------------------

    INTEGER :: N,Value,Array(:)
!------------------------------------------------------------------------------

    ! Local variables

    INTEGER :: Lower, Upper,Lou,INDEX
!------------------------------------------------------------------------------

    !*******************************************************************

    INDEX = 0 
    Upper = N
    Lower = 1

    ! Handle the special case

    IF ( Upper == 0 ) RETURN

    DO WHILE( .TRUE. )
      IF ( Array(Lower) == Value ) THEN
         INDEX = Lower
         EXIT
      ELSE IF ( Array(Upper) == Value ) THEN
         INDEX = Upper
         EXIT
      END IF

      IF ( (Upper-Lower)>1 ) THEN
        Lou = ISHFT((Upper + Lower), -1)
        IF ( Array(Lou) < Value ) THEN
          Lower = Lou
        ELSE
          Upper = Lou
        END IF
      ELSE
        EXIT
      END IF
    END DO
    
    RETURN

!------------------------------------------------------------------------------
  END FUNCTION Search
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE OpenIncludeFile( Unit, FileName, IncludePath )
!------------------------------------------------------------------------------
    INTEGER :: Unit
    CHARACTER(LEN=*) :: FileName, IncludePath
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,k0,k1,l
    CHARACTER(LEN=1024) :: name, TmpName
!------------------------------------------------------------------------------

    i = 1
    name = FileName
    DO WHILE( name(i:i) == ' ' .OR. name(i:i)=='"')
      i = i + 1
    END DO
    j = LEN_TRIM(name)
    IF ( name(j:j) == '"' ) j=j-1
    name = TRIM(name(i:j))

    IF ( INDEX(name,':') == 0 .AND. name(1:1) /= '/' .AND. &
              name(1:1) /= Backslash ) THEN
       k0 = 1
       DO WHILE( IncludePath(k0:k0) == '"' )
         k0 = k0+1
       END DO
       k1 = INDEX( IncludePath, ';' )

       DO WHILE( k1 >= k0 )
         DO k = k1-1,k0,-1
           IF ( IncludePath(k:k) /= ' ' .AND. IncludePath(k:k)/='"' ) EXIT
         END DO 
         IF ( IncludePath(k:k) == '"' ) k=k-1
         IF ( k >= k0 ) THEN
           WRITE( tmpName,'(a,a,a)' ) IncludePath(k0:k), '/', TRIM(name)
           OPEN( Unit, FILE=TRIM(tmpName), STATUS='OLD',ERR=10 )
           RETURN
         END IF
10       CONTINUE
         k0 = k1+1
         k1 = INDEX( IncludePath(k0:), ';' ) + k0 - 1
       END DO

       IF ( LEN_TRIM(IncludePath(k0:))>0 ) THEN
         k1 = INDEX( IncludePath(k0:), '"' ) + k0 - 2
         IF ( k1 < k0 ) k1=LEN_TRIM(IncludePath)
         WRITE( tmpName,'(a,a,a)' ) TRIM(IncludePath(k0:k1)), '/', TRIM(name)
         OPEN( Unit, FILE=TRIM(TmpName), STATUS='OLD',ERR=20 )
         RETURN
       END IF

20     CONTINUE
       OPEN( Unit, FILE=TRIM(name), STATUS='OLD' )
    ELSE
       OPEN( Unit, FILE=TRIM(name), STATUS='OLD' )
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE OpenIncludeFile
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   RECURSIVE FUNCTION ReadAndTrim( Unit,str,echo,literal ) RESULT(l)
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Read a (logical) line from FORTRAN device Unit and remove leading, trailing,
!  and multiple blanks between words. Also convert uppercase characters to
!  lowercase.The logical line can continue the several physical lines by adding
!  the backslash (\) mark at the end of a physical line. 
!
!  ARGUMENTS:
!
!     INTEGER :: Unit
!       INPUT: Fortran unit number to read from
!
!     CHARACTER :: str
!       OUTPUT: The string read from the file
!
!  FUNCTION RESULT:
!      LOGICAL :: l
!        Success of the read operation
!
!******************************************************************************
     INTEGER, PARAMETER :: MAXLEN = 16384

     INTEGER :: Unit
     CHARACTER(LEN=*) :: str

     LOGICAL, OPTIONAL :: Echo, literal
 
     LOGICAL :: l

     CHARACTER(LEN=12) :: tmpstr
     CHARACTER(LEN=MAXLEN) :: readstr = ' ', copystr = ' ', matcstr=' ' , IncludePath=' '

     LOGICAL :: InsideQuotes, OpenSection=.FALSE.
     INTEGER :: i,j,k,m,ValueStarts=0,inlen,ninlen,outlen,IncludeUnit=28,IncludeUnitBase=28

     CHARACTER(LEN=MAX_NAME_LEN) :: Prefix = '  '

     INTEGER, PARAMETER :: A=ICHAR('A'),Z=ICHAR('Z'),U2L=ICHAR('a')-ICHAR('A'),Tab=9

     SAVE ReadStr, ValueStarts, Prefix, OpenSection

     IF ( PRESENT(literal) ) literal=.FALSE.

     l = .TRUE.
     outlen = LEN(str)
     IF ( ValueStarts==0 .AND. OpenSection ) THEN
       str = 'end'
       ValueStarts = 0
       OpenSection = .FALSE.
       RETURN
     END IF

     IF ( ValueStarts == 0 ) THEN
        tmpstr = ' '
        DO WHILE( .TRUE. )
          IF ( IncludeUnit < IncludeUnitBase ) THEN
            READ( IncludeUnit,'(A)',END=1,ERR=1 ) readstr
            GO TO 2
1           CLOSE(IncludeUnit)
            IncludeUnit = IncludeUnit+1
            READ( Unit,'(A)',END=10,ERR=10 ) readstr
2           CONTINUE
          ELSE
            READ( Unit,'(A)',END=10,ERR=10 ) readstr
          END IF

          readstr = ADJUSTL(readstr)

          DO k=1,12
            j = ICHAR(readstr(k:k))
            IF ( j >= A .AND. j<= Z ) THEN
              Tmpstr(k:k) = CHAR(j+U2L)
            ELSE
              tmpstr(k:k) = readstr(k:k)
            END IF
          END DO

          IF ( Tmpstr(1:12) == 'include path' ) THEN
            k = LEN_TRIM(readstr)
            IncludePath(1:k-13) = readstr(14:k)
          ELSE
            EXIT
          END IF
        END DO

        IF ( tmpstr(1:8) == 'include ' ) THEN
          IncludeUnit = IncludeUnit-1
          CALL OpenIncludeFile( IncludeUnit, TRIM(readstr(9:)), IncludePath )
          READ( IncludeUnit,'(A)',END=3,ERR=3 ) readstr
          GO TO 4
3         CLOSE(IncludeUnit)
          IncludeUnit = IncludeUnit+1
          READ( Unit,'(A)',END=10,ERR=10 ) readstr
4         CONTINUE
        END IF
        ninlen = LEN_TRIM(readstr)
     ELSE
        inlen = LEN_TRIM(readstr)
        ninlen = inlen-ValueStarts+1
        IF ( Prefix == ' ' ) THEN
           readstr = readstr(ValueStarts:inlen)
        ELSE IF ( Prefix == '::' ) THEN
           readstr = readstr(ValueStarts:inlen)
           OpenSection = .TRUE.
           Prefix = ' '
        ELSE
           DO i=ValueStarts,inlen
              IF ( readstr(i:i) ==  ')' ) THEN
                 readstr(i:i) = ' '
                 EXIT
              ELSE IF ( readstr(i:i) == ',' ) THEN
                 readstr(i:i) = ' '
              END IF
           END DO
           ninlen = ninlen + LEN_TRIM(Prefix) + 1
           readstr = TRIM(Prefix) // ' ' // readstr(ValueStarts:inlen)
        END IF
     END IF

     ValueStarts = 0
     InsideQuotes  = .FALSE.

     i = INDEX( readstr(1:ninlen), '!' )
     IF ( i>0 ) ninlen=i-1

     i = 1
     inlen = ninlen
     DO WHILE( i <= inlen )
       IF ( readstr(i:i) == '"' ) InsideQuotes = .NOT.InsideQuotes
       IF ( .NOT. InsideQuotes .AND. readstr(i:i) == CHAR(92) .AND. i==inlen ) THEN
          readstr(i:i) = ' '
          IF ( IncludeUnit < IncludeUnitBase ) THEN
            READ( Unit,'(A)',END=10,ERR=10 ) readstr(i+1:MAXLEN)
          ELSE
            READ( IncludeUnit,'(A)',END=10,ERR=10 ) readstr(i+1:MAXLEN)
          END IF
          DO j=LEN(readstr),i+1,-1
             IF ( readstr(j:j) /= ' ' ) EXIT
          END DO
          inlen = inlen + j-i
       END IF
       i = i + 1
     END DO

     i = INDEX( readstr(1:inlen), '$' )
     IF ( i>0 .AND. i<inlen ) THEN
       m = i
       copystr(i:inlen) = readstr(i:inlen)
       DO WHILE(i<=inlen)
         IF ( copystr(i:i) == '$' ) THEN
            DO j=i+1,inlen-1
              IF ( copystr(j:j) == '$' ) EXIT
            END DO
            ninlen = j - i
            CALL MATC( copystr(i+1:), matcstr, ninlen )
            DO k=1,ninlen
              readstr(m:m) = matcstr(k:k)
              m = m + 1
            END DO
            i = j+1
         ELSE
            readstr(m:m) = copystr(i:i)
            i = i + 1
            m = m + 1
         END IF
       END DO
       IF ( m <= inlen ) readstr(m:inlen) = ' '
       inlen = m-1
     END IF

     IF ( PRESENT( Echo ) ) THEN
        IF ( Echo ) WRITE( 6, '(a)' ) readstr(1:inlen)
     END IF

     i = 1
     DO WHILE(i <= inlen )
        IF (readstr(i:i) /= ' ' .AND. ICHAR(readstr(i:i))/=Tab ) EXIT
        i = i + 1
     END DO

     InsideQuotes = .FALSE.
     str = ' '

     IF ( PRESENT(literal) ) THEN
       IF ( readstr(i:i) == '"' ) literal=.TRUE.
     END IF

     k = 1
     DO WHILE( i<=inlen )
        IF ( readstr(i:i) == '"' ) THEN
          InsideQuotes = .NOT.InsideQuotes
          i=i+1
          IF ( i>inlen ) EXIT
        END IF

        IF ( .NOT.InsideQuotes ) THEN
           IF ( readstr(i:i) == '!' .OR. readstr(i:i) == '#' .OR. &
                readstr(i:i) == '=' .OR. readstr(i:i) == '(' .OR. &
                readstr(i:i) == ';' .OR. readstr(i:i+1) == '::' ) EXIT 
           IF (ICHAR( readstr(i:i))<32.AND.ICHAR(readstr(i:i))/=Tab) EXIT
        END IF

        DO WHILE( i <= inlen )
          IF ( readstr(i:i) == '"'  ) THEN
            InsideQuotes = .NOT.InsideQuotes
            i=i+1
            IF ( i>inlen ) EXIT
          END IF

          IF ( .NOT.InsideQuotes ) THEN
             IF ( readstr(i:i) == ' ' .OR. readstr(i:i) == '=' .OR. &
                  readstr(i:i) == ';' .OR. readstr(i:i) == '(' .OR. &
                  readstr(i:i+1) == '::' ) EXIT 
             IF ( ICHAR( readstr(i:i))<32 ) EXIT
          END IF

          IF ( k>outlen ) THEN
             CALL Fatal( 'ReadAndTrim', 'Output length exeeded.' )
          END IF

          j = ICHAR( readstr(i:i) )
          IF ( .NOT.InsideQuotes .AND. j>=A .AND. j<=Z ) THEN
            str(k:k) = CHAR(j+U2L)
          ELSE IF ( .NOT.InsideQuotes .AND. j==Tab ) THEN
            str(k:k) = ' '
          ELSE
            str(k:k) = readstr(i:i)
          ENDIF

          i = i + 1
          k = k + 1
        END DO
 
        IF ( k <= outlen ) str(k:k) = ' '
        k = k + 1

        DO WHILE( i<=inlen )
          IF ( readstr(i:i) /= ' ' .AND. ICHAR(readstr(i:i))/=Tab ) EXIT
          i = i + 1
        END DO
     END DO

     IF ( i <= inlen ) THEN
       Prefix = ' '
       IF ( ReadStr(i:i) == '=' ) THEN
         ValueStarts = i + 1
       ELSE IF ( ReadStr(i:i) == ';' ) THEN
         ValueStarts = i + 1
       ELSE IF ( ReadStr(i:i) == '(' ) THEN
         ValueStarts = i + 1
         Prefix = 'Size'
       ELSE IF ( ReadStr(i:i+1) == '::' ) THEN
         ValueStarts = i + 2
         Prefix = '::'
       ELSE IF ( ICHAR(readstr(i:i)) < 32 ) THEN
         DO WHILE( i <= inlen )
           IF ( ICHAR(readstr(i:i)) >= 32 ) EXIT
           i = i + 1
         END DO
         IF ( i <= inlen ) ValueStarts = i
       END IF
     END IF
     RETURN
10   CONTINUE
     l = .FALSE.
!------------------------------------------------------------------------------
   END FUNCTION ReadAndTrim
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION IntegerToString( input ) RESULT(str)
!------------------------------------------------------------------------------
    CHARACTER(LEN=16) :: str
    INTEGER :: i,j,k,n,input

    str = ' '
    i = input
    n = LOG10(i+0.5d0)
    k = n
    DO j=1,n+1
       str(j:j) = CHAR(i/10**k+ICHAR('0'))
       i = i - 10**k * (i/10**k)
       k = k - 1
    END DO
!------------------------------------------------------------------------------
  END FUNCTION IntegerToString
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  FUNCTION GetVarName(Var) RESULT(str)
!------------------------------------------------------------------------------
    TYPE(Variable_t) :: Var
    CHARACTER(LEN=Var % NameLen) :: str
!------------------------------------------------------------------------------
    str = Var % Name(1:Var % NameLen)
!------------------------------------------------------------------------------
  END FUNCTION GetVarName
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION ComponentNameVar( Var, Component ) RESULT(str)
!------------------------------------------------------------------------------
    TYPE(Variable_t) :: Var
    INTEGER, OPTIONAL :: Component
!------------------------------------------------------------------------------
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
    str = ComponentName(Var % Name, Component)
!------------------------------------------------------------------------------
END FUNCTION ComponentNameVar
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION ComponentNameStr( BaseName, Component_arg ) RESULT(str)
!------------------------------------------------------------------------------
    INTEGER, OPTIONAL :: Component_arg
    CHARACTER(LEN=*) :: BaseName
!------------------------------------------------------------------------------
    INTEGER :: ind, ind1, DOFsTot, DOFs, Component
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
    ind = INDEX( BaseName,'[' )

    Component = 0
    IF ( PRESENT(Component_arg) ) Component=Component_arg

    IF ( ind<=0 ) THEN
      str = BaseName
      IF ( Component > 0 ) &
        str = TRIM(str) // ' ' // TRIM( IntegerToString(Component) )
    ELSE
      DOFsTot = 0
      DO WHILE( .TRUE. )
        ind1 = INDEX( BaseName(ind+1:),':' )+ind
        IF ( ind1 <= ind ) THEN
           CALL Fatal( 'ComponentName', 'Syntax error in variable definition.' )
        END IF
        READ(BaseName(ind1+1:),'(i1)') DOFs
        DOFsTot = DOFsTot+DOFs
        IF ( DOFsTot>=Component ) EXIT
        ind = ind1+2
      END DO
      str = BaseName(ind+1:ind1-1)
      IF ( DOFs>1 ) THEN
        DOFs = Component - DOFsTot + DOFs
        str = TRIM(str) // ' ' // TRIM( IntegerToString(DOFs) )
      END IF
    END IF
!------------------------------------------------------------------------------
  END FUNCTION ComponentNameStr
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
    SUBROUTINE SolveTriDiag( n, y, h, r )
!------------------------------------------------------------------------------
       INTEGER :: n
       REAL(KIND=dp) :: y(n), h(n), r(n)
       REAL(KIND=dp) :: s,b(n)
       INTEGER :: i

       DO i=2,n-1
         b(i) = 2 * ( h(i-1) + h(i) )
         r(i) = 3 * ( h(i)   * ( y(i)-y(i-1) ) / h(i-1) + &
                      h(i-1) * ( y(i+1)-y(i) ) / h(i) )
       END DO

       r(2) = r(2) - h(2) * r(1)
       DO i=2,n-2
         s = -h(i+1) / b(i)
         r(i+1) = r(i+1) + s * r(i)
         b(i+1) = b(i+1) + s * h(i-1)
       END DO

       DO i=n-1,2,-1
          r(i) = (r(i) - h(i-1) * r(i+1)) / b(i)
       END DO
!------------------------------------------------------------------------------
    END SUBROUTINE SolveTriDiag
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
    SUBROUTINE CubicSpline( n,x,y,r )
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: x(:),y(:),r(:)
      INTEGER :: n

      REAL(KIND=dp) ::  a,b,c,d,t,dt,lt,h(n)
      INTEGER :: i,j,k,l

      DO i=1,n-1
         h(i) = x(i+1) - x(i)
      END DO

      r(1) = (y(2) - y(1) )
      r(n) = (y(n) - y(n-1) )

      CALL SolveTriDiag( n,x,h,r )
!------------------------------------------------------------------------------
    END SUBROUTINE CubicSpline
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   FUNCTION CubicSplineVal(x,y,r,t) RESULT(s)
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: x(2),y(2),r(2),s,t
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: a,b,c,d,h,lt

      h = x(2)-x(1)
      a = -2 * ( y(2) - y(1) ) + (   r(1) + r(2) ) * h
      b =  3 * ( y(2) - y(1) ) - ( 2*r(1) + r(2) ) * h
      c = r(1) * h
      d = y(1)

      lt = (t - x(1)) / h
      s = ((a*lt + b) * lt + c) * lt + d
!------------------------------------------------------------------------------
   END FUNCTION CubicSplineVal
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   FUNCTION CubicSplinedVal(x,y,r,t) RESULT(s)
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: x(2),y(2),r(2),s,t
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: a,b,c,h,lt

      h = x(2)-x(1)
      a = -2 * ( y(2) - y(1) ) + (   r(1) + r(2) ) * h
      b =  3 * ( y(2) - y(1) ) - ( 2*r(1) + r(2) ) * h
      c = r(1) * h

      lt = (t - x(1)) / h
      s = ((a*lt + b) * lt + c)/h
!------------------------------------------------------------------------------
   END FUNCTION CubicSplinedVal
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION InterpolateCurve( TValues,FValues,T, CubicCoeff) RESULT( F )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: TValues(:),FValues(:),T,F
     REAL(KIND=dp), OPTIONAL, POINTER :: CubicCoeff(:)
!------------------------------------------------------------------------------
     INTEGER :: i,n
     LOGICAL :: Cubic
!------------------------------------------------------------------------------

     n = SIZE(TValues)

     DO i=1,n
        IF ( TValues(i) >= T ) EXIT
     END DO
     IF ( i > n ) i = n
     IF ( i < 2 ) i = 2

     Cubic = PRESENT(CubicCoeff)
     Cubic = Cubic .AND. T>=Tvalues(1) .AND. T<=Tvalues(n)
     IF ( Cubic ) Cubic = Cubic.AND.ASSOCIATED(CubicCoeff)

     IF ( Cubic ) THEN
       F = CubicSplineVal(Tvalues(i-1:i),FValues(i-1:i),CubicCoeff(i-1:i),T)
     ELSE
       F = (T-TValues(i-1)) / (TValues(i)-TValues(i-1))
       F = (1-F)*FValues(i-1) + F*FValues(i)
     END IF
   END FUNCTION InterpolateCurve
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION DerivateCurve( TValues,FValues,T,CubicCoeff ) RESULT( F )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: TValues(:),FValues(:),T,F
     REAL(KIND=dp), OPTIONAL, POINTER :: CubicCoeff(:)
!------------------------------------------------------------------------------
     INTEGER :: i,n
     LOGICAL :: Cubic
!------------------------------------------------------------------------------
     n = SIZE(TValues)



     DO i=1,n
       IF ( TValues(i) >= T ) EXIT
     END DO

     IF ( i > n ) i = n
     IF ( i < 2 ) i = 2

     Cubic = PRESENT(CubicCoeff)
     Cubic = Cubic .AND. T>=Tvalues(1) .AND. T<=Tvalues(n)
     IF ( Cubic ) Cubic = Cubic.AND.ASSOCIATED(CubicCoeff)

     IF (Cubic) THEN
       F = CubicSplinedVal(Tvalues(i-1:i),FValues(i-1:i),CubicCoeff(i-1:i),T)
     ELSE
       F = (FValues(i)-FValues(i-1)) / (TValues(i)-TValues(i-1))
     END IF
!------------------------------------------------------------------------------
   END FUNCTION DerivateCurve
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE SolveLinSys2x2( A, x, b )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: A(2,2),x(2),b(2),detA
!------------------------------------------------------------------------------
     detA = A(1,1) * A(2,2) - A(1,2) * A(2,1)

     IF ( detA == 0.0d0 ) THEN
       WRITE( Message, * ) 'Singular matrix, sorry!'
       CALL Error( 'SolveLinSys2x2', Message )
       RETURN
     END IF

     detA = 1.0d0 / detA
     x(1) = detA * (A(2,2) * b(1) - A(1,2) * b(2))
     x(2) = detA * (A(1,1) * b(2) - A(2,1) * b(1))
!------------------------------------------------------------------------------
   END SUBROUTINE SolveLinSys2x2
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE SolveLinSys3x3( A, x, b )
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: A(3,3),x(3),b(3)
!------------------------------------------------------------------------------
     REAL(KIND=dp) :: C(2,2),y(2),g(2),s,t,q
!------------------------------------------------------------------------------

     IF ( ABS(A(1,1))>ABS(A(1,2)) .AND. ABS(A(1,1))>ABS(A(1,3)) ) THEN
       q = 1.0d0 / A(1,1)
       s = q * A(2,1)
       t = q * A(3,1)
       C(1,1) = A(2,2) - s * A(1,2)
       C(1,2) = A(2,3) - s * A(1,3)
       C(2,1) = A(3,2) - t * A(1,2)
       C(2,2) = A(3,3) - t * A(1,3)

       g(1) = b(2) - s * b(1)
       g(2) = b(3) - t * b(1)
       CALL SolveLinSys2x2( C,y,g )
       
       x(2) = y(1)
       x(3) = y(2)
       x(1) = q * ( b(1) - A(1,2) * x(2) - A(1,3) * x(3) )
     ELSE IF ( ABS(A(1,2)) > ABS(A(1,3)) ) THEN
       q = 1.0d0 / A(1,2)
       s = q * A(2,2)
       t = q * A(3,2)
       C(1,1) = A(2,1) - s * A(1,1)
       C(1,2) = A(2,3) - s * A(1,3)
       C(2,1) = A(3,1) - t * A(1,1)
       C(2,2) = A(3,3) - t * A(1,3)
       
       g(1) = b(2) - s * b(1)
       g(2) = b(3) - t * b(1)
       CALL SolveLinSys2x2( C,y,g )

       x(1) = y(1)
       x(3) = y(2)
       x(2) = q * ( b(1) - A(1,1) * x(1) - A(1,3) * x(3) )
     ELSE
       q = 1.0d0 / A(1,3)
       s = q * A(2,3)
       t = q * A(3,3)
       C(1,1) = A(2,1) - s * A(1,1)
       C(1,2) = A(2,2) - s * A(1,2)
       C(2,1) = A(3,1) - t * A(1,1)
       C(2,2) = A(3,2) - t * A(1,2)

       g(1) = b(2) - s * b(1)
       g(2) = b(3) - t * b(1)
       CALL SolveLinSys2x2( C,y,g )

       x(1) = y(1)
       x(2) = y(2)
       x(3) = q * ( b(1) - A(1,1) * x(1) - A(1,2) * x(2) )
     END IF
!------------------------------------------------------------------------------
   END SUBROUTINE SolveLinSys3x3
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   FUNCTION AllocateMatrix() RESULT(Matrix)
!------------------------------------------------------------------------------
      TYPE(Matrix_t), POINTER :: Matrix
!------------------------------------------------------------------------------
      ALLOCATE( Matrix )

      Matrix % Format = MATRIX_CRS


      NULLIFY( Matrix % Child )
      NULLIFY( Matrix % Parent )
      NULLIFY( Matrix % EMatrix )
      NULLIFY( Matrix % ConstraintMatrix )

      NULLIFY( Matrix % Perm )
      NULLIFY( Matrix % InvPerm )

      NULLIFY( Matrix % Cols )
      NULLIFY( Matrix % Rows )
      NULLIFY( Matrix % Diag )
      NULLIFY( Matrix % GRows )
 
      NULLIFY( Matrix % RHS )
      NULLIFY( Matrix % Force )
      NULLIFY( Matrix % RHS_im )

      NULLIFY( Matrix % Values )
      NULLIFY( Matrix % ILUValues )
      NULLIFY( Matrix % MassValues )
      NULLIFY( Matrix % DampValues )

      NULLIFY( Matrix % BulkRHS )
      NULLIFY( Matrix % BulkValues )

      NULLIFY( Matrix % ILUCols )
      NULLIFY( Matrix % ILURows )
      NULLIFY( Matrix % ILUDiag )

      NULLIFY( Matrix % CRHS )
      NULLIFY( Matrix % CForce )

      NULLIFY( Matrix % RowOwner )
      NULLIFY( Matrix % ParMatrix )

      NULLIFY( Matrix % CValues )
      NULLIFY( Matrix % CILUValues )
      NULLIFY( Matrix % CMassValues )
      NULLIFY( Matrix % CDampValues )

      NULLIFY( Matrix % GRows )
      NULLIFY( Matrix % GOrder )
      NULLIFY( Matrix % RowOwner )

      NULLIFY( Matrix % ParMatrix )
      Matrix % UMFPack_Numeric = 0

      Matrix % Lumped    = .FALSE.
      Matrix % Ordered   = .FALSE. 
      Matrix % Complex   = .FALSE.
      Matrix % Symmetric = .FALSE.
      Matrix % SolveCount   = 0
      Matrix % NumberOfRows = 0
!------------------------------------------------------------------------------
   END FUNCTION AllocateMatrix
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  RECURSIVE SUBROUTINE FreeQuadrantTree( Root )
!------------------------------------------------------------------------------
    TYPE(Quadrant_t), POINTER :: Root

    INTEGER :: i

    IF ( .NOT. ASSOCIATED( Root ) ) RETURN

    IF ( ASSOCIATED(Root % Elements) ) DEALLOCATE( Root % Elements )

    IF ( ASSOCIATED( Root % ChildQuadrants ) ) THEN
       DO i=1,SIZE(Root % ChildQuadrants)
          CALL FreeQuadrantTree( Root % ChildQuadrants(i) % Quadrant )
       END DO
       DEALLOCATE( Root % ChildQuadrants )
       NULLIFY( Root % ChildQuadrants )
    END IF

    DEALLOCATE( Root )
!------------------------------------------------------------------------------
  END SUBROUTINE FreeQuadrantTree
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateRealVector( F, n, From, FailureMessage )
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: F(:)
    INTEGER :: n
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n > 0 ) THEN
       ALLOCATE( F(n), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n, ' element real array.'
          CALL Error( 'AllocateRealVector', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateRealVector', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateRealVector', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AllocateRealVector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateComplexVector( f, n, From, FailureMessage )
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp), POINTER :: f(:)
    INTEGER :: n
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n > 0 ) THEN
       ALLOCATE( f(n), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n, ' element real array.'
          CALL Error( 'AllocateComplexVector', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateComplexVector', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateComplexVector', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AllocateComplexVector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateIntegerVector( f, n, From, FailureMessage )
!------------------------------------------------------------------------------
    INTEGER, POINTER :: f(:)
    INTEGER :: n
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n > 0 ) THEN
       ALLOCATE( f(n), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n, ' element integer array.'
          CALL Error( 'AllocateIntegerVector', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateIntegerVector', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateIntegerVector', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AllocateIntegerVector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateLogicalVector( f, n, From, FailureMessage )
!------------------------------------------------------------------------------
    LOGICAL, POINTER :: f(:)
    INTEGER :: n
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n > 0 ) THEN
       ALLOCATE( f(n), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n, ' element integer array.'
          CALL Error( 'AllocateLogicalVector', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateLogicalVector', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateLogicalVector', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AllocateLogicalVector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateElementVector( f, n, From, FailureMessage )
!------------------------------------------------------------------------------
    TYPE(Element_t), POINTER :: f(:)
    INTEGER :: n
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n > 0 ) THEN
       ALLOCATE( f(n), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n, ' element integer array.'
          CALL Error( 'AllocateElementVector', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateElementVector', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateElementVector', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE AllocateElementVector
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateRealArray( f, n1, n2, From, FailureMessage )
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: f(:,:)
    INTEGER :: n1,n2
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n1 > 0 .AND. n2 > 0 ) THEN
       ALLOCATE( f(n1,n2), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n1, ' by ', n2, ' element real matrix.'
          CALL Error( 'AllocateRealArray', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateRealArray', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateRealArray', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE  AllocateRealArray
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE AllocateComplexArray( f, n1, n2, From, FailureMessage )
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp), POINTER :: f(:,:)
    INTEGER :: n1,n2
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n1 > 0 .AND. n2 > 0 ) THEN
       ALLOCATE( f(n1,n2), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n1, ' by ', n2, ' element real matrix.'
          CALL Error( 'AllocateComplexArray', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateComplexArray', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateComplexArray', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE  AllocateComplexArray
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AllocateIntegerArray( f, n1, n2, From, FailureMessage )
!------------------------------------------------------------------------------
    INTEGER, POINTER :: f(:,:)
    INTEGER :: n1,n2
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n1 > 0 .AND. n2 > 0 ) THEN
       ALLOCATE( f(n1,n2), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n1, ' by ', n2, ' element integer matrix.'
          CALL Error( 'AllocateIntegerArray', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateIntegerArray', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateIntegerArray', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE  AllocateIntegerArray
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE AllocateLogicalArray( f, n1, n2, From, FailureMessage )
!------------------------------------------------------------------------------
    LOGICAL, POINTER :: f(:,:)
    INTEGER :: n1,n2
    CHARACTER(LEN=*), OPTIONAL :: From, FailureMessage
!------------------------------------------------------------------------------
    INTEGER :: istat
!------------------------------------------------------------------------------

    istat = -1
    IF ( n1 > 0 .AND. n2 > 0 ) THEN
       ALLOCATE( f(n1,n2), STAT=istat )
    END IF
    IF ( istat /=  0 ) THEN
       IF ( PRESENT( FailureMessage  ) ) THEN
          WRITE( Message, * )'Unable to allocate ', n1, ' by ', n2, ' element integer matrix.'
          CALL Error( 'AllocateLogicalArray', Message )
          IF ( PRESENT( From ) ) THEN
             WRITE( Message, * )'Requested From: ', TRIM(From)
             CALL Error( 'AllocateLogicalArray', Message )
          END IF
          IF ( PRESENT( FailureMessage ) ) THEN
             CALL Fatal( 'AllocateLogicalArray', FailureMessage )
          END IF
       END IF
    END IF
!------------------------------------------------------------------------------
  END SUBROUTINE  AllocateLogicalArray
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Given the filename0 (and suffix0) find the 1st free filename
! that does not exist in the current working directory
!------------------------------------------------------------------------------

  FUNCTION NextFreeFilename(Filename0,Suffix0,LastExisting) RESULT (Filename)

    CHARACTER(LEN=MAX_NAME_LEN) :: Filename0
    CHARACTER(LEN=MAX_NAME_LEN), OPTIONAL :: Suffix0 
    LOGICAL, OPTIONAL :: LastExisting
    CHARACTER(LEN=MAX_NAME_LEN) :: Filename
    CHARACTER(LEN=MAX_NAME_LEN) :: Prefix, Suffix, PrevFilename
    LOGICAL :: FileIs
    INTEGER :: No, ind, len
    
    ind = INDEX( FileName0,'.',.TRUE. )
    len = LEN_TRIM(Filename0)
    IF(ind > 0) THEN
      Prefix = Filename0(1:ind-1)
      Suffix = Filename0(ind:len)
    ELSE
      Prefix = Filename0(1:len)
      IF(PRESENT(Suffix0)) THEN
        Suffix = '.'//TRIM(Suffix0)
      ELSE
        Suffix = '.dat'
      END IF
    END IF

    DO No = 1,9999
      IF( No > 0 ) PrevFilename = Filename
      IF( No < 10) THEN
        WRITE( FileName,'(A,I1,A)') TRIM(Prefix),No,TRIM(Suffix)
      ELSE IF( No < 100) THEN
        WRITE( FileName,'(A,I2,A)') TRIM(Prefix),No,TRIM(Suffix)
      ELSE IF( No < 1000) THEN
        WRITE( FileName,'(A,I3,A)') TRIM(Prefix),No,TRIM(Suffix)
      ELSE IF( No < 10000) THEN
        WRITE( FileName,'(A,I4,A)') TRIM(Prefix),No,TRIM(Suffix)
      END IF
      INQUIRE( FILE=Filename, EXIST=FileIs )
      IF(.NOT. FileIs) EXIT
    END DO

    IF( Present(LastExisting)) THEN
      IF( LastExisting ) Filename = PrevFilename
    END IF

!------------------------------------------------------------------------------
  END FUNCTION NextFreeFilename
!------------------------------------------------------------------------------
    

END MODULE GeneralUtils
