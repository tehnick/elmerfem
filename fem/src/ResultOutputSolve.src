!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
 

SUBROUTINE ResultOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Exports data to other suitable postprocessing software.
!  Currently supported formats are GiD, VTK legacy, and Open DX.
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************

  USE DefUtils

  IMPLICIT NONE
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt, t0, t1, CPUTime
  LOGICAL :: TransientSimulation, SaveGid, SaveVTK, SaveOpenDx, SaveGmsh, &
      SaveVTU, SaveEP, ListSet = .FALSE.
  INTEGER :: nInterval=1, nstep=0, OutputCount = 0, MeshDim
  INTEGER, POINTER :: OutputIntervals(:), TimeSteps(:)

  TYPE(Mesh_t), POINTER :: Mesh
  CHARACTER(10) :: OutputFormat
  LOGICAL :: SubroutineVisited=.FALSE.,Found
    
  SAVE SubroutineVisited, OutputCount, ListSet, MeshDim


  CALL Info( 'ResultOutputSolver', '-------------------------------------')
  t0 = CPUTime()


  SaveGid = ListGetLogical(Solver % Values,'Gid Format',Found)
  SaveGmsh = ListGetLogical(Solver % Values,'Gmsh Format',Found)
  SaveVTK = ListGetLogical(Solver % Values,'VTK Format',Found)
  SaveVTU = ListGetLogical(Solver % Values,'VTU Format',Found)
  SaveOpenDx = ListGetLogical(Solver % Values,'Dx Format',Found)
  SaveEP = ListGetLogical(Solver % Values,'Elmerpost Format',Found)

  OutputFormat = GetString( Solver % Values, 'Output Format', Found )
  IF(Found) THEN
    IF( OutputFormat == "gid" )THEN
      SaveGid = .TRUE.
    ELSE IF( OutputFormat == "vtk" )THEN
      SaveVTK = .TRUE.
    ELSE IF( OutputFormat == "vtu" )THEN
      SaveVTU = .TRUE.
    ELSE IF( OutputFormat == "dx" )THEN
      SaveOpenDx = .TRUE.
    ELSE IF( OutputFormat == "gmsh" )THEN
      SaveGmsh = .TRUE.
    ELSE IF( OutputFormat == "elmerpost" )THEN
      SaveEP = .TRUE.
    ELSE
      CALL Warn( 'ResultOutputSolver', &
                 'Unknown output format "' // TRIM(OutputFormat) // '"' )
      CALL Warn( 'ResultOutputSolver', &
                 'Available formats are "GiD", "VTK", "VTU" and "DX"' )
      RETURN
    END IF
  END IF

  IF( .NOT. SubroutineVisited ) THEN
    IF ( ListGetLogical(Solver % Values,'Show Variables',Found) ) THEN
      CALL CreateListForSaving( Model, Solver % Values,.TRUE. )    
      RETURN
    END IF
  END IF

  IF(.NOT. (SaveGid .OR. SaveGmsh .OR. SaveVTK .OR. SaveVTU .OR. SaveOpenDx .OR. SaveEP)) THEN
    CALL Warn('ResultOutputSolver','No output format was defined')
    RETURN
  END IF

  IF( .NOT. ListCheckPresent( Solver % Values,'Output File Name' ) ) THEN
    CALL ListAddString( Solver % Values,'Output File Name','Case')
  END IF
  
  ! The idea of this is that the independent subroutines may be called 
  ! with different data sets and still maintaining the standard output calling convention
  OutputCount = OutputCount + 1
  CALL ListAddInteger( Solver % Values,'Output Count',OutputCount)



  ! Finally go for it and write desired data
  ! Some formats requite that the list of variables is explicitely given
  !-----------------------------------------

  Mesh => Model % Meshes
  DO WHILE( ASSOCIATED(Mesh) )
    IF ( .NOT.Mesh % OutputActive ) THEN
      Mesh => Mesh % next
      CYCLE 
    END IF
    
    CALL SetCurrentMesh( Model, Mesh )
    CALL Info('ResultOutputSolver','Working on mesh: '//TRIM(Mesh % Name) )
    WRITE(Message,'(A,I1)') 'Dimension of mesh: ',Mesh % MeshDim 
    CALL Info('ResultOutputSolver',Message)

    IF( .NOT. ListSet ) THEN
      CALL CreateListForSaving( Model, Solver % Values,.TRUE. )    
      ListSet = .TRUE.
    ELSE IF( MeshDim /= Model % Mesh % MeshDim ) THEN
      CALL CreateListForSaving( Model, Solver % Values,.TRUE.,.TRUE. )    
    END IF
    MeshDim = Model % Mesh % MeshDim

    IF( SaveGid ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in GiD format' )    
      CALL GiDOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF
    IF( SaveGmsh ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in new gmsh format' )        
      CALL GmshOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF
    IF( SaveVTK ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in legacy vtk format' )            
      CALL VtkOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF
    IF( SaveVTU ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in xml vtu format' )               
      CALL VtuOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF
    IF( SaveOpenDx ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in OpenDX format' )                   
      CALL DXOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF
    IF( SaveEP ) THEN
      CALL Info( 'ResultOutputSolver','Saving results in ElmerPost format' )                   
      CALL ElmerPostOutputSolver( Model,Solver,dt,TransientSimulation )
    END IF

    t1 = CPUTime()
    
    WRITE( Message, * ) 'Time used for saving: ',t1-t0
    CALL Info( 'ResultOutputSolver', Message )
    CALL Info( 'ResultOutputSolver', '-------------------------------------')

    Mesh => Mesh % Next
  END DO


  SubroutineVisited = .TRUE.

CONTAINS
  

!------------------------------------------------------------------------------
! Elmer may include scalar and vector variables which may be known by their
! original name or have an alias. For historical reasons they are introduced
! by two quite separate ways. This subroutine tries to make the definition of
! variables for saving more straight-forward.
!------------------------------------------------------------------------------
  SUBROUTINE CreateListForSaving( Model, List, ShowVariables, ClearList )
!------------------------------------------------------------------------------
    USE DefUtils
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    TYPE(ValueList_t),POINTER  :: List
    LOGICAL :: ShowVariables
    LOGICAL, OPTIONAL :: ClearList
!------------------------------------------------------------------------------
    INTEGER :: i,j,k,l,LoopDim, VarDim,DOFs,dim
    TYPE(Variable_t), POINTER :: Var, Var1
    CHARACTER(LEN=MAX_NAME_LEN) :: VarName, VarStr, VarStrComp, VarStrExt, str
    LOGICAL :: IsVector, Set, GotIt, ComponentVector, ThisOnly
    INTEGER :: Nvector, Nscalar

!------------------------------------------------------------------------------
! Sometimes the list must be cleared in order to use it for a different mesh
!-----------------------------------------------------------------------------
    IF( PRESENT( ClearList ) ) THEN
      IF( ClearList ) THEN
        DO i=1,99
          IF( i < 10 ) THEN
            WRITE(VarStr,'(A,I2)') 'Scalar Field',i
          ELSE
            WRITE(VarStr,'(A,I3)') 'Scalar Field',i
          END IF
          IF( ListCheckPresent( List, VarStr ) ) THEN
            CALL ListRemove( List, VarStr )
          ELSE
            EXIT
          END IF
        END DO

        DO i=1,99
          IF( i < 10 ) THEN
            WRITE(VarStr,'(A,I2)') 'Vector Field',i
          ELSE
            WRITE(VarStr,'(A,I3)') 'Vector Field',i
          END IF
          IF( ListCheckPresent( List, VarStr ) ) THEN
            CALL ListRemove( List, VarStr )
          ELSE
            EXIT
          END IF

          IF( i < 10 ) THEN
            WRITE(VarStr,'(A,I2,A)') 'Vector Field',i,' Component'
          ELSE
            WRITE(VarStr,'(A,I3,A)') 'Vector Field',i,' Component'
          END IF
          IF( ListCheckPresent( List, VarStr ) ) THEN
            CALL ListRemove( List, VarStr )
          END IF
        END DO
      END IF
    END IF
    
    !-------------------------------------------------------------------
    ! First check that there is a need to create the list i.e. it is not
    ! already manually defined
    !-------------------------------------------------------------------
    IF( ListCheckPresent( List,'Scalar Field 1' ) ) RETURN
    IF( ListCheckPresent( List,'Vector Field 1' ) ) RETURN

    Nscalar = 0
    Nvector = 0


    ThisOnly = .NOT. ListGetLogical( Solver % Values,'Interpolate Fields',GotIt)
    dim = Model % Mesh % MeshDim
    
    Var => Model % Variables
    DO WHILE( ASSOCIATED( Var ) )
      
      IF ( .NOT. Var % Output ) THEN
        Var => Var % Next
        CYCLE
      END IF
      
      IF ( SIZE( Var % Values ) == Var % DOFs ) THEN
        Var => Var % Next
        CYCLE
      END IF

      VarDim = Var % Dofs
      IsVector = (VarDim > 1)
      Set = .FALSE.

      WRITE(VarName,'(A)') TRIM(Var % Name)

      SELECT CASE(Var % Name)

      CASE( 'coordinate 1','coordinate 2','coordinate 3' )
        ! These are treated separatetely as coordinates are not typically saved


      CASE( 'mesh update' )
        ! Mesh update is treated separately because its special connection to displacement

        Var1 => Model % Variables
        DO WHILE( ASSOCIATED( Var1 ) )
          IF ( TRIM(Var1 % Name) == 'displacement' ) EXIT
          Var1 => Var1 % Next
        END DO
        IF ( .NOT. ASSOCIATED( Var1 ) ) THEN
          Set = .TRUE.
        END IF
        
      CASE('mesh update 1','mesh update 2', 'mesh update 3' )
        
      CASE( 'displacement' )
        Set = .TRUE.
        ! mesh update is by default the complement to displacement 
        Var1 => Model % Variables
        DO WHILE( ASSOCIATED( Var1 ) )
          IF ( TRIM(Var1 % Name) == 'mesh update' ) EXIT
          Var1 => Var1 % Next
        END DO
        IF ( ASSOCIATED( Var1 ) ) THEN
          IF( Nvector < 9 ) THEN
            WRITE(VarStrComp,'(A,I2,A)') 'Vector Field',Nvector+1,' Complement'
          ELSE
            WRITE(VarStrComp,'(A,I3,A)') 'Vector Field',Nvector+1,' Complement'            
          END IF
          CALL ListAddString( List ,TRIM(VarStrComp),'mesh update')
        END IF
        
      CASE( 'displacement 1','displacement 2','displacement 3')
        

      CASE DEFAULT
  
        ! All vector variables are assumed to be saved using its components
        ! rather than vector itself.

        IF ( Var % DOFs == 1 ) THEN
          Set = .TRUE. 
          
	  str =  ' '
          j = LEN_TRIM(Var % Name)
          DO i=1,j
            str(i:i) = Var % Name(i:i)
          END DO
          
          ! Check that there are exactly dim number of components
          ! If so save the quantity as a vector, otherwise componentwise
          IF( str(j:j) == '1') THEN
            IF(dim == 2) THEN
              Var1 => VariableGet(Model % Variables,TRIM(str(1:j-2))//' 2',ThisOnly)		
              IF( ASSOCIATED(Var1)) THEN
                Var1 => VariableGet(Model % Variables,TRIM(str(1:j-2))//' 3',ThisOnly)		
                IsVector = .NOT. ASSOCIATED(Var1)
              END IF
            END IF
            IF(dim == 3) THEN
              Var1 => VariableGet(Model % Variables,TRIM(str(1:j-2))//' 3',ThisOnly)		
              IF( ASSOCIATED(Var1)) THEN
                Var1 => VariableGet(Model % Variables,TRIM(str(1:j-2))//' 4',ThisOnly)		
                IsVector = .NOT. ASSOCIATED(Var1)
              END IF
            END IF
	    IF( IsVector ) THEN
              WRITE(VarName,'(A)') TRIM(str(1:j-2))
              ! Loop over the 2nd (and 3rd) components as they are already accounted for
	      DO k=2,dim
                Var => Var % Next
              END DO
            END IF
          END IF
        END IF
      END SELECT
      
      !---------------------------------------------------------------------------
      ! Set the default variable names that have not been set
      !------------------------------------------------------------------------
      IF( Set ) THEN
        IF( IsVector ) THEN
          Nvector = Nvector + 1
          IF( Nvector < 10 ) THEN 
            WRITE(VarStr,'(A,I2)') 'Vector Field',Nvector
          ELSE 
            WRITE(VarStr,'(A,I3)') 'Vector Field',Nvector
          END IF
        ELSE 
          Nscalar = Nscalar + 1
          IF( Nscalar < 10 ) THEN
            WRITE(VarStr,'(A,I2)') 'Scalar Field',Nscalar
          ELSE            
            WRITE(VarStr,'(A,I3)') 'Scalar Field',Nscalar
          END IF
        END IF
        CALL ListAddString( List,TRIM(VarStr),TRIM(VarName) )
      END IF

      Var => Var % Next
    END DO


    IF( ShowVariables ) THEN
      CALL Info('CreateListForSaving','Field Variables for Saving')
      DO i=1,Nscalar
        IF( i < 10 ) THEN
          WRITE(VarStr,'(A,I2)') 'Scalar Field',i
        ELSE
          WRITE(VarStr,'(A,I3)') 'Scalar Field',i
        END IF
        VarName = ListGetString( List, VarStr,GotIt )
        IF( GotIt ) THEN
          WRITE( Message,'(A)') TRIM(VarStr)//': '//TRIM(VarName)
          CALL Info('CreateListForSaving',Message)
        END IF
      END DO

      DO i=1,Nvector
        IF( i < 10 ) THEN
          WRITE(VarStr,'(A,I2)') 'Vector Field',i
        ELSE
          WRITE(VarStr,'(A,I3)') 'Vector Field',i
        END IF
        VarName = ListGetString( List, VarStr,GotIt )
        IF( GotIt ) THEN
          WRITE( Message,'(A)') TRIM(VarStr)//': '//TRIM(VarName)
          CALL Info('CreateListForSaving',Message)
        END IF
      END DO

      DO i=1,Nvector
        IF( i < 10 ) THEN
          WRITE(VarStr,'(A,I2,A)') 'Vector Field',i,' Complement'
        ELSE
          WRITE(VarStr,'(A,I3,A)') 'Vector Field',i,' Complement'
        END IF
        VarName = ListGetString( List, VarStr, GotIt )
        IF( GotIt ) THEN
          WRITE( Message,'(A)') TRIM(VarStr)//': '//TRIM(VarName)
          CALL Info('CreateListForSaving',Message)
        END IF
      END DO
    END IF


  END SUBROUTINE CreateListForSaving
  
END SUBROUTINE ResultOutputSolver


!------------------------------------------------------------------------------
  SUBROUTINE ElmerPostOutputSolver( Model, Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
    USE DefUtils
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
    INTEGER :: TimeCount
    CHARACTER(LEN=512) :: PostFile, FilePrefix
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Variable_t), POINTER :: Var,Var1,Displacement,MeshUpdate,MaskVar
    
    CHARACTER(LEN=512) :: Row
    CHARACTER(MAX_NAME_LEN) :: Str, DateStr, VarName, Txt
    
    LOGICAL :: gotIt, FreeSurfaceFlag, MoveBoundary, MeshMoved, MaskExists
    INTEGER :: ScalarFields, VectorFields
    REAL(KIND=dp) :: Time,MeshScale, NodeCoords(3)
    REAL(KIND=dp), POINTER :: Values(:), Values2(:), Values3(:)
    INTEGER :: ii,i,j,k,l,n,m,q,Node,DOFs,TimeStep, &
         NumberOfNodes, NumberOfElements, ind, Vari, DIM, ExtCount
    INTEGER, POINTER :: MaskPerm(:), MaskOrder(:), TimeSteps(:)

    INTEGER, SAVE :: SavedCount = 0
    LOGICAL :: Visited 
!------------------------------------------------------------------------------
    
    dim = Model % Mesh % MeshDim
    ExtCount = ListGetInteger( Solver % Values,'Output Count',GotIt)
    
    IF( GotIt ) THEN
      SavedCount = ExtCount 
    ELSE
      SavedCount = SavedCount + 1
    END IF
    Visited = ( SavedCount > 1 )

    Timesteps => ListGetIntegerArray( CurrentModel % Simulation, &
        'Timestep Intervals', GotIt )
    IF( GotIt ) THEN
      TimeCount = SUM(TimeSteps)
    ELSE 
      TimeCount = ListGetInteger( Model % Simulation,'Steady State Max Iterations')
    END IF
    
    FilePrefix = GetString( Solver % Values,'Output File Name',GotIt )
    IF ( .NOT.GotIt ) FilePrefix = "Output"
    
    IF(INDEX(FilePrefix,'.') == 0) THEN
      WRITE( Postfile,'(A,A)') TRIM(FilePrefix),".ep"
    ELSE
      PostFile = FilePrefix
    END IF
    
    IF ( INDEX( PostFile, ':') == 0 .AND. PostFile(1:1) /= '/' .AND. &
        PostFile(1:1) /= Backslash ) THEN
      
      IF ( LEN_TRIM(OutputPath) > 0 ) THEN
        IF ( Visited )  THEN
          OPEN( PostFileUnit,File=TRIM(OutputPath) // '/' // &
              TRIM(PostFile), POSITION='APPEND' )
        ELSE
          OPEN( PostFileUnit,File=TRIM(OutputPath) // '/' // &
              TRIM(PostFile),STATUS='UNKNOWN' )
        END IF
      ELSE
        IF ( Visited ) THEN
          OPEN( PostFileUnit,File=TRIM(PostFile),POSITION='APPEND' )
        ELSE
          OPEN( PostFileUnit,File=TRIM(PostFile),STATUS='UNKNOWN' )
        ENDIF
      END IF
    ELSE
      IF ( Visited  ) THEN
        OPEN( PostFileUnit,File=TRIM(PostFile),POSITION='APPEND' )
      ELSE
        OPEN( PostFileUnit,File=TRIM(PostFile),STATUS='UNKNOWN' )
      END IF
    END IF


    FreeSurfaceFlag = .FALSE.
    MoveBoundary    = .FALSE.
    DO i=1,CurrentModel % NumberOfBCs
      FreeSurfaceFlag = FreeSurfaceFlag .OR. ListGetLogical( &
          CurrentModel % BCs(i) % Values,'Free Surface', GotIt )
      IF ( FreeSurfaceFlag ) THEN
        MoveBoundary =  ListGetLogical( &
            CurrentModel % BCs(i) % Values,'Internal Move Boundary', GotIt )
        
        IF ( .NOT. GotIt ) MoveBoundary = .TRUE.
        
        FreeSurfaceFlag = FreeSurfaceFlag .AND. MoveBoundary
      END IF
      
      IF ( FreeSurfaceFlag ) EXIT
    END DO
    
!------------------------------------------------------------------------------
! Initialize stuff for masked saving
!------------------------------------------------------------------------------
    Str = ListGetString( Solver % Values,'Mask Variable',MaskExists)
    IF( MaskExists ) THEN
      MaskVar => VariableGet(Model % Variables,TRIM(Str))
      IF( ASSOCIATED(MaskVar)) MaskPerm => MaskVar % Perm
      MaskExists = ASSOCIATED(MaskPerm)
    END IF
    IF(MaskExists) THEN
      CALL Info('ElmerPostOutputSolver','Using > '// TRIM(Str) // ' < as mask variable')
      NumberOfNodes = MAXVAL(MaskPerm)
      ALLOCATE(MaskOrder(NumberOfNodes))
      DO i=1,SIZE(MaskPerm)
        j = MaskPerm(i)
        IF(j > 0) MaskOrder(j) = i
      END DO
      NumberOfElements = 0
      DO i=1,Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
        CurrentElement => Model % Elements(i)
        IF( ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) THEN
          NumberOfElements = NumberOfElements + 1
        END IF
      END DO
    ELSE
      NumberOfNodes = Model % NumberOfNodes
      NumberOfElements =  Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
    END IF
 
!------------------------------------------------------------------------------
!   Count degrees of freedom to be saved
!------------------------------------------------------------------------------
    
    DO Vari = 1, 99
      IF( Vari < 10 ) THEN
        WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
      ELSE
        WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
      END IF
      IF( .NOT. ListCheckPresent( Solver % Values, TRIM(Txt)) ) EXIT
    END DO
    ScalarFields = Vari - 1
    
    DO Vari = 1, 99
      IF( Vari < 10 ) THEN
        WRITE(Txt,'(A,I2)') 'Vector Field',Vari
      ELSE
        WRITE(Txt,'(A,I3)') 'Vector Field',Vari
      END IF
      IF( .NOT. ListCheckPresent( Solver % Values, TRIM(Txt)) ) EXIT
    END DO
    VectorFields = Vari - 1
    
    IF( ScalarFields + VectorFields == 0 ) RETURN
    
    Dofs = ScalarFields + 3 * VectorFields

!------------------------------------------------------------------------------
! Write header to output
!------------------------------------------------------------------------------
    IF ( .NOT. Visited ) THEN
      WRITE(PostFileUnit,'(i10,i10,i7,i7)',ADVANCE='NO' ) NumberOfNodes, &
          NumberOfElements, DOFs, TimeCount
      
      DO Vari = 1, ScalarFields
        IF( Vari < 10 ) THEN
          WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
        ELSE
          WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
        END IF
        VarName = ListGetString( Solver % Values, TRIM(Txt) )

	VarName(1:1) = CHAR(ICHAR(VarName(1:1))-ICHAR('a')+ICHAR('A'))
        k = LEN_TRIM(VarName)
        DO j=1,k
          IF ( VarName(j:j) == ' ' ) VarName(j:j) = '.'
        END DO
       
        WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' scalar: '//TRIM(VarName)
      END DO
      
      DO Vari = 1, VectorFields
        IF( Vari < 10 ) THEN
          WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF

        VarName = ListGetString( Solver % Values, TRIM(Txt),GotIt)

	VarName(1:1) = CHAR(ICHAR(VarName(1:1))-ICHAR('a')+ICHAR('A'))
        k = LEN_TRIM(VarName)
        DO j=1,k
          IF ( VarName(j:j) == ' ' ) VarName(j:j) = '.'
        END DO

        WRITE(PostFileUnit,'(a)',ADVANCE='NO' ) ' vector: '//TRIM(VarName)
      END DO
      
      WRITE(PostFileUnit,'()')
      DateStr = FormatDate()
      WRITE( PostFileUnit, '("#File started at: ",A)' ) TRIM(DateStr)
!------------------------------------------------------------------------------
!   Coordinates
!------------------------------------------------------------------------------
!
      MeshScale = 1.0_dp
      DO i=1,Model % NumberOfSolvers
        IF ( Model % Solvers(i) % Variable % NameLen <= 0 ) CYCLE
        
        IF (Model % Solvers(i) % Variable % Name &
            (1:Model % Solvers(i) % Variable % NameLen) == 'displacement') THEN
          MeshMoved = ListGetLogical( Model % Solvers(i) % Values, &
              'Displace Mesh', Gotit )
          IF ( Gotit .AND. .NOT. MeshMoved ) MeshScale = 0.0_dp
        END IF
      END DO
      
      
      DO ii=1,NumberOfNodes
        
        i = ii
        IF(MaskExists) i = MaskOrder(i)

        NodeCoords(1) = Model % Nodes % x(i)
        NodeCoords(2) = Model % Nodes % y(i)
        NodeCoords(3) = Model % Nodes % z(i)
        
        IF ( ASSOCIATED(Displacement) ) THEN
          k = Displacement % Perm(i)
          
          IF ( k > 0 ) THEN
            k = Displacement % DOFs * (k-1)
            NodeCoords(1) = NodeCoords(1) - MeshScale*Displacement % Values(k+1)
            IF( Displacement % DOFs >= 2) THEN
              NodeCoords(2) = NodeCoords(2) - MeshScale*Displacement % Values(k+2)
            END IF
            IF( Displacement % DOFs == 3) THEN
              NodeCoords(3) = NodeCoords(3) - MeshScale*Displacement % Values(k+3)
            END IF
          ELSE
            IF ( ASSOCIATED( MeshUpdate ) ) k = MeshUpdate % Perm(i)
            
            k = MeshUpdate % DOFs * (k-1)
            NodeCoords(1) = NodeCoords(1) - MeshUpdate % Values(k+1)
            IF( MeshUpdate % DOFs >= 2) THEN
              NodeCoords(2) = NodeCoords(2) - MeshUpdate % Values(k+2)
            END IF
            IF( MeshUpdate % DOFs == 3) THEN
              NodeCoords(3) = NodeCoords(3) - MeshUpdate % Values(k+3)
            END IF
          END IF
        END IF

        IF( DIM <= 2 ) THEN           
          WRITE(PostFileUnit,'(2ES16.7E3 A)') NodeCoords(1:2), ' 0.0'
        ELSE
          WRITE(PostFileUnit,'(3ES16.7E3 A)') NodeCoords(1:3)
        END IF

      END DO

!------------------------------------------------------------------------------
! Elements
!------------------------------------------------------------------------------
      WRITE(PostFileUnit,'(a)') '#group all'
      DO i=1,Model % NumberOfBulkElements
        CurrentElement => Model % Elements(i)
        
        IF(MaskExists) THEN
          IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
        END IF
        
        k = CurrentElement % BodyId
        gotIt = .FALSE.
        IF ( k >= 1 .AND. k <= Model % NumberOfBodies ) THEN
          Str = ListGetString( Model % Bodies(k) % Values,'Name',gotIt )
        END IF
        
        IF ( gotIt ) THEN
          k = LEN_TRIM(Str)
          DO j=1,k
            IF ( Str(j:j) == ' ' ) Str(j:j) = '.'
          END DO
          
          WRITE( PostFileUnit,'(a)',ADVANCE='NO' )  Str(1:k)
        ELSE
          IF ( k > 0 .AND. k < 10 ) THEN
            WRITE(PostFileUnit,'(a,i1,a)',ADVANCE='NO' ) 'body',k,' '
          ELSE IF ( k >= 10 .AND. k < 100 ) THEN
            WRITE(PostFileUnit,'(a,i2,a)',ADVANCE='NO' ) 'body',k,' '
          ELSE
            WRITE(PostFileUnit,'(a,i3,a)',ADVANCE='NO' ) 'body',k,' '
          END IF
        END IF
        
        WRITE(PostFileUnit,'(i5)', ADVANCE='NO') CurrentElement % TYPE % ElementCode
        n = 0
        DO j=1,CurrentElement % TYPE % NumberOfNodes,4
          DO k=1,MIN(4,CurrentElement % TYPE % NumberOfNodes-n)
            n = n + 1
            ind = CurrentElement % NodeIndexes(n)
            IF(MaskExists) ind = MaskPerm(ind)
            WRITE(PostFileUnit, '(i8)', ADVANCE='NO')  ind - 1
          END DO
          WRITE( PostFileUnit,'(a)' ) ''
        END DO
      END DO
      
      DO i=Model % NumberOfBulkElements + 1,Model % NumberOfBulkElements + &
          Model % NumberOfBoundaryElements
        
        CurrentElement => Model % Elements(i)
        
        IF(MaskExists) THEN
          IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
        END IF
        
        k = CurrentElement % BoundaryInfo % Constraint
        
        gotIt = .FALSE.
        IF ( k >= 1 .AND. k <= Model % NumberOfBCs ) THEN
          Str = ListGetString( Model % BCs(k) % Values,'Name',gotIt )
        END IF
        
        IF ( gotIt ) THEN
          k = LEN_TRIM(Str)
          DO j=1,k
            IF ( Str(j:j) == ' ' ) Str(j:j) = '.'
          END DO
          
          WRITE( PostFileUnit,'(a)',ADVANCE='NO' )  Str(1:k)
        ELSE
          IF ( k < 10 ) THEN
            WRITE( PostFileUnit,'(a,i1,a)',ADVANCE='NO' ) 'Constraint', k, ' '
          ELSE IF ( k < 100 ) THEN
            WRITE( PostFileUnit,'(a,i2,a)',ADVANCE='NO' ) 'Constraint', k, ' '
          ELSE
            WRITE( PostFileUnit,'(a,i3,a)',ADVANCE='NO' ) 'Constraint', k, ' '
          END IF
        END IF
        
        WRITE(PostFileUnit,'(i5)', ADVANCE='NO') CurrentElement % TYPE % ElementCode
        DO k=1,CurrentElement % TYPE % NumberOfNodes
          ind = CurrentElement % NodeIndexes(k)
          IF(MaskExists) ind = MaskPerm(ind)
          WRITE( PostFileUnit, '(i8)', ADVANCE='NO' )  ind-1
        END DO
        WRITE( PostFileUnit,'(a)' ) ''
      END DO
      WRITE(PostFileUnit,'(a)') '#endgroup all'
    END IF
   
!------------------------------------------------------------------------------
!  Save resulst on a timestep (or steady state iteration step)
!------------------------------------------------------------------------------
 
    TimeStep   = SavedCount
    Var => VariableGet( Model % Variables, 'Time' )        
    Time = 1.0d0
    IF ( ASSOCIATED(Var) ) Time = Var % Values(1)

    
    WRITE( PostFileUnit,'(a,i7,i7,ES16.7E3)' ) '#time ',SavedCount,Timestep,Time

    DO ii=1,NumberOfNodes
      
      i = ii
      IF(MaskExists) i = MaskOrder(i)
      
      DO Vari = 1, ScalarFields
        IF( Vari < 10 ) THEN
          WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
        ELSE
          WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
        END IF
        VarName = ListGetString( Solver % Values, TRIM(Txt),GotIt)
        Var => VariableGet( Model % Variables, TRIM(VarName) ) 
        Values => Var % Values

        k = i
        IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
        IF ( k > 0 ) THEN
          WRITE(PostFileUnit,'(ES16.7E3)',ADVANCE='NO') Values(k)
        ELSE
          WRITE(PostFileUnit,'(A)',ADVANCE='NO') ' 0.0'
        END IF
      END DO

      DO Vari = 1, VectorFields

        IF( Vari < 10 ) THEN
          WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF
        VarName = ListGetString( Solver % Values, TRIM(Txt),GotIt)
        Var => VariableGet( Model % Variables, VarName ) 

        IF( ASSOCIATED(Var) ) THEN
          k = i
          Dofs = Var% Dofs
          IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)
          
          IF( k == 0 ) THEN
            ! Check for the presence of secondary variable (in practice 'mesh update')
            IF( Vari < 10 ) THEN
              WRITE(Txt,'(A,I2,A)') 'Vector Field',Vari,' Complement'
            ELSE
              WRITE(Txt,'(A,I3,A)') 'Vector Field',Vari,' Complement'
            END IF
            VarName = ListGetString( Solver % Values, TRIM(Txt),GotIt)
            IF( GotIt ) THEN
              Var => VariableGet( Model % Variables, VarName ) 
              k = Var % Perm(i)
            END IF
          END IF
          
          IF( k > 0 ) THEN
            DO j=1,dofs
              WRITE(PostFileUnit,'(ES16.7E3)',ADVANCE='NO') Var % Values(dofs*(k-1)+j)
            END DO
            IF( dofs < 3 ) THEN
              WRITE(PostFileUnit,'(A)',ADVANCE='NO') ' 0.0'
            END IF
          ELSE 
            WRITE(PostFileUnit,'(A)',ADVANCE='NO') ' 0.0 0.0 0.0'
          END IF
          
        ELSE
          ! Check for the presence of component vectors given by its components i=1,2,3
          Var => VariableGet( Model % Variables, TRIM(VarName)//' 1' ) 
          IF( ASSOCIATED(Var)) THEN
            k = i
            IF ( ASSOCIATED(Var % Perm) ) k = Var % Perm(k)

            IF( k == 0 ) THEN
              IF( Vari < 10 ) THEN
                WRITE(Txt,'(A,I2,A)') 'Vector Field',Vari,' Complement'
              ELSE
                WRITE(Txt,'(A,I3,A)') 'Vector Field',Vari,' Complement'
              END IF
              VarName = ListGetString( Solver % Values, TRIM(Txt),GotIt)
              IF( GotIt ) THEN
                Var => VariableGet( Model % Variables, TRIM(VarName)//' 1' ) 
                k = Var % Perm(i)
              END IF
            END IF
            IF( k > 0 ) THEN
              Values => Var % Values
              Var => VariableGet( Model % Variables, TRIM(VarName)//' 2' ) 
              Values2 => Var % Values
              IF( dim == 2 ) THEN
                WRITE(PostFileUnit,'(2ES16.7E3,A)',ADVANCE='NO') Values(k),&
                    Values2(k),' 0.0'               
              ELSE
                Var => VariableGet( Model % Variables, TRIM(VarName)//' 3' ) 
                Values3 => Var % Values
                WRITE(PostFileUnit,'(3ES16.7E3)',ADVANCE='NO') Values(k),&
                    Values2(k), Values3(k)
              END IF
            ELSE
              WRITE(PostFileUnit,'(A)',ADVANCE='NO') ' 0.0 0.0 0.0'              
            END IF
          END IF
        END IF
      END DO
      
      WRITE(PostFileUnit,'()')
    END DO

!------------------------------------------------------------------------------
!   We are done here close the files and deallocate
!------------------------------------------------------------------------------
    CLOSE(PostFileUnit)
    
    IF(MaskExists) DEALLOCATE(MaskOrder)

  END SUBROUTINE ElmerPostOutputSolver
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
SUBROUTINE GiDOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
  USE DefUtils
  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Element_t),POINTER :: Element
  TYPE(Variable_t), POINTER :: Solution
  INTEGER, POINTER :: Perm(:)
  REAL(KIND=dp), POINTER :: Values(:)
  COMPLEX(KIND=dp), POINTER :: CValues(:)
  TYPE(Variable_t), POINTER :: TimeVariable
  TYPE(ValueList_t), POINTER :: SolverParams

  LOGICAL :: Found, CoordinatesWritten = .FALSE.
  LOGICAL :: EigenAnalysis = .FALSE., FirstTimeStep

  INTEGER :: i,j,k,m,n,dim, Code, body_id, ElementCounter, Nloop, Loop, ExtCount
  INTEGER :: tensorComponents, SteadyStep = 0
  INTEGER, PARAMETER :: MaxElemCode = 1000
  INTEGER :: ListElemTypes(MaxElemCode)


  CHARACTER(LEN=1024) :: OutputFile, ResFile, MshFile, Txt, Family, &
       ScalarFieldName, VectorFieldName, TensorFieldName, CompName
  CHARACTER(LEN=1024) :: Txt2, Txt3

  INTEGER :: PyramidMap613(14,4), PyramidMap605(2,4)
  INTEGER :: WedgeMap706(3,4), WedgeMap715(21,4)

!------------------------------------------------------------------------------

  PyramidMap605(1,:) = (/ 3, 5, 4, 1 /)
  PyramidMap605(2,:) = (/ 3, 5, 2, 1 /)

  PyramidMap613(1,:)  = (/ 7, 8, 3, 12 /)
  PyramidMap613(2,:)  = (/ 10, 11, 12, 5 /)
  PyramidMap613(3,:)  = (/ 10, 13, 12, 5 /)
  PyramidMap613(4,:)  = (/ 9, 10, 13, 11 /)
  PyramidMap613(5,:)  = (/ 9, 13, 11, 12 /)
  PyramidMap613(6,:)  = (/ 9, 10, 11, 1 /)
  PyramidMap613(7,:)  = (/ 9, 6, 11, 1 /)
  PyramidMap613(8,:)  = (/ 9, 6, 11, 12 /)
  PyramidMap613(9,:)  = (/ 9, 8, 12, 4 /)
  PyramidMap613(10,:) = (/ 9, 13, 12, 4 /)
  PyramidMap613(11,:) = (/ 7, 9, 8, 12 /)
  PyramidMap613(12,:) = (/ 7, 9, 6, 12 /)
  PyramidMap613(13,:) = (/ 7, 6, 11, 12 /)
  PyramidMap613(14,:) = (/ 7, 6, 11, 2 /)

  WedgeMap706(1,:) = (/ 5, 4, 3, 1 /)
  WedgeMap706(2,:) = (/ 5, 3, 2, 1 /)
  WedgeMap706(3,:) = (/ 5, 6, 4, 3 /)

  WedgeMap715(1,:) = (/ 10, 11, 5, 2 /)
  WedgeMap715(2,:) = (/ 12, 11, 6, 3 /)
  WedgeMap715(3,:) = (/ 12, 10, 4, 1 /)
  WedgeMap715(4,:) = (/ 7, 8, 11, 2 /)
  WedgeMap715(5,:) = (/ 7, 10, 11, 2 /)
  WedgeMap715(6,:) = (/ 13, 14, 11, 5 /)
  WedgeMap715(7,:) = (/ 13, 10, 11, 5 /)
  WedgeMap715(8,:) = (/ 9, 10, 8, 11 /)
  WedgeMap715(9,:) = (/ 9, 7, 10, 8 /)
  WedgeMap715(10,:) = (/ 9, 12, 10, 11 /)
  WedgeMap715(11,:) = (/ 9, 12, 10, 1 /)
  WedgeMap715(12,:) = (/ 9, 7, 10, 1 /)
  WedgeMap715(13,:) = (/ 9, 8, 11, 3 /)
  WedgeMap715(14,:) = (/ 9, 12, 11, 3 /)
  WedgeMap715(15,:) = (/ 15, 12, 10, 11 /)
  WedgeMap715(16,:) = (/ 15, 12, 10, 4 /)
  WedgeMap715(17,:) = (/ 15, 10, 14, 11 /)
  WedgeMap715(18,:) = (/ 15, 13, 10, 14 /)
  WedgeMap715(19,:) = (/ 15, 13, 10, 4 /)
  WedgeMap715(20,:) = (/ 15, 14, 11, 6 /)
  WedgeMap715(21,:) = (/ 15, 12, 11, 6 /)

  SolverParams => GetSolverParams()
  EigenAnalysis = GetLogical( SolverParams, 'Eigen Analysis', Found )

  
  ExtCount = ListGetInteger( Solver % Values,'Output Count',Found)
  IF( Found ) THEN
    SteadyStep = ExtCount 
  ELSE
    SteadyStep = SteadyStep + 1
  END IF
  FirstTimeStep = ( SteadyStep == 1 )


  OutputFile = GetString( Solver % Values, 'Output File Name', Found )
  IF(.NOT. Found) OutputFile = 'Output'

  WRITE(ResFile,'(A,A)') TRIM(OutputFile),'.flavia.res'
  WRITE(MshFile,'(A,A)') TRIM(OutputFile),'.flavia.msh'


  CALL Info('GidOutputSolver','Writing result for GiD postprocessing')
  CALL Info('GidOutputSolver','res-file = :'//TRIM(ResFile) )
  CALL Info('GidOutputSolver','msh-file = :'//TRIM(MshFile) )


  ! Write the GiD msh-file:
  !------------------------
  dim = CoordinateSystemDimension()
  IF( CoordinatesWritten ) GOTO 10

  OPEN( UNIT=10, FILE=MshFile )

  ! First check how many element types are involved in the analysis:
  !-----------------------------------------------------------------
  ListElemTypes = 0
  ElementCounter = 0
!  DO i = 1, Solver % NumberOfActiveElements
!     Element => GetActiveElement(i)
  DO i = 1, Model % NumberOfBulkElements !+ Model % NumberOfBoundaryElements
     Element => Model % Mesh % Elements(i)

     Code = Element % TYPE % ElementCode
     ListElemTypes(Code) = ListElemTypes(Code)+1
  END DO
  PRINT *,'Total number of elements =',SUM(ListElemTypes)

  ! Write the different element types in different blocks:
  !-------------------------------------------------------
  DO i = 1,MaxElemCode
     IF(ListElemTypes(i) == 0) CYCLE
     PRINT *,ListElemTypes(i),'elements of type',i
     n = MOD(i,100)
     IF( INT(i/100) == 1 ) Family = 'Point'
     IF( INT(i/100) == 2 ) Family = 'Linear'
     IF( INT(i/100) == 3 ) Family = 'Triangle'
     IF( INT(i/100) == 4 ) Family = 'Quadrilateral'
     IF( INT(i/100) == 5 ) Family = 'Tetrahedra'
     IF( INT(i/100) == 6 ) THEN
        Family = 'Tetrahedra' ! PYRAMIDS WILL BE SPLITTED
        n = 4                 ! INTO LINEAR TETRAHEDRA
     END IF
     IF( INT(i/100) == 7 ) THEN
        Family = 'Tetrahedra' ! WEDGES WILL BE SPLITTED
        n = 4                 ! INTO LINEAR TETRAHEDRA
     END IF
     IF( INT(i/100) == 8 ) Family = 'Hexahedra'

     IF( n < 10 ) THEN
        WRITE(Txt,'(A,I1,A,A,A,I2)') 'MESH "Elmer Mesh" dimension ',&
             dim,' ElemType ', TRIM(Family),' Nnode', n
     ELSE
        WRITE(Txt,'(A,I1,A,A,A,I3)') 'MESH "Elmer Mesh" dimension ',&
             dim,' ElemType ', TRIM(Family),' Nnode', n
     END IF

     WRITE(10,'(A)') TRIM(Txt)

     ! Write all node coordinates in the first block:
     !-----------------------------------------------
     IF( .NOT.CoordinatesWritten ) THEN
        WRITE(10,'(A)') 'Coordinates'
        DO j = 1, Model % Mesh % NumberOfNodes
           WRITE(10,'(I6,3ES16.7E3)') j, &
                Model % Mesh % Nodes % x(j), &
                Model % Mesh % Nodes % y(j), &
                Model % Mesh % Nodes % z(j)
        END DO
        WRITE(10,'(A)') 'end coordinates'
        WRITE(10,'(A)') ' '
        CoordinatesWritten = .TRUE.
     END IF

     ! Write the element connectivity tables:
     !---------------------------------------
     WRITE(10,'(A)') 'Elements'
!     DO j = 1, Solver % NumberOfActiveElements
!        Element => GetActiveElement( j )
     DO j = 1, Model % NumberOfBulkElements !+ Model % NumberOfBoundaryElements
        Element => Model % Mesh % Elements(j)

        Code = Element % TYPE % ElementCode
        IF( Code /= i ) CYCLE
        body_id = Element % BodyId

        IF( Code == 613 ) THEN
           ! 13 noded pyramids will be splitted into 14 linear tetraheda
           !------------------------------------------------------------
           DO m = 1,14
              ElementCounter = ElementCounter + 1
              WRITE(10,'(100I10)') ElementCounter, &
                   Element % NodeIndexes(PyramidMap613(m,:)), body_id
           END DO
        ELSEIF( Code == 605 ) THEN
           ! 5 noded pyramids will be splitted into 2 linear tetraheda
           !----------------------------------------------------------
           DO m = 1,2
              ElementCounter = ElementCounter + 1
              WRITE(10,'(100I10)') ElementCounter, &
                   Element % NodeIndexes(PyramidMap605(m,:)), body_id
           END DO           
        ELSEIF( Code == 706 ) THEN
           ! 6 noded wedges will be splitted into 3 linear tetraheda
           !---------------------------------------------------------
           DO m = 1,3
              ElementCounter = ElementCounter + 1
              WRITE(10,'(100I10)') ElementCounter, &
                   Element % NodeIndexes(WedgeMap706(m,:)), body_id
           END DO           
        ELSEIF( Code == 715 ) THEN
           ! 15 noded wedges will be splitted into 21 linear tetraheda
           !----------------------------------------------------------
           DO m = 1,21
              ElementCounter = ElementCounter + 1
              WRITE(10,'(100I10)') ElementCounter, &
                   Element % NodeIndexes(WedgeMap715(m,:)), body_id
           END DO           
        ELSE
           ! Standard elements are understood by GiD as such
           !------------------------------------------------
           ElementCounter = ElementCounter + 1 
           WRITE(10,'(100I10)') ElementCounter, Element % NodeIndexes, body_id
        END IF

     END DO
     WRITE(10,'(A)') 'end elements'
     WRITE(10,'(A)') ' '
  END DO

10 CONTINUE
  
  ! Write the GiD res-file:
  !------------------------
  IF( FirstTimeStep ) THEN
    OPEN(UNIT=10, FILE=ResFile )
    WRITE(10,'(A)') 'GiD Post Result File 1.0'
  ELSE
    OPEN(UNIT=10, FILE=ResFile, POSITION='APPEND' )
  END IF

  Nloop = 1
  IF( EigenAnalysis ) THEN
     Nloop = GetInteger( Solver % Values, 'Eigen System Values', Found )
     IF( .NOT.Found ) Nloop = 1
   END IF

   DO Loop = 1, Nloop
     PRINT *,'------------'

     ! First scalar fields:
     !----------------------
     DO i = 1, 99
       IF( i<10 ) THEN
         WRITE(Txt,'(A,I2)') 'Scalar Field',i
       ELSE
         WRITE(Txt,'(A,I3)') 'Scalar Field',i
       END IF
       
       ScalarFieldName = GetString( Solver % Values, TRIM(Txt), Found )
       IF(.NOT. Found) EXIT
       
       Solution => VariableGet( Model % Mesh % Variables, ScalarFieldName )
       IF( .NOT.ASSOCIATED( Solution ) ) THEN
         PRINT *,'Scalar field "',TRIM(ScalarFieldName),'" not found'
       ELSE
         PRINT *,'Scarar field',i,'= "',TRIM(ScalarFieldName),'"'
         Perm => Solution % Perm
         
         IF( .NOT.EigenAnalysis ) THEN
           Values => Solution % Values
         ELSE
           Cvalues => Solution % EigenVectors(Loop,:)
         END IF
         
         IF( TransientSimulation ) THEN
           TimeVariable => VariableGet( Model % Mesh % Variables, 'Time' )
           PRINT *,'Current time=',TimeVariable % Values(1)
           WRITE(10,'(A,A,A,ES16.7E3,A)') 'Result "',&
               TRIM(ScalarFieldName),'" "Transient analysis" ', &
               TimeVariable % Values(1) ,' Scalar OnNodes'
         ELSE
           IF( .NOT.EigenAnalysis ) THEN
             WRITE(10,'(A,A,A,I2,A)') 'Result "',&
                 TRIM(ScalarFieldName),'" "Steady analysis"',SteadyStep,' Scalar OnNodes'
           ELSE
             WRITE(10,'(A,A,A,I2,A)') 'Result "',&
                 TRIM(ScalarFieldName),'" "Eigen analysis"',Loop,' Scalar OnNodes'
           END IF
         END IF
         
         WRITE(10,'(A,A,A)') 'ComponentNames "',TRIM(ScalarFieldName),'"'
         WRITE(10,'(A)') 'Values'
         DO j = 1, Model % Mesh % NumberOfNodes
           k = Perm(j)
           IF( .NOT.EigenAnalysis ) THEN
             WRITE(10,'(I6,ES16.7E3)') j, Values(k)
           ELSE
             WRITE(10,'(I6,ES16.7E3)') j, REAL(CValues(k))
           END IF
         END DO
         WRITE(10,'(A)') 'end values'
         WRITE(10,'(A)') ' '
       END IF
     END DO

     ! Then vector fields:
     !--------------------
     DO i = 1, 99
       IF( i<10 ) THEN
         WRITE(Txt,'(A,I2)') 'Vector Field',i
       ELSE
         WRITE(Txt,'(A,I3)') 'Vector Field',i
       END IF
       
       VectorFieldName = GetString( Solver % Values, TRIM(Txt), Found )
       IF(.NOT. Found) EXIT
       PRINT *,'Vector field',i,'= "',TRIM(VectorFieldName),'"'
       
       IF( TransientSimulation ) THEN
         TimeVariable => VariableGet( Model % Mesh % Variables, 'Time' )
         PRINT *,'Current time=',TimeVariable % Values(1)
         WRITE(10,'(A,A,A,ES16.7E3,A)') 'Result "',&
             TRIM(VectorFieldName),'" "Transient analysis" ', &
             TimeVariable % Values(1) ,' Vector OnNodes'
       ELSE
         IF( .NOT.EigenAnalysis ) THEN
           WRITE(10,'(A,A,A,I2,A)') 'Result "',&
               TRIM(VectorFieldName),'" "Steady analysis"',SteadyStep,' Vector OnNodes'
         ELSE
           WRITE(10,'(A,A,A,I2,A)') 'Result "',&
               TRIM(VectorFieldName),'" "Eigen analysis"',Loop,' Vector OnNodes'
         END IF
       END IF
       
       WRITE(Txt,'(A)') 'ComponentNames '
       DO j = 1, dim
         IF(j<Dim) THEN
           WRITE(Txt,'(A,A,A,I2,A)' ) &
               TRIM(Txt), ' "', TRIM(VectorFieldName),j,'",'
         ELSE
           WRITE(Txt,'(A,A,A,I2,A)' ) &
               TRIM(Txt), ' "', TRIM(VectorFieldName),j,'"'
         END IF
       END DO
       WRITE(10,'(A)') TRIM(Txt)
       WRITE(10,'(A)') 'Values'
       
       DO j = 1, Model % Mesh % NumberOfNodes
         WRITE(Txt2,'(I10)') j
         DO k = 1,dim
           
           ! Check if vector field components have been defined explicitely:
           !----------------------------------------------------------------
           WRITE(Txt3,'(A,I1,A,I1)') 'Vector Field ',i,' component ',k
           CompName = GetString( Solver % Values, TRIM(Txt3), Found )
           IF( Found ) THEN
             WRITE(Txt,'(A)') TRIM(CompName)
           ELSE
             WRITE(Txt,'(A,I2)') TRIM(VectorFieldName), k
           END IF
           
           IF( j==1 ) PRINT *, TRIM(Txt3),' = "', TRIM(Txt),'"'
           
           Solution => VariableGet( Model % Mesh % Variables, TRIM(Txt) )
           IF( .NOT.ASSOCIATED( Solution ) ) THEN
             PRINT *,'Vector field component',k,' not found'
           ELSE
             Perm => Solution % Perm
             
             IF( .NOT.EigenAnalysis ) THEN
               Values => Solution % Values
               WRITE(Txt2,'(A,ES16.7E3)') TRIM(Txt2), Values( Perm(j) )
             ELSE
               CValues => Solution % Eigenvectors(Loop,:)
               WRITE(Txt2,'(A,ES16.7E3)') TRIM(Txt2), REAL(CValues( Perm(j) ) )
             END IF
             
           END IF
         END DO
         WRITE(10,'(A)') TRIM(Txt2)
         
       END DO
       WRITE(10,'(A)') 'end values'
     END DO
     

     ! Finally tensor fields:
     !-----------------------
     DO i = 1, 99
       IF( i<10 ) THEN
         WRITE(Txt,'(A,I2)') 'Tensor Field',i
       ELSE
         WRITE(Txt,'(A,I3)') 'Tensor Field',i
       END IF
       
       TensorFieldName = GetString( Solver % Values, TRIM(Txt), Found )
       IF(.NOT. Found) EXIT
       
       PRINT *,'Tensor field',i,'= "',TRIM(TensorFieldName),'"'
       
       IF( TransientSimulation ) THEN
         TimeVariable => VariableGet( Model % Mesh % Variables, 'Time' )
         PRINT *,'Current time=',TimeVariable % Values(1)
         WRITE(10,'(A,A,A,ES16.7E3,A)') 'Result "',&
             TRIM(TensorFieldName),'" "Transient analysis" ', &
             TimeVariable % Values(1) ,' Matrix OnNodes'
       ELSE
         IF( .NOT.EigenAnalysis ) THEN
           WRITE(10,'(A,A,A,I2,A)') 'Result "',&
               TRIM(TensorFieldName),'" "Steady analysis"',SteadyStep,' Matrix OnNodes'
         ELSE
           WRITE(10,'(A,A,A,I2,A)') 'Result "',&
               TRIM(TensorFieldName),'" "Eigen analysis"',Loop,' Matrix OnNodes'
         END IF
         
       END IF
       
       WRITE(Txt,'(A)') 'ComponentNames '
       IF( dim == 2 ) THEN
         TensorComponents = 3
       ELSE
         TensorComponents = 6
       END IF
       
       DO j = 1, TensorComponents
         WRITE(Txt3,'(A,I1,A,I1)') 'Tensor Field ',i,' component ',j
         CompName = GetString( Solver % Values, TRIM(Txt3), Found )

         IF( Found ) THEN
           WRITE(Txt2,'(A)') TRIM(CompName)
         ELSE
           WRITE(Txt2,'(A,A,I1)') TRIM(TensorFieldName), ' ', j
         END IF

         IF(j<TensorComponents) THEN
           WRITE(Txt,'(A,A,A,A)' ) &
               TRIM(Txt), ' "', TRIM(Txt2), '",'
         ELSE
           WRITE(Txt,'(A,A,A,A)' ) &
               TRIM(Txt), ' "', TRIM(txt2), '"'
         END IF
       END DO
       WRITE(10,'(A)') TRIM(Txt)
       WRITE(10,'(A)') 'Values'
       
       DO j = 1, Model % Mesh % NumberOfNodes
         WRITE(Txt2,'(I10)') j
         DO k = 1,TensorComponents
           
           ! Check if tensor field components have been defined explicitely:
           !----------------------------------------------------------------
           WRITE(Txt3,'(A,I1,A,I1)') 'Tensor Field ',i,' component ',k
           CompName = GetString( Solver % Values, TRIM(Txt3), Found )
           IF( Found ) THEN
             WRITE(Txt,'(A)') TRIM(CompName)
           ELSE
             WRITE(Txt,'(A,A,I1)') TRIM(TensorFieldName), ' ', k
           END IF
           
           IF( j==1 ) PRINT *, TRIM(Txt3),' = "', TRIM(Txt),'"'
           
           Solution => VariableGet( Model % Mesh % Variables, TRIM(Txt) )
           IF( .NOT.ASSOCIATED( Solution ) ) THEN
             PRINT *,'Tensor field component',k,' not found'
           ELSE
             Perm => Solution % Perm
             !Values => Solution % Values
             !WRITE(Txt2,'(A,ES16.7E3)') TRIM(Txt2), Values( Perm(j) )
             
             IF( .NOT.EigenAnalysis ) THEN
               Values => Solution % Values
               WRITE(Txt2,'(A,ES16.7E3)') TRIM(Txt2), Values( Perm(j) )
             ELSE
               CValues => Solution % Eigenvectors(Loop,:)
               WRITE(Txt2,'(A,ES16.7E3)') TRIM(Txt2), REAL(CValues( Perm(j) ) )
             END IF

           END IF
         END DO
         WRITE(10,'(A)') TRIM(Txt2)
         
       END DO
       WRITE(10,'(A)') 'end values'
     END DO
     
   END DO ! Nloop


   CLOSE(10)
  
   PRINT *,'Output complete.'

!------------------------------------------------------------------------------
 END SUBROUTINE GiDOutputSolver
!------------------------------------------------------------------------------
  



!------------------------------------------------------------------------------
SUBROUTINE GmshOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
  USE DefUtils
  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Element_t),POINTER :: Element
  INTEGER, POINTER :: Perm(:)
  REAL(KIND=dp), POINTER :: Values(:),Values2(:),Values3(:)
  REAL(KIND=dp) :: Vector(3), Time
  COMPLEX(KIND=dp), POINTER :: CValues(:)
  TYPE(Variable_t), POINTER :: Solution, TimeVariable
  TYPE(ValueList_t), POINTER :: SolverParams
  
  LOGICAL :: Found, GotField, FileAppend, AlterTopology, MaskExists
  LOGICAL :: EigenAnalysis = .FALSE., EigenActive, ComponentVector
  
  INTEGER :: VisitedTimes = 0, ExtCount
  INTEGER :: i,j,k,l,m,n,nsize,dim,dofs,ElmerCode, GmshCode,body_id, Vari, Rank, truedim
  INTEGER :: Tag, NumberOfAllElements, BCOffSet
  INTEGER, PARAMETER :: MaxElemCode = 827
  INTEGER :: ElmerToGmshType(MaxElemCode), GmshToElmerType(21), GmshIndexes(27) 
  INTEGER, POINTER :: NodeIndexes(:), ElmerIndexes(:), MaskPerm(:)

  INTEGER, PARAMETER :: LENGTH = 1024
  CHARACTER(LEN=LENGTH) :: OutputFile, Txt, FieldName, CompName
    
  SAVE VisitedTimes
  
!------------------------------------------------------------------------------

  CALL Info('GmshOutputSolver','Saving results in Gmsh format')

  ExtCount = ListGetInteger( Solver % Values,'Output Count',Found)
  IF( Found ) THEN
    VisitedTimes = ExtCount
  ELSE
    VisitedTimes = VisitedTimes + 1
  END IF

  GmshToElmerType = (/ 202, 303, 404, 504, 808, 706, 605, 203, 306, 409, &
      510, 827, 0, 0, 101, 408, 820, 715, 613, 0, 310 /)
  ElmerToGmshType = 0

  DO i=1,SIZE(GmshToElmerType)
    j = GmshToElmerType(i)
    IF( j > 0 ) ElmerToGmshType(j) = i
  END DO

  SolverParams => GetSolverParams()
  EigenAnalysis = GetLogical( SolverParams, 'Eigen Analysis', Found )
  FileAppend = GetLogical( SolverParams,'File Append',Found)
  IF(.NOT. Found) FileAppend = .TRUE.
  AlterTopology = GetLogical( SolverParams,'Alter Topology',Found)
  
  Txt = ListGetString( SolverParams,'Mask Variable',MaskExists)
  IF( MaskExists ) THEN
    Solution => VariableGet(Model % Variables,TRIM(Txt))
    IF( ASSOCIATED(Solution)) MaskPerm => Solution % Perm
    MaskExists = ASSOCIATED(MaskPerm)
  END IF

  OutputFile = GetString( Solver % Values, 'Output File Name', Found )
  IF( .NOT.Found ) OutputFile = 'Output.msh'

  IF(INDEX(OutputFile,'.') == 0) WRITE( OutputFile,'(A,A)') TRIM(OutputFile),".msh"

  dim = CoordinateSystemDimension()
  IF( VisitedTimes > 1 ) THEN
    IF( AlterTopology ) THEN
      OutputFile = NextFreeFilename( OutputFile )
      CALL Info('GmshOutputSolver','Writing mesh and data to a new file: '//TRIM(OutputFile))
    ELSE IF( FileAppend ) THEN      
      CALL Info('GmshOutputSolver','Appending data to the same file: '//TRIM(OutputFile))
      OPEN(UNIT=10, FILE=OutputFile, POSITION='APPEND' )      
      GOTO 10
    ELSE
      OutputFile = NextFreeFilename( OutputFile )          
      CALL Info('GmshOutputSolver','Writing data to a new file: '//TRIM(OutputFile))
      OPEN(UNIT=10, FILE=OutputFile )
      WRITE(10,'(A)') '$MeshFormat'
      WRITE(10,'(A)') '2.0 0 8'
      WRITE(10,'(A)') '$EndMeshFormat'          
      GOTO 10    
    END IF
  END IF


  ! Save the header
  !-------------------------------------------------
  CALL Info('GsmhOutputSolver','Saving results to file: '//TRIM(OutputFile))
  OPEN(UNIT=10, FILE=OutputFile )
  
  WRITE(10,'(A)') '$MeshFormat'
  WRITE(10,'(A)') '2.0 0 8'
  WRITE(10,'(A)') '$EndMeshFormat'    
  

  ! Save the mesh nodes
  !-------------------------------------------------
  CALL Info('GmshOutputSolver','Writing the mesh nodes')
  IF( MaskExists ) THEN
    nsize = MAXVAL( MaskPerm ) 
  ELSE
    nsize = Model % NumberOfNodes
  END IF

  WRITE(10,'(A)') '$Nodes'
  WRITE(10,'(I8)') nsize
  IF( dim == 3 ) THEN
    DO i = 1, Model % NumberOfNodes
      IF( MaskExists ) THEN
        IF( MaskPerm(i) == 0 ) CYCLE
      END IF      
      WRITE(10,'(I8,3ES16.7E3)') i,Model % Nodes % x(i),Model % Nodes % y(i), Model % Nodes % z(i)
    END DO
  ELSE 
    DO i = 1, Model % NumberOfNodes
      IF( MaskExists ) THEN
        IF( MaskPerm(i) == 0 ) CYCLE
      END IF            
      WRITE(10,'(I8,2ES16.7E3,A)') i,Model % Nodes % x(i),Model % Nodes % y(i),' 0.0' 
    END DO
  END IF
  WRITE(10,'(A)') '$EndNodes'

  ! Save the mesh elements
  !-------------------------------------------------
  CALL Info('GmshOutputSolver','Writing the mesh elements')
  NumberOfAllElements = Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
  
  IF( MaskExists ) THEN
    nsize = 0
    DO i=1,NumberOfAllElements
      Element => Model % Mesh % Elements(i)
      ElmerIndexes => Element % NodeIndexes
      IF( ANY(MaskPerm(ElmerIndexes) == 0) ) CYCLE
      nsize = nsize  + 1
    END DO
  ELSE
    nsize = NumberOfAllElements
  END IF



  WRITE(10,'(A)') '$Elements'
  WRITE(10,'(I8)') nsize
  DO i = 1, NumberOfAllElements
    Element => Model % Mesh % Elements(i)
    ElmerCode = Element % TYPE % ElementCode
    ElmerIndexes => Element % NodeIndexes
    
    IF( MaskExists ) THEN
      IF( ANY(MaskPerm(ElmerIndexes) == 0) ) CYCLE     
    END IF

    GmshCode = ElmerToGmshType(ElmerCode)
    IF( GmshCode == 0 ) THEN
      CALL Warn('GmshOutputSolver','Gmsh element index not found!')
      CYCLE
    END IF

    IF( i <= Model % NumberOfBulkElements ) THEN
      Tag = Element % BodyId
    ELSE
      Tag = GetBCId( Element ) + BCOffset
    END IF

    WRITE(10,'(I8,I3,I3,I5)',ADVANCE='NO') i,GmshCode,1,Tag
    k = MOD(ElmerCode,100)

    CALL ElmerToGmshIndex(ElmerCode,ElmerIndexes,GmshIndexes)

    DO j=1,k-1
      WRITE(10,'(I8)',ADVANCE='NO') GmshIndexes(j)
    END DO
    WRITE(10,'(I8)') GmshIndexes(k)
  END DO
  WRITE(10,'(A)') '$EndElements'

  BCOffSet = Model % NumberOfBodies

  ! With a mask the list of physical entities should be checked
  !-------------------------------------------------------------
  IF(.NOT. MaskExists ) THEN
    nsize = Model % NumberOfBodies + Model % NumberOfBCs
    WRITE(10,'(A)') '$PhysicalNames'
    WRITE(10,'(I8)') nsize
    DO i=1,Model % NumberOfBodies 
      Txt = ListGetString( Model % Bodies(i) % Values,'Name')
      WRITE(10,'(I8,A)') i,'"'//TRIM(Txt)//'"'
    END DO
    DO i=1,Model % NumberOfBCs
      Txt = ListGetString( Model % BCs(i) % Values,'Name')
      WRITE(10,'(I8,A)') i+BCOffset,'"'//TRIM(Txt)//'"'
    END DO
    WRITE(10,'(A)') '$EndPhysicalNames'
  END IF


10 CONTINUE


  ! Time is needed
  !-------------------------------------------------
  TimeVariable => VariableGet( Model % Variables, 'Time' )        
  Time = TimeVariable % Values(1)
  
  ! Loop over different type of variables
  !-------------------------------------------------
  CALL Info('GmshOutputSolver','Writing the nodal data')
  DO Rank = 0,2
    DO Vari = 1, 99
      IF( Vari < 10 ) THEN
        IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
        IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        IF(Rank==2) WRITE(Txt,'(A,I2)') 'Tensor Field',Vari
      ELSE
        IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
        IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        IF(Rank==2) WRITE(Txt,'(A,I3)') 'Tensor Field',Vari
      END IF

      FieldName = GetString( Solver % Values, TRIM(Txt), Found )
      IF(.NOT. Found) EXIT 
      IF( Rank == 2) THEN
        CALL Warn('GmshOutputSolver','Not implemented yet for tensors!')
        CYCLE
      END IF

      ComponentVector = .FALSE.
      Solution => VariableGet( Model % Mesh % Variables, FieldName )
      IF(ASSOCIATED(Solution)) THEN
        Values => Solution % Values
        Perm => Solution % Perm
        dofs = Solution % DOFs
      ELSE
        IF( Rank == 1 ) THEN
          Solution => VariableGet( Model % Mesh % Variables, FieldName//' 1' )
          IF( ASSOCIATED( Solution ) ) THEN
            ComponentVector = .TRUE.
            Values => Solution % Values
            Perm => Solution % Perm
            dofs = 1
            Solution => VariableGet( Model % Mesh % Variables, FieldName//' 2' )
            IF( ASSOCIATED(Solution)) THEN
              Values2 => Solution % Values
              dofs = 2
            END IF            
            Solution => VariableGet( Model % Mesh % Variables, FieldName//' 3' )
            IF( ASSOCIATED(Solution)) THEN
              Values3 => Solution % Values
              dofs = 3
            END IF
          END IF
        END IF
        IF( .NOT. ASSOCIATED(Solution)) THEN
          CALL Warn('GsmhOutputSolver','Variable not present: '//TRIM(FieldName))
          CYCLE
        END IF
      END IF
      IF( ASSOCIATED(Solution % EigenVectors) ) THEN
        CALL Warn('GmshOutputSolver','Eigenvectors related to field: '//TRIM(FieldName))
        CALL Warn('GmshOutputSolver','Eigenvectors saving yet not supported')
      END IF

      truedim = MIN(dofs, dim)
      IF( MaskExists ) THEN
        nsize = 0
        DO i=1,SIZE(Perm)
          IF( Perm(i)==0 .OR. MaskPerm(i) == 0 ) CYCLE
          nsize = nsize + 1
        END DO
        IF( nsize == 0 ) THEN
          CALL Warn('GmshOutputSolver','No dofs with the current mask for saving: '//TRIM(FieldName))         
        END IF
      ELSE
        nsize = SIZE(Values) / Dofs
      END IF

      
      WRITE(10,'(A)') '$NodeData'
      WRITE(10,'(A)') '1'
      WRITE(10,'(A)') '"'//TRIM(FieldName)//'"'
      WRITE(10,'(A)') '1'
      WRITE(10,'(ES16.7E3)') Time
      WRITE(10,'(A)') '3'
      WRITE(10,'(I8)') VisitedTimes
      IF(Rank == 0) THEN
        WRITE(10,'(A)') '1'
      ELSE IF(Rank == 1) THEN
        WRITE(10,'(A)') '3'
      ELSE 
        WRITE(10,'(A)') '9'
      END IF     
      WRITE(10,'(I8)') nsize
     
      DO i=1,SIZE(Perm) 
        j = Perm(i)
        IF( j == 0) CYCLE
        IF( MaskExists ) THEN
          IF( MaskPerm(i) == 0 ) CYCLE
        END IF
        
        IF( Rank == 0 ) THEN
          WRITE(10,'(I8,ES16.7E3)') i,Values(j)
        ELSE IF(Rank == 1) THEN
          IF( ComponentVector ) THEN
            IF( truedim == 2 ) THEN
              WRITE(10,'(I8,2ES16.7E3,A)') i,&
                  Values(j),Values2(j),' 0.0'
            ELSE
              WRITE(10,'(I8,3ES16.7E3)') i,&
                  Values(j),Values2(j),Values3(j)
            END IF
          ELSE
            IF( truedim == 2 ) THEN
              WRITE(10,'(I8,2ES16.7E3,A)') i,&
                  Values(dofs*(j-1)+1),Values(dofs*(j-1)+2),' 0.0'
            ELSE
              WRITE(10,'(I8,3ES16.7E3)') i,&
                  Values(dofs*(j-1)+1),Values(dofs*(j-1)+2),Values(dofs*(j-1)+3)
            END IF           
          END IF
        END IF
      END DO
      WRITE(10,'(A)') '$EndNodeData'

    END DO
  END DO
  
      
  IF(.FALSE.) THEN
    WRITE(10,'(A)') '$ElementData'
    WRITE(10,'(A)') '$EndElementData'
  END IF
  
  IF(.FALSE.) THEN
    WRITE(10,'(A)') '$ElementNodeData'
    WRITE(10,'(A)') '$EndElementNodeData'
  END IF
  
  CLOSE(10)
  
  CALL Info('GmshOutputSolver','Gmsh output complete')

CONTAINS



  SUBROUTINE ElmerToGmshIndex(Code,ElmerIndexes,GmshIndexes)

    INTEGER :: Code
    INTEGER :: ElmerIndexes(:),GmshIndexes(:)
    INTEGER :: i,n
    LOGICAL :: reorder, Visited = .FALSE.

    INTEGER, TARGET :: order510(10),order613(13),order715(15),order820(20)
    INTEGER, POINTER :: order(:)

    SAVE Visited

    IF(.NOT. Visited ) THEN
      order510(:) = (/ 0,1,2,3,4,5,6,7,9,8 /)
      order613(:) = (/ 0,1,2,3,4,5,8,10,6,7,9,11,12 /)
      order715(:) = (/ 0,1,2,3,4,5,6,9,7,8,10,11,12,14,13 /)
      order820(:) = (/ 0,1,2,3,4,5,6,7,8,11,12,9,10,12,14,15,16,18,19,17 /)
      Visited = .TRUE.
    END IF

    reorder = .FALSE.

    SELECT CASE( Code )
      
    CASE (510)
      reorder = .TRUE.
      order => order510
      
    CASE (613)
      reorder = .TRUE.
      order => order613
      
    CASE (715)
      reorder = .TRUE.
      order => order715
      
    CASE (820)
      reorder = .TRUE.
      order => order820
     
    CASE DEFAULT
      
    END SELECT

    n = MOD(Code,100) 
    IF( reorder ) THEN
      DO i=1,n 
        GmshIndexes(order(i)+1) = ElmerIndexes(i)
      END DO
    ELSE
      GmshIndexes(1:n) = ElmerIndexes(1:n)      
    END IF


  END SUBROUTINE ElmerToGmshIndex

!------------------------------------------------------------------------------
END SUBROUTINE GmshOutputSolver
!------------------------------------------------------------------------------
  


!------------------------------------------------------------------------------
! The Vtk output solver begins here
!------------------------------------------------------------------------------
MODULE VtkLegacyFile

  USE MeshUtils
  USE ElementDescription
  
  IMPLICIT NONE
  !   PRIVATE
  SAVE
  
  PUBLIC :: WriteVtkLegacyFile
  
  TYPE :: VtkCell_t
    INTEGER :: nNodes
    ! FIXME: POINTER -> ALLOCATABLE when more compilers support it
    INTEGER, POINTER :: NodeIndex(:)
  END TYPE VtkCell_t
  
  INTEGER, PARAMETER :: VtkUnit = 58


CONTAINS

  SUBROUTINE WriteVtkLegacyFile( VtkFile, Model, SubtractDisp )
    CHARACTER(LEN=*), INTENT(IN) :: VtkFile
    TYPE(Model_t) :: Model 
    LOGICAL, INTENT(IN) :: SubtractDisp
    TYPE(Variable_t), POINTER :: Var,Var1
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k
    
    OPEN( UNIT=VtkUnit, FILE=VtkFile, STATUS='UNKNOWN' )
    
    CALL WriteGrid( VtkUnit, Model, SubtractDisp )
    
    WRITE( VtkUnit,'("POINT_DATA ",I0)' ) Model % NumberOfNodes
    
    Var => Model % Variables
    DO WHILE( ASSOCIATED( Var ) )
      IF ( .NOT.Var % Output ) THEN
        Var => Var % Next
        CYCLE
      END IF
      
      IF ( SIZE( Var % Values ) == Var % DOFs ) THEN
        Var => Var % Next
        CYCLE
      END IF
      
      SELECT CASE( Var % Name )
        
      CASE( 'mesh update' )
        Var1 => Model % Variables
        
        DO WHILE( ASSOCIATED( Var1 ) )
          IF ( TRIM( Var1 % Name ) == 'displacement' ) EXIT
          Var1 => Var1 % Next
        END DO
        
        IF ( .NOT.ASSOCIATED( Var1 ) ) THEN
          CALL WriteVector("Mesh.Update", Var, Model % NumberOfNodes,&
              3, VtkUnit)
        END IF
        
      CASE( 'mesh update 1','mesh update 2', 'mesh update 3' )
        
      CASE( 'displacement' )
        WRITE( VtkUnit,'("VECTORS ",A," double")' ) "Displacement"
        DO i = 1, Model % NumberOfNodes
          k = i
          IF ( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
          
          IF ( k > 0 ) THEN
            DO j=1,Var % DOFs
              WRITE( VtkUnit,'(ES16.7E3)',ADVANCE='NO' ) &
                  Var % Values(Var % DOFs*(k-1)+j)
            END DO
            IF ( Var % DOFs < 3 ) THEN
              WRITE( VtkUnit,'(" 0.0")',ADVANCE='NO' )
            END IF
            WRITE( VtkUnit, * ) 
          ELSE
            Var1 => Model % Variables
            DO WHILE( ASSOCIATED( Var1 ) )
              IF ( TRIM( Var1 % Name ) == 'mesh update' ) EXIT
              Var1 => Var1 % Next
            END DO
            IF ( ASSOCIATED( Var1 ) ) THEN
              k = i
              IF ( ASSOCIATED(Var1 % Perm ) ) k = Var1 % Perm(k)
              IF ( k > 0 ) THEN
                DO j=1,Var1 % DOFs
                  WRITE( VtkUnit,'(ES16.7E3)',ADVANCE='NO' ) &
                      Var1 % Values(Var1 % DOFs*(k-1)+j)
                END DO
                IF ( Var1 % DOFs < 3 ) THEN
                  WRITE( VtkUnit,'(" 0.0")', ADVANCE='NO' )
                END IF
                WRITE( VtkUnit, * ) 
              ELSE
                WRITE( VtkUnit,'(" 0.0 0.0 0.0")' )
              END IF
            ELSE
              WRITE( VtkUnit,'(" 0.0 0.0 0.0")' )
            END IF
          END IF
        END DO
        
      CASE( 'displacement 1','displacement 2','displacement 3' )
        
      CASE( 'flow solution' )
        CALL WriteVector( "Velocity", Var, Model % NumberOfNodes, 4, &
            VtkUnit )
        WRITE( VtkUnit,'("SCALARS ",A," double")' ) "Pressure"
        WRITE( VtkUnit,'("LOOKUP_TABLE default")' )
        DO i = 1, Model % NumberOfNodes
          k = i
          IF ( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
          WRITE( VtkUnit,'(ES16.7E3)' ) &
              Var % Values(Var % DOFs*(k-1)+Var % DOFs)
        END DO
        
      CASE( 'velocity 1','velocity 2','velocity 3','pressure' )
        
      CASE( 'magnetic field' )
        CALL WriteVector( "MagField", Var, Model % NumberOfNodes, 3, &
            VtkUnit)
      CASE( 'magnetic field 1','magnetic field 2', 'magnetic field 3' )
        
      CASE( 'electric current' )
        CALL WriteVector( "Current", Var, Model % NumberOfNodes, 3, &
            VtkUnit)
      CASE('electric current 1','electric current 2','electric current 3')
        
      CASE( 'coordinate 1','coordinate 2','coordinate 3' )
        
      CASE( 'magnetic flux density' )
        CALL WriteVector("MagneticFlux", Var, Model % NumberOfNodes, 3,&
            VtkUnit)
      CASE( 'magnetic flux density 1','magnetic flux density 2', &
          'magnetic flux density 3' )
        
      CASE DEFAULT
        IF ( Var % DOFs == 1 ) THEN
          DO i=1,Var % NameLen
            str(i:i) = Var % Name(i:i)
            IF (str(i:i) == ' ') str(i:i) = '.'
          END DO
          str(1:1) = CHAR(ICHAR(str(1:1))-ICHAR('a')+ICHAR('A'))
          
          WRITE(VtkUnit,'("SCALARS ",A," double")') str(1:Var%NameLen)
          WRITE( VtkUnit,'("LOOKUP_TABLE default")' )
          DO i = 1, Model % NumberOfNodes
            k = i
            IF ( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
            IF ( k > 0 ) THEN
              WRITE( VtkUnit,'(ES16.7E3)' ) Var % Values(k)
            ELSE
              WRITE( VtkUnit,'(" 0.0")' )
            END IF
          END DO
        END IF
      END SELECT
      Var => Var % Next
    END DO
    

    CLOSE( VtkUnit )
  END SUBROUTINE WriteVtkLegacyFile
  

  SUBROUTINE WriteVector( VarName, Var, nNodes, MaxDOF, IOUnit )
    CHARACTER(*), INTENT(IN) :: VarName
    TYPE(Variable_t), INTENT(IN) :: Var
    INTEGER, INTENT(IN) :: nNodes, MaxDOF, IOUnit
    INTEGER :: i, j, k, n
    
    n = Var % DOFs - (MaxDOF - 3)
    
    WRITE( IOUnit, '("VECTORS ",A," double")' ) TRIM( VarName )
    DO i = 1, nNodes
      k = i
      IF ( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
      IF ( k > 0 ) THEN
        DO j=1, n
          WRITE( IOUnit,'(ES16.7E3)',ADVANCE='NO' ) &
              Var % Values(Var % DOFs*(k-1)+j)
        END DO
        IF ( n < 3 ) THEN
          WRITE( IOUnit,'(" 0.0")',ADVANCE='NO' )
        END IF
        WRITE( IOUnit, * ) 
      ELSE
        WRITE( IOUnit,'(" 0.0 0.0 0.0")' )
      END IF
    END DO
  END SUBROUTINE WriteVector
  

  LOGICAL FUNCTION FreeSurface( Model )
    TYPE(Model_t), INTENT(IN) :: Model
    LOGICAL :: MoveBoundary, GotIt
    INTEGER :: i
    
    FreeSurface = .FALSE.
    MoveBoundary = .FALSE.
    DO i = 1, Model % NumberOfBCs
      FreeSurface = FreeSurface &
          .OR. ListGetLogical( Model % BCs(i) % Values, &
          'Free Surface', GotIt )
      IF ( FreeSurface ) THEN
        MoveBoundary = ListGetLogical( Model % BCs(i) % Values, &
            'Internal Move Boundary', GotIt )
        
        IF ( .NOT.GotIt ) MoveBoundary = .TRUE.
        
        FreeSurface = FreeSurface .AND. MoveBoundary
      END IF
      
      IF ( FreeSurface ) EXIT
    END DO
  END FUNCTION FreeSurface
  

    SUBROUTINE WriteGrid ( IOUnit, Model, SubtractDisp )
        USE DefUtils
        INTEGER, INTENT(IN) :: IOUnit
        TYPE(Model_t), INTENT(IN) :: Model
        LOGICAL, INTENT(IN) :: SubtractDisp ! Subtract Displacement from Coords.
        TYPE(Variable_t), POINTER :: Displacement, MeshUpdate, Var1, Var2
        INTEGER :: i, k, l, nVtkCells, nVtkCellNum, dim
        ! FIXME: POINTER -> ALLOCATABLE when more compilers support it
        REAL(KIND=dp) :: Coord(3)
        LOGICAL :: Found
        TYPE(VtkCell_t), POINTER :: VtkCells(:)


        WRITE ( IOUnit, '("# vtk DataFile Version 3.0")' ) 
        WRITE ( IOUnit, '("ElmerSolver output; started at ", A)' ) TRIM( FormatDate() )
        WRITE ( IOUnit, '("ASCII")' ) 
        WRITE ( IOUnit, '("DATASET UNSTRUCTURED_GRID")' ) 

        !
        ! Coordinates: 
        !
        WRITE ( IOUnit, '("POINTS ", I0, " double")' ) Model % NumberOfNodes

        ! First, look for displacements
        dim = CoordinateSystemDimension()
        Displacement => NULL()
        MeshUpdate => NULL()
        IF ( SubtractDisp ) THEN
            Var1 => Model % Variables
            DO WHILE( ASSOCIATED( Var1 ) )
                IF ( .NOT.Var1 % Output ) THEN
                    Var1 => Var1 % Next
                    CYCLE
                END IF

                SELECT CASE( Var1 % Name )
                CASE( 'mesh update' )
                    Var2 => Model % Variables
                    DO WHILE( ASSOCIATED( Var2 ) )
                        IF ( TRIM( Var2 % Name ) == 'displacement' ) EXIT
                        Var2 => Var2 % Next
                    END DO

                    IF ( .NOT. ASSOCIATED( Var2 ) ) THEN
                        Displacement => Var1
                    ELSE
                        MeshUpdate   => Var1
                    END IF

                CASE( 'displacement' )
                    Displacement => Var1
                END SELECT

                Var1 => Var1 % Next
            END DO
        END IF

        DO i = 1, Model % NumberOfNodes
          Coord(1) = Model % Nodes % x(i)
          Coord(2) = Model % Nodes % y(i)
          Coord(3) = Model % Nodes % z(i)

          IF( SubtractDisp ) THEN
            k = 0
            IF( ASSOCIATED(Displacement)) k = Displacement % Perm(i)
            
            l = 0
            IF ( ASSOCIATED( MeshUpdate ) ) l = MeshUpdate % Perm(i)
            
            IF ( k > 0 ) THEN
              k = Displacement % DOFs * (k-1)
              Coord(1) = Coord(1) - Displacement % Values(k+1)
              IF( Displacement % DOFs >= 2 ) &
                  Coord(2) = Coord(2) - Displacement % Values(k+2)
              IF( Displacement % DOFs == 3 ) &
                  Coord(3) = Coord(3) - Displacement % Values(k+3)
            END IF
            IF ( l > 0 ) THEN
              l = MeshUpdate % DOFs * (l-1)
              Coord(1) = Coord(1) - MeshUpdate % Values(l+1)
              IF( MeshUpdate % DOFs >= 2 ) &
                  Coord(2) = Coord(2) - MeshUpdate % Values(l+2)
              IF( MeshUpdate % DOFs == 3 ) &
                  Coord(3) = Coord(3) - MeshUpdate % Values(l+3)
            END IF
          END IF

          IF( dim <= 2 ) THEN
            WRITE( IOUnit,'(2ES16.7E3 A)' ) Coord,' 0.0' 
          ELSE
            WRITE( IOUnit,'(3ES16.7E3)' ) Coord 
          END IF
        END DO

        WRITE ( IOUnit, * )

        !
        ! CELLS
        !
        CALL GetNVtkCells ( Model, nVtkCells, nVtkCellNum )
        
        WRITE( IOUnit,'("CELLS ",I0," ",I0)' ) nVtkCells, nVtkCellNum
        DO i = 1, Model%NumberOfBulkElements + Model%NumberOfBoundaryElements

            CALL Elements2Cells ( Model % Elements(i), VtkCells )

            DO k = 1, SIZE( VtkCells )
                WRITE( IOUnit, '(I0)', ADVANCE='NO' ) VtkCells(k) % nNodes
                WRITE( IOUnit, '(50(" ",I0))') VtkCells(k) % NodeIndex
                DEALLOCATE( VtkCells(k) % NodeIndex )
            END DO

            ! FIXME: These explicit deallocations of VtkCells(j) % NodeIndex and
            ! VtkCells can be removed if/when they are changed to ALLOCATABLEs
            DEALLOCATE ( VtkCells )

        END DO

        WRITE( IOUnit, * )

        !
        ! CELL_TYPES
        !
        WRITE( IOUnit,'("CELL_TYPES ",I0)' ) nVtkCells
        DO i = 1, Model%NumberOfBulkElements + Model%NumberOfBoundaryElements
            CALL WriteCellType ( IOUnit, Model%Elements(i)%TYPE%ElementCode )
        END DO

        WRITE( IOUnit, * )

        WRITE( IOUnit, * ) 'CELL_DATA', Model % NumberOfBulkElements+ &
                   Model % NumberOfBoundaryElements

        WRITE( IOUnit, '(A)' ) 'SCALARS group int32'
        WRITE( IOUnit, '(A)' ) 'LOOKUP_TABLE default'
        DO i=1,Model % NumberOfBulkElements
          WRITE( IOUnit, * ) Model % Elements(i) % BodyId
        END DO
        DO i=Model % NumberOfBulkElements+1, &
            Model % NumberOFBulkElements+Model % NumberOfBoundaryElements
          WRITE( IOUnit, * ) 100+GetBCId( Model % Elements(i) )
        END DO

    CONTAINS

        ! Here's a bunch of routines to deal with ELMER Element -> VTK Cell
        ! translations.   Most element types has a directly corresponding cell
        ! type, but some have to be expanded to a compound of simplier cell
        ! types.

        ! nVtkCells is the number of VtkCells, and VtkCellNum is the total
        ! number of integer numbers we have to write to the 'CELLS' section.

        SUBROUTINE GetNVtkCells( Model,nVtkCells,nVtkCellNum )
            TYPE(Model_t), INTENT(IN) :: Model
            INTEGER, INTENT(OUT) :: nVtkCells, nVtkCellNum

            nVtkCells = 0
            nVtkCellNum = 0
            DO i = 1, Model%NumberOfBulkElements+Model%NumberOfBoundaryElements
                SELECT CASE ( Model % Elements(i) % TYPE % ElementCode )
                CASE( 409 )
                    ! Translate to 4 VTK_QUAD cells
                    nVtkCells = nVtkCells + 4
                    nVtkCellNum = nVtkCellNum + 16 + 4

                CASE DEFAULT
                    nVtkCells = nVtkCells + 1
                    nVtkCellNum = nVtkCellNum &
                                + Model % Elements(i) % TYPE % NumberOfNodes + 1
                END SELECT
            END DO
        END SUBROUTINE GetNVtkCells


        ! Translate an Element_t to an array of VtkCell_t.

        SUBROUTINE Elements2Cells( Elem, VtkCells )
            TYPE(Element_t), INTENT(IN) :: Elem
            ! FIXME: POINTER -> ALLOCATABLE, INTENT(OUT) when more compilers
            ! support it
            TYPE(VtkCell_t), POINTER :: VtkCells(:)
            INTEGER :: k

            SELECT CASE ( Elem % TYPE % ElementCode )
            CASE( 409 )
                ! Translate to 4 VTK_QUAD cells
                ALLOCATE( VtkCells(4) )

                VtkCells % nNodes = 4
                DO k = 1, 4
                    ALLOCATE( VtkCells(k) % NodeIndex(4) )
                END DO
                VtkCells(1) % NodeIndex = (/ Elem % NodeIndexes(1), &
                                             Elem % NodeIndexes(5), &
                                             Elem % NodeIndexes(9), &
                                             Elem % NodeIndexes(8) /) - 1
                VtkCells(2) % NodeIndex = (/ Elem % NodeIndexes(5), &
                                               Elem % NodeIndexes(2), &
                                               Elem % NodeIndexes(6), &
                                               Elem % NodeIndexes(9) /) - 1
                VtkCells(3) % NodeIndex = (/ Elem % NodeIndexes(9), &
                                               Elem % NodeIndexes(6), &
                                               Elem % NodeIndexes(3), &
                                               Elem % NodeIndexes(7) /) - 1
                VtkCells(4) % NodeIndex = (/ Elem % NodeIndexes(8), &
                                               Elem % NodeIndexes(9), &
                                               Elem % NodeIndexes(7), &
                                               Elem % NodeIndexes(4) /) - 1
            CASE DEFAULT
                ALLOCATE( VtkCells(1) )

                VtkCells % nNodes = Elem % TYPE % NumberOfNodes
                ALLOCATE( VtkCells(1) % NodeIndex(VtkCells(1) % nNodes) )
                VtkCells(1) % NodeIndex = Elem % NodeIndexes-1
            END SELECT

        END SUBROUTINE Elements2Cells


        SUBROUTINE WriteCellType( IOUnit,Code )
            INTEGER, INTENT(IN) :: IOUnit, Code

            SELECT CASE (Code)
            CASE( 101 )
                WRITE( IOUnit,'(I0)' ) 1
            CASE( 202 )
                WRITE( IOUnit,'(I0)' ) 3
            CASE( 203 )
                WRITE( IOUnit,'(I0)' ) 21
            CASE( 303 )
                WRITE( IOUnit,'(I0)' ) 5
            CASE( 306 )
                WRITE( IOUnit,'(I0)' ) 22
            CASE( 404 )
                WRITE( IOUnit,'(I0)' ) 9
            CASE( 408 )
                WRITE( IOUnit,'(I0)' ) 23
            CASE( 409 )
                ! Translate to 4 VTK_QUAD cells
                WRITE( IOUnit,'(I0)' ) (/ 9, 9, 9, 9 /)
            CASE( 504 )
                WRITE( IOUnit,'(I0)' ) 10
            CASE( 510 )
                WRITE( IOUnit,'(I0)' ) 24
            CASE( 605 )
                WRITE( IOUnit,'(I0)' ) 14
            CASE( 706 )
                WRITE( IOUnit,'(I0)' ) 13
            CASE( 808 )
                WRITE( IOUnit,'(I0)' ) 12
            CASE( 820 )
                WRITE( IOUnit,'(I0)' ) 25
            CASE DEFAULT
                WRITE( IOUnit,'(I0)' ) -Code
            END SELECT
        END SUBROUTINE WriteCellType

    END SUBROUTINE WriteGrid

END MODULE VtkLegacyFile


!------------------------------------------------------------------------------
SUBROUTINE VtkOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
  
  USE DefUtils 
  USE VtkLegacyFile
  
  IMPLICIT NONE
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(dp) :: dt
  LOGICAL :: TransientSimulation
  
  INTEGER, SAVE :: nTime = 0
  LOGICAL :: GotIt
  CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
  
  ! Avoid compiler warings about unused variables
  IF ( TransientSimulation ) THEN; ENDIF
    IF ( dt > 0.0 ) THEN; ENDIF
      
      IF ( nTime == 0 ) THEN
        FilePrefix = GetString( Solver % Values,'Output File Name',GotIt )
        IF ( .NOT.GotIt ) FilePrefix = "Output"
      END IF
      nTime = nTime + 1
      
      CALL WriteData( TRIM(FilePrefix), Model, nTime )
      

    CONTAINS
      
      SUBROUTINE WriteData( Prefix, Model, nTime )
        CHARACTER(*), INTENT(IN) :: Prefix
        TYPE(Model_t) :: Model
        INTEGER, INTENT(IN) :: nTime
        CHARACTER(MAX_NAME_LEN) :: VtkFile
        TYPE(Mesh_t), POINTER :: Mesh
        TYPE(Variable_t), POINTER :: Var
        INTEGER :: i, j, k
        LOGICAL :: EigAnal
        REAL(dp), POINTER :: OrigValues(:)
        INTEGER :: OrigDOFs
        CHARACTER(MAX_NAME_LEN) :: Dir
        
        Mesh => Model % Mesh
          
        IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
          Dir = TRIM(Mesh % Name) // "/"
        ELSE
          Dir = "./"
        END IF
          
        EigAnal = .FALSE.
        
        Solvers: DO i = 1, Model % NumberOfSolvers
          EigAnal = ListGetLogical( Model % Solvers(i) % Values, &
              "Eigen Analysis", GotIt )
          Var => Model % Solvers(i) % Variable
          IF ( EigAnal .AND. ASSOCIATED(Var % EigenValues) ) THEN
            DO j = 1, Model % Solvers(i) % NOfEigenValues
              OrigValues => Var % Values
              OrigDOFs = Var % DOFs
              
              IF ( Model % Solvers(i) % Matrix % COMPLEX ) THEN
                Var % DOFs = Var % DOFs*2
                ALLOCATE( Var % Values(2*SIZE(Var%EigenVectors,2)) )
                FORALL ( k = 1:SIZE(Var % Values)/2 )
                  Var%Values(2*k-1) = REAL(Var%EigenVectors(j,k))
                  Var%Values(2*k) = AIMAG(Var%EigenVectors(j,k))
                END FORALL
              ELSE
                ALLOCATE( Var % Values(SIZE(Var % EigenVectors,2)) )
                Var % Values = Var % EigenVectors(j,:)
              END IF
              
              WRITE( VtkFile, '(A,A,I4.4,"_",I2.2,".vtk")' ) &
                  TRIM(Dir), Prefix, nTime, j
              CALL WriteVtkLegacyFile( VtkFile, Model, .FALSE. )
              
              DEALLOCATE( Var % Values )
              Var % Values => OrigValues
              Var % DOFs = OrigDOFs
            END DO
            EXIT Solvers
          END IF
        END DO Solvers
        
        IF ( .NOT.EigAnal ) THEN
          WRITE( VtkFile,'(A,A,I4.4,".vtk")' ) TRIM(Dir),Prefix,nTime
          CALL WriteVtkLegacyFile( VtkFile, Model, .TRUE. )
        END IF
        
      END SUBROUTINE WriteData
      
    END SUBROUTINE VtkOutputSolver


!------------------------------------------------------------------------------
! The DX output solver begins here
!------------------------------------------------------------------------------
    MODULE DXFile

      USE MeshUtils
      USE ElementDescription
      
      IMPLICIT NONE
      !    PRIVATE
      SAVE
      
      PUBLIC :: WriteDXFiles
      
      INTEGER, PARAMETER :: MAX_VERTIX = 4, MAX_PART_ELEM = 21
      
    CONTAINS
      
      SUBROUTINE WriteDXFiles( Prefix, Model, SubtractDisp, nTime )
        CHARACTER(LEN=*), INTENT(IN) :: Prefix
        TYPE(Model_t) :: Model 
        LOGICAL, INTENT(IN) :: SubtractDisp
        INTEGER, INTENT(IN) :: nTime
        TYPE(Variable_t), POINTER :: Var,Var1
        CHARACTER(LEN=512) :: str
        INTEGER :: i
        INTEGER, PARAMETER :: MasterUnit = 58
        
        IF ( nTime == 1) THEN
          CALL WriteGrid( Prefix, Model, SubtractDisp )
          
          OPEN( MasterUnit, FILE = Prefix // "Master.dx", STATUS="unknown" )
          WRITE( MasterUnit, '(A)') 'object "group" class group'
        END IF
        
        Var => Model % Variables
        DO WHILE( ASSOCIATED( Var ) )
          IF ( .NOT.Var % Output ) THEN
            Var => Var % Next
            CYCLE
          END IF
          
          IF ( SIZE( Var % Values ) == Var % DOFs ) THEN
            Var => Var % Next
            CYCLE
          END IF
          
          SELECT CASE( Var % Name )
            
          CASE( 'mesh update' )
            Var1 => Model % Variables
            
            DO WHILE( ASSOCIATED( Var1 ) )
              IF ( TRIM( Var1 % Name ) == 'displacement' ) EXIT
              Var1 => Var1 % Next
            END DO
            
            IF ( .NOT.ASSOCIATED( Var1 ) ) THEN
              CALL WriteVariable( "MeshUpdate", Var, &
                  Model % NumberOfNodes, Var % DOFs, 0,  &
                  nTime, MasterUnit, Prefix )
            END IF
            
          CASE( 'mesh update 1','mesh update 2', 'mesh update 3' )
            
          CASE( 'displacement' )
            CALL WriteDisplacement( Var, Model, nTime, MasterUnit, Prefix )
          CASE( 'displacement 1','displacement 2','displacement 3' )
            
          CASE( 'flow solution' )
            CALL WriteVariable( "Velocity", Var, Model % NumberOfNodes, &
                Var % DOFs-1, 0, nTime, MasterUnit, Prefix )
            CALL WriteVariable( "Pressure", Var, Model % NumberOfNodes, 1, &
                Var % DOFs-1, nTime, MasterUnit, Prefix )
          CASE( 'velocity 1','velocity 2','velocity 3','pressure' )
            
          CASE( 'magnetic field' )
            CALL WriteVariable( "MagField", Var, Model % NumberOfNodes, &
                Var % DOFs, 0, nTime, MasterUnit, Prefix )
          CASE( 'magnetic field 1','magnetic field 2', 'magnetic field 3' )
            
          CASE( 'electric current' )
            CALL WriteVariable( "Current", Var, Model % NumberOfNodes, &
                Var % DOFs, 0, nTime, MasterUnit, Prefix )
          CASE('electric current 1','electric current 2','electric current 3')
            
          CASE( 'coordinate 1','coordinate 2','coordinate 3' )
            
          CASE( 'magnetic flux density' )
            CALL WriteVariable( "MagneticFlux", Var, Model % NumberOfNodes,&
                Var % DOFs, 0, nTime, MasterUnit, Prefix )
          CASE( 'magnetic flux density 1','magnetic flux density 2', &
              'magnetic flux density 3' )
          CASE DEFAULT
            DO i=1,Var % NameLen
              str(i:i) = Var % Name(i:i)
              IF( str(i:i) == ' ' ) str(i:i) = '_'
            END DO
            str(1:1) = CHAR(ICHAR(str(1:1))-ICHAR('a')+ICHAR('A'))
            
            CALL WriteVariable( TRIM(str), Var, Model % NumberOfNodes, &
                Var % DOFs, 0,  nTime, MasterUnit, Prefix )
          END SELECT
          Var => Var % Next
        END DO
        
        IF( nTime == 1) THEN
          CLOSE( MasterUnit )
        END IF
      END SUBROUTINE WriteDXFiles
      

      SUBROUTINE WriteVariable( VarName, Var, nNodes, SelfDOF, Offset, nTime, &
          MasterUnit, Prefix )
        CHARACTER(*), INTENT(IN) :: VarName
        TYPE(Variable_t), INTENT(IN) :: Var
        INTEGER, INTENT(IN) :: nNodes, SelfDOF, Offset, nTime, MasterUnit
        CHARACTER(*), INTENT(IN) :: Prefix
        INTEGER :: i, j, k
        INTEGER :: FUnit
        CHARACTER(MAX_NAME_LEN) :: FName, RelativeFName, MeshFile
        CHARACTER(7) :: VType
        
        FUnit = MasterUnit + 1
        FName = Prefix // VarName // ".dx"
        
        i = INDEX(FName, '/', BACK=.TRUE.)
        RelativeFName = FName(i+1:)
        
        i = INDEX(Prefix, '/', BACK=.TRUE.)
        MeshFile = Prefix(i+1:) // "Mesh.dx"
        
        IF( nTime == 1 ) THEN
          
            IF ( SelfDOF == 1 ) THEN
              VType = "-scalar"
            ELSE
              VType = "-vector"
            END IF
            WRITE( MasterUnit, '(A)' ) 'member "' // VarName // VType     &
                // '" value file "' // TRIM(RelativeFName) // '","'  &
                // VarName // 'series' // '"'
            
            OPEN( FUnit, FILE=FName, STATUS="unknown" )
          ELSE
            OPEN( FUnit, FILE=FName, STATUS="old", POSITION="append" )
            DO i = 1, 2+(nTime-1)*7
              BACKSPACE FUnit   ! Yuck!
            END DO
          END IF
          
          IF( SelfDOF == 1 )THEN
            WRITE( FUnit,'("object ",I0," class array type double rank 0 &
                &items ",I0," data follows")') nTime, nNodes
          ELSE
            WRITE( FUnit,'("object ",I0," class array type double rank 1 shape &
                &",I0," items ",I0," data follows")') nTime, & 
                SelfDOF, nNodes
          END IF
          
          DO i = 1, nNodes
            k = i
            IF( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
            IF( k > 0 )THEN
              DO j=1, SelfDOF
                WRITE( FUnit,'(ES16.7E3)',ADVANCE='NO' ) &
                    Var % Values(Var % DOFs*(k-1)+j+Offset)
              END DO
              WRITE( FUnit, * ) 
            ELSE
              WRITE( FUnit, '(9F4.1)' ) (/ (0.0, k=1,SelfDOF) /)
            END IF
          END DO
          
          WRITE( FUnit, '(A)' ) 'attribute "dep" string "positions"'
          WRITE( FUnit, * ) 
          
          DO i = nTime + 1, 2*nTime
            WRITE( FUnit,'("object ",I0," class field")' ) i
            WRITE( FUnit,'(A,I0)' ) 'component "data" value ', i - nTime
            WRITE( FUnit,'(A,A,A)' ) 'component "positions" value file "',&
                TRIM( MeshFile ), '",1'
            WRITE( FUnit,'(A,A,A)' ) 'component "connections" value file "',&
                TRIM( MeshFile ), '",2'
            WRITE( FUnit, '(A,A,A)' ) 'attribute "name" string "', VarName,'"'
            WRITE( FUnit, * ) 
          END DO
          
          WRITE( FUnit,'(A)' ) 'object "'//VarName//'series'//'" class series'
          DO i = 1, nTime
            WRITE( FUnit, '("member ",I0," value ",I0," position ",I0)' ) &
                i-1, i+nTime, i
          END DO
          WRITE( FUnit, '("end")' ) 
          
          CLOSE( FUnit )
          
        END SUBROUTINE WriteVariable
        
    
        ! WriteDisplacement is like WriteVariable, but specialized for
        ! Displacements; displacements need special treatment.
        
        SUBROUTINE WriteDisplacement( Var, Model, nTime, MasterUnit, Prefix )
          TYPE(Variable_t), INTENT(IN) :: Var
          TYPE(Model_t), INTENT(IN) :: Model
          INTEGER, INTENT(IN) :: nTime, MasterUnit
          CHARACTER(*), INTENT(IN) :: Prefix
          INTEGER :: i, j, k
          INTEGER :: FUnit
          CHARACTER(MAX_NAME_LEN) :: FName, RelativeFName, MeshFile
          TYPE(Variable_t), POINTER :: Var1
          
          FUnit = MasterUnit + 1
          FName = Prefix // "Displacement.dx"
          
          i = INDEX(FName, '/', BACK=.TRUE.)
          RelativeFName = FName(i+1:)
          
          i = INDEX(Prefix, '/', BACK=.TRUE.)
          MeshFile = Prefix(i+1:) // "Mesh.dx"
          
          IF( nTime == 1 ) THEN
            WRITE( MasterUnit,'(A)' ) &
                'member "Displacement-vector" value file "' &
                // TRIM(RelativeFName) // '", "Displacementseries"'
            
            OPEN( FUnit, FILE=FName, STATUS="unknown" )
          ELSE
            OPEN( FUnit, FILE=FName, STATUS="old", POSITION="append" )
            DO i = 1, 2+(nTime-1)*7
              BACKSPACE FUnit   ! Yuck!
            END DO
          END IF
          
          WRITE( FUnit,'("object ",I0," class array type double rank 1 shape ",  &
              &I0," items ",I0," data follows")') nTime, Var % DOFs, &
              Model % NumberOfNodes
          DO i = 1, Model % NumberOfNodes
            k = i
            IF( ASSOCIATED( Var % Perm ) ) k = Var % Perm(k)
            IF( k > 0 )THEN
              DO j=1, Var % DOFs
                WRITE( FUnit,'(ES16.7E3)',ADVANCE='NO' ) &
                    Var % Values(Var % DOFs*(k-1)+j)
              END DO
              WRITE( FUnit, * ) 
            ELSE
              Var1 => Model % Variables
              DO WHILE( ASSOCIATED( Var1 ) )
                IF ( TRIM( Var1 % Name ) == 'mesh update' ) EXIT
                Var1 => Var1 % Next
              END DO
              IF( ASSOCIATED( Var1 ) )THEN
                k = i
                IF( ASSOCIATED(Var1 % Perm ) ) k = Var1 % Perm(k)
                IF( k > 0 )THEN
                  DO j=1,Var1 % DOFs
                    WRITE( FUnit,'(ES16.7E3)',ADVANCE='NO' ) &
                        Var1 % Values(Var1 % DOFs*(k-1)+j)
                  END DO
                  WRITE( FUnit, * ) 
                ELSE
                  WRITE( FUnit, '(9F4.1)' ) (/ (0.0, k=1,Var % DOFs) /)
                END IF
              ELSE
                WRITE( FUnit, '(9F4.1)' ) (/ (0.0, k=1,Var % DOFs) /)
              END IF
            END IF
          END DO
          
          WRITE( FUnit, '(A)' ) 'attribute "dep" string "positions"'
          WRITE( FUnit, * ) 
          
          DO i = nTime + 1, 2*nTime
            WRITE( FUnit,'("object ",I0," class field")' ) i
            WRITE( FUnit,'(A,I0)' ) 'component "data" value ', i - nTime
            WRITE( FUnit,'(A,A,A)' ) 'component "positions" value file "',&
                TRIM( MeshFile ), '",1'
            WRITE( FUnit,'(A,A,A)' ) 'component "connections" value file "',&
                TRIM( MeshFile ), '",2'
            WRITE( FUnit,'(A,A,A)' ) 'attribute "name" string "Displacement"'
            WRITE( FUnit,* ) 
          END DO
          
          WRITE( FUnit,'(A)' ) 'object "Displacementseries" class series'
          DO i = 1, nTime
            WRITE( FUnit,'("member ",I0," value ",I0," position ",I0)' ) &
                i-1, i+nTime, i
          END DO
          WRITE( FUnit, '("end")' ) 
          
          CLOSE( FUnit )
          
        END SUBROUTINE WriteDisplacement
        
        
        SUBROUTINE WriteGrid ( PRefix, Model, SubtractDisp )
          CHARACTER(*), INTENT(IN) :: Prefix
          TYPE(Model_t), INTENT(IN) :: Model
          LOGICAL, INTENT(IN) :: SubtractDisp ! Subtract Displacement from Coords.
          TYPE(Variable_t), POINTER :: Displacement, MeshUpdate, Var1, Var2
          INTEGER :: i, k, l, nElem, nVertix, dim
          CHARACTER(MAX_NAME_LEN) :: FName
          INTEGER, PARAMETER :: FUnit = 58
          INTEGER :: NodeIndex(MAX_PART_ELEM, MAX_VERTIX)
          REAL(KIND=dp) :: Coord(3)
          
          FName = Prefix // "Mesh.dx"
          OPEN( UNIT=FUnit, FILE=FName, STATUS="unknown", ACTION="write" )
          
          WRITE ( FUnit,'("# ElmerSolver output; started at ",A)' ) &
              TRIM( FormatDate() )
          !
          ! Coordinates: 
          !
          WRITE ( FUnit, '("# Node Coordinates")' )
          WRITE ( FUnit, '("object 1 class array type float rank 1 shape 3 &
              &items ",I0," data follows")' ) Model % NumberOfNodes
          
          ! First, look for displacements
          dim = Model % Mesh % MeshDim

          Displacement => NULL()
          MeshUpdate => NULL()
          IF( SubtractDisp )THEN
            Var1 => Model % Variables
            DO WHILE( ASSOCIATED( Var1 ) )
              IF( .NOT.Var1 % Output )THEN
                Var1 => Var1 % Next
                CYCLE
              END IF
              
              SELECT CASE( Var1 % Name )
              CASE( 'mesh update' )
                Var2 => Model % Variables
                DO WHILE( ASSOCIATED( Var2 ) )
                  IF ( TRIM( Var2 % Name ) == 'displacement' ) EXIT
                  Var2 => Var2 % Next
                END DO
                
                IF( .NOT. ASSOCIATED( Var2 ) )THEN
                  Displacement => Var1
                ELSE
                  MeshUpdate   => Var1
                END IF
                
              CASE( 'displacement' )
                Displacement => Var1
              END SELECT
              
              Var1 => Var1 % Next
            END DO
          END IF
          
          DO i = 1, Model % NumberOfNodes

            Coord(1) =  Model % Nodes % x(i)
            Coord(2) =  Model % Nodes % y(i)
            Coord(3) =  Model % Nodes % z(i)

            IF( SubtractDisp ) THEN
              k = 0
              IF( ASSOCIATED( Displacement ) ) k = Displacement % Perm(i)
              l = 0
              IF ( ASSOCIATED( MeshUpdate ) ) l = MeshUpdate % Perm(i)
              
              IF( k > 0 ) THEN
                k = Displacement % DOFs * (k-1)
                Coord(1) = Displacement % Values(k+1)
                IF( Displacement % DOFs >= 2) Coord(2) = Displacement % Values(k+2)
                IF( Displacement % DOFs == 2) Coord(3) = Displacement % Values(k+3)
              END IF
              IF( k == 0 .AND. l > 0 ) THEN
                l = MeshUpdate % DOFs * (l-1)
                Coord(1) = MeshUpdate % Values(l+1)
                IF( MeshUpdate % DOFs >= 2) Coord(2) = MeshUpdate % Values(l+2)
                IF( MeshUpdate % DOFs == 2) Coord(3) = MeshUpdate % Values(l+3)                
              END IF
            END IF

            IF( dim == 3 ) THEN
              WRITE( FUnit,'(3ES16.7E3)' ) Coord
            ELSE
              WRITE( FUnit,'(2ES16.7E3,A)' ) Coord(1:2),' 0.0'
            END IF
          END DO
          
          WRITE ( FUnit, * )
          
          ! Elements.
          !
          ! The only DX elements we use are triangles (for 2D) and tetrahedra
          ! (3D).  All other element types are translated into compounds of either
          ! of these.
          !
          ! Note that, at the moment, either all elements have to be 2D, or they
          ! all have to be 3D; therefore, boundary elements are not written.
          
          WRITE ( FUnit, '("# Element definitions")' )
          
          CALL GetNElem( Model, nElem, nVertix )
          WRITE( FUnit,'("object 2 class array type int rank 1 shape ", &
              &I0, " items ", I0, " data follows")' ) nVertix, nElem
          
          DO i = 1, Model % NumberOfBulkElements
            CALL TranslateElem( Model % Elements(i), NodeIndex, nElem  )
            DO k = 1, nElem
              WRITE( FUnit, '(4(" ",I0))') NodeIndex(k,1:nVertix)
            END DO
          END DO
          
          IF ( nVertix == 3 ) THEN
            WRITE( FUnit,'(A)') 'attribute "element type" string "triangles"'
          ELSE
            WRITE( FUnit,'(A)') 'attribute "element type" string "tetrahedra"'
          END IF
          WRITE( FUnit, '("end")' )
          
          
        CONTAINS
          
          ! Here's a bunch of routines to deal with ELMER -> DX element
          ! translations.
          
          ! nElem is the number of DX elements, and nVertix is the numbe of
          ! vertices per element (either 3 for triangle or 4 for tetrahedra).
          
          SUBROUTINE GetNElem( Model, nElem, nVertix )
            TYPE(Model_t), INTENT(IN) :: Model
            INTEGER, INTENT(OUT) :: nElem, nVertix
            
            IF (Model % Elements(1) % TYPE % ElementCode < 500) THEN
              nVertix = 3
            ELSE
              nVertix = 4
            END IF
            
            nElem = 0
            DO i = 1, Model%NumberOfBulkElements
              SELECT CASE ( Model % Elements(i) % TYPE % ElementCode )
              CASE( 303 )
                nElem = nElem + 1
              CASE( 404 )
                nElem = nElem + 2
              CASE( 409 )
                nElem = nElem + 8
              CASE( 504 )
                nElem = nElem + 1
              CASE( 605 )
                nElem = nElem + 2
              CASE( 613 )
                nElem = nElem + 14
              CASE( 706 )
                nElem = nElem + 3
              CASE( 715 )
                nElem = nElem + 21
              CASE( 808 )
                nElem = nElem + 4
              CASE DEFAULT
                WRITE (0, *) 'Sorry! Element type ',                    &
                    Model % Elements(i) % TYPE % ElementCode, &
                    ' not supported! '
                STOP
              END SELECT
            END DO
          END SUBROUTINE GetNElem
          
          
          ! Translate an ELMER element to a (compound of) DX element(s).
          
          SUBROUTINE TranslateElem( Elem, NodeIndex, nElem )
            TYPE(Element_t), INTENT(IN) :: Elem
            INTEGER, INTENT(OUT) :: NodeIndex(MAX_PART_ELEM, MAX_VERTIX)
            INTEGER, INTENT(OUT) :: nElem
            
            SELECT CASE ( Elem % TYPE % ElementCode )
            CASE( 303 ) ! Triangle
              nElem = 1
              NodeIndex(1,:3) = Elem % NodeIndexes(1:3)
            CASE( 404 ) ! Quad; translate into 2 triangles
              nElem = 2
              NodeIndex(1,:3) = Elem % NodeIndexes(1:3)
              NodeIndex(2,:3) = Elem % NodeIndexes((/ 1,3,4 /))
            CASE( 409 )
              nElem = 8
              NodeIndex(1,:3) = Elem % NodeIndexes((/ 1,5,9 /))
              NodeIndex(2,:3) = Elem % NodeIndexes((/ 5,2,9 /))
              NodeIndex(3,:3) = Elem % NodeIndexes((/ 2,6,9 /))
              NodeIndex(4,:3) = Elem % NodeIndexes((/ 6,3,9 /))
              NodeIndex(5,:3) = Elem % NodeIndexes((/ 3,7,9 /))
              NodeIndex(6,:3) = Elem % NodeIndexes((/ 7,4,9 /))
              NodeIndex(7,:3) = Elem % NodeIndexes((/ 4,8,9 /))
              NodeIndex(8,:3) = Elem % NodeIndexes((/ 8,1,9 /))
            CASE( 504 ) ! Tetrahedron
              nElem = 1
              NodeIndex(1,:) = Elem % NodeIndexes(1:4)
            CASE( 605 ) ! Pyramid
              nElem = 2
              NodeIndex(1,:) = Elem % NodeIndexes((/ 3,5,4,1 /))
              NodeIndex(2,:) = Elem % NodeIndexes((/ 3,5,2,1 /))
            CASE( 613 )
              nElem = 14
              NodeIndex(1,:) = Elem % NodeIndexes((/ 7,8,3,12 /))
              NodeIndex(2,:) = Elem % NodeIndexes((/ 10,11,12,5 /))
              NodeIndex(3,:) = Elem % NodeIndexes((/ 10,13,12,5 /))
              NodeIndex(4,:) = Elem % NodeIndexes((/ 9,10,13,11 /))
              NodeIndex(5,:) = Elem % NodeIndexes((/ 9,13,11,12 /))
              NodeIndex(6,:) = Elem % NodeIndexes((/ 9,10,11,1 /))
              NodeIndex(7,:) = Elem % NodeIndexes((/ 9,6,11,1 /))
              NodeIndex(8,:) = Elem % NodeIndexes((/ 9,6,11,12 /))
              NodeIndex(9,:) = Elem % NodeIndexes((/ 9,8,12,4 /))
              NodeIndex(10,:) = Elem % NodeIndexes((/ 9,13,12,4 /))
              NodeIndex(11,:) = Elem % NodeIndexes((/ 7,9,8,12 /))
              NodeIndex(12,:) = Elem % NodeIndexes((/ 7,9,6,12 /))
              NodeIndex(13,:) = Elem % NodeIndexes((/ 7,6,11,12 /))
              NodeIndex(14,:) = Elem % NodeIndexes((/ 7,6,11,2 /))
            CASE( 706 ) ! Wedge
              nElem = 3
              NodeIndex(1,:) = Elem % NodeIndexes((/ 5,4,3,1 /))
              NodeIndex(2,:) = Elem % NodeIndexes((/ 5,3,2,1 /))
              NodeIndex(3,:) = Elem % NodeIndexes((/ 5,6,4,3 /))
            CASE( 715 )
              nElem = 21
              NodeIndex(1,:) = Elem % NodeIndexes((/ 10,11,5,2 /))
              NodeIndex(2,:) = Elem % NodeIndexes((/ 12,11,6,3 /))
              NodeIndex(3,:) = Elem % NodeIndexes((/ 12,10,4,1 /))
              NodeIndex(4,:) = Elem % NodeIndexes((/ 7,8,11,2 /))
              NodeIndex(5,:) = Elem % NodeIndexes((/ 7,10,11,2 /))
              NodeIndex(6,:) = Elem % NodeIndexes((/ 13,14,11,5 /))
              NodeIndex(7,:) = Elem % NodeIndexes((/ 13,10,11,5 /))
              NodeIndex(8,:) = Elem % NodeIndexes((/ 9,10,8,11 /))
              NodeIndex(9,:) = Elem % NodeIndexes((/ 9,7,10,8 /))
              NodeIndex(10,:) = Elem % NodeIndexes((/ 9,12,10,11 /))
              NodeIndex(11,:) = Elem % NodeIndexes((/ 9,12,10,1 /))
              NodeIndex(12,:) = Elem % NodeIndexes((/ 9,7,10,1 /))
              NodeIndex(13,:) = Elem % NodeIndexes((/ 9,8,11,3 /))
              NodeIndex(14,:) = Elem % NodeIndexes((/ 9,12,11,3 /))
              NodeIndex(15,:) = Elem % NodeIndexes((/ 15,12,10,11 /))
              NodeIndex(16,:) = Elem % NodeIndexes((/ 15,12,10,4 /))
              NodeIndex(17,:) = Elem % NodeIndexes((/ 15,10,14,11 /))
              NodeIndex(18,:) = Elem % NodeIndexes((/ 15,13,10,14 /))
              NodeIndex(19,:) = Elem % NodeIndexes((/ 15,13,10,4 /))
              NodeIndex(20,:) = Elem % NodeIndexes((/ 15,14,11,6 /))
              NodeIndex(21,:) = Elem % NodeIndexes((/ 15,12,11,6 /))
            CASE( 808 ) ! Hexahedron; translate into 4 tetrahedra
              nElem = 4
              NodeIndex(1,:) = Elem % NodeIndexes((/ 1,2,4,5 /))
              NodeIndex(2,:) = Elem % NodeIndexes((/ 2,3,4,7 /))
              NodeIndex(3,:) = Elem % NodeIndexes((/ 2,7,5,6 /))
              NodeIndex(4,:) = Elem % NodeIndexes((/ 4,5,7,8 /))
            END SELECT
            
            NodeIndex = NodeIndex - 1
            
          END SUBROUTINE TranslateElem
          
        END SUBROUTINE WriteGrid
        
      END MODULE DXFile
      
      
!------------------------------------------------------------------------------
      SUBROUTINE DXOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------

        USE DefUtils 
        USE DXFile
        
        IMPLICIT NONE
        TYPE(Solver_t) :: Solver
        TYPE(Model_t) :: Model
        REAL(dp) :: dt
        LOGICAL :: TransientSimulation
        
        INTEGER, SAVE :: nTime = 0
        LOGICAL :: GotIt
        CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
        
        ! Avoid compiler warings about unused variables
        IF ( TransientSimulation ) THEN; ENDIF
          IF ( dt > 0.0 ) THEN; ENDIF
            
            IF ( nTime == 0 ) THEN
              FilePrefix = GetString( Solver % Values,'Output File Name',GotIt )
              IF ( .NOT.GotIt ) FilePrefix = "Output"
            END IF
            nTime = nTime + 1
            
            CALL WriteData( TRIM(FilePrefix), Model, nTime )
            

CONTAINS

  SUBROUTINE WriteData( Prefix, Model, nTime )
    CHARACTER(*), INTENT(IN) :: Prefix
    TYPE(Model_t) :: Model
    INTEGER, INTENT(IN) :: nTime
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Variable_t), POINTER :: Var
    INTEGER :: i, j, k
    LOGICAL :: EigAnal
    REAL(dp), POINTER :: OldValues(:)
    CHARACTER(MAX_NAME_LEN) :: Dir
    
    Mesh => Model % Mesh
      
    IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
      Dir = TRIM(Mesh % Name) // "/"
    ELSE
      Dir = "./"
    END IF
      
    EigAnal = .FALSE.
    
    Solvers: DO i = 1, Model % NumberOfSolvers
      EigAnal = ListGetLogical( Model % Solvers(i) % Values, &
          "Eigen Analysis", GotIt )
      Var => Model % Solvers(i) % Variable
      IF ( EigAnal .AND. ASSOCIATED(Var % EigenValues) ) THEN
        DO j = 1, Model % Solvers(i) % NOfEigenValues
          OldValues => Var % Values
          
          IF ( Model % Solvers(i) % Matrix % COMPLEX ) THEN
            ALLOCATE( Var % Values(2*SIZE(Var%EigenVectors,2)) )
            FORALL ( k = 1:SIZE(Var % Values)/2 )
              Var%Values(2*k-1) = REAL(Var%EigenVectors(j,k))
              Var%Values(2*k) = AIMAG(Var%EigenVectors(j,k))
            END FORALL
          ELSE
            ALLOCATE( Var % Values(SIZE(Var % EigenVectors,2)) )
            Var % Values = Var % EigenVectors(j,:)
          END IF
          
          CALL WriteDXFiles( TRIM(Dir)//Prefix,Model,.FALSE.,j )
          
          DEALLOCATE( Var % Values )
          Var % Values => OldValues
        END DO
        EXIT Solvers
      END IF
    END DO Solvers
    
    IF ( .NOT.EigAnal ) THEN
      CALL WriteDXFiles( TRIM(Dir)//Prefix, Model, .TRUE., nTime )
    END IF

  END SUBROUTINE WriteData
  
END SUBROUTINE DXOutputSolver






!------------------------------------------------------------------------------
! The Vtu output solver begins here
!------------------------------------------------------------------------------
SUBROUTINE VtuOutputSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------

  USE DefUtils 
  USE MeshUtils
  USE ElementDescription
  
  IMPLICIT NONE
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(dp) :: dt
  LOGICAL :: TransientSimulation
  
  INTEGER, SAVE :: nTime = 0
  LOGICAL :: GotIt, Parallel, FixedMesh
  CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
  CHARACTER(MAX_NAME_LEN) :: VtuFile, PvtuFile 
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Variable_t), POINTER :: Var
  INTEGER :: i, j, k, Partitions, Part, ExtCount, FileindexOffSet, MeshDim
  CHARACTER(MAX_NAME_LEN) :: Dir
  LOGICAL :: Visited = .FALSE.

  LOGICAL :: MaskExists, MaskAllocated
  CHARACTER(MAX_NAME_LEN) :: Str
  TYPE(Variable_t), POINTER :: MaskVar
  INTEGER, POINTER :: MaskPerm(:), MaskOrder(:)
  INTEGER :: NumberOfNodes, NumberOfElements, ParallelNodes, ParallelElements
  TYPE(Element_t), POINTER :: CurrentElement


  ExtCount = ListGetInteger( Solver % Values,'Output Count',GotIt)
  IF( GotIt ) THEN
    nTime = ExtCount
  ELSE
    nTime = nTime + 1
  END IF
  FileIndexOffset = ListGetInteger( Solver % Values,'Fileindex offset',GotIt)

  IF ( nTime == 1 ) THEN
    CALL Info('VtuOutputSolver','Saving results in VTK XML format')
    FilePrefix = GetString( Solver % Values,'Output File Name',GotIt )
    IF ( .NOT.GotIt ) FilePrefix = "Output"
  END IF
  
  Partitions = ParEnv % PEs
  Part = ParEnv % MyPE
  Parallel = (Partitions > 1) .OR. ListGetLogical(Solver % Values,'Enforce Parallel format',GotIt)

  FixedMesh = ListGetLogical(Solver % Values,'Fixed Mesh',GotIt)
  Mesh => Model % Mesh
  MeshDim = Mesh % MeshDim


  !------------------------------------------------------------------------------
  ! Initialize stuff for masked saving
  !------------------------------------------------------------------------------
  MaskAllocated = .FALSE.
  Str = ListGetString( Solver % Values,'Mask Variable',MaskExists)
  IF( MaskExists ) THEN
    MaskVar => VariableGet(Model % Variables,TRIM(Str))
    IF( ASSOCIATED(MaskVar)) MaskPerm => MaskVar % Perm
    MaskExists = ASSOCIATED(MaskPerm)
  ELSE
    IF( MeshDim == 2 ) THEN
      Str = ListGetString( Solver % Values,'2D Mask Name',GotIt)    
    ELSE IF( MeshDim == 3 ) THEN  
      Str = ListGetString( Solver % Values,'3D Mask Name',GotIt)    
    END IF
    IF(.NOT. GotIt) Str = ListGetString( Solver % Values,'Mask Name',GotIt) 
    IF( GotIt ) THEN
      ALLOCATE( MaskPerm( Model % NumberOfNodes ) ) 
      CALL MakePermUsingMask( Model,Solver,Mesh,Str, &
          .FALSE., MaskPerm, NumberOfNodes )
      ParallelNodes = NINT( ParallelReduction( 1.0_dp * NumberOfNodes ) )
      IF( ParallelNodes > 0 ) THEN
        MaskExists = .TRUE.
        MaskAllocated = .TRUE.
      ELSE
        CALL Warn('VtuOutputSolver','Given mask not active: '//TRIM(Str) )
        DEALLOCATE( MaskPerm )
      END IF
    END IF
  END IF
  
  IF(MaskExists) THEN
    CALL Info('VtuOutputSolver','Using > '// TRIM(Str) // ' < as mask variable')
    NumberOfNodes = MAXVAL(MaskPerm)
    NumberOfElements = 0
    IF( NumberOfNodes > 0 ) THEN
      ALLOCATE(MaskOrder(NumberOfNodes))
      DO i=1,SIZE(MaskPerm)
        j = MaskPerm(i)
        IF(j > 0) MaskOrder(j) = i
      END DO
      DO i=1,Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
        CurrentElement => Model % Elements(i)
        IF( ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0) ) THEN
          NumberOfElements = NumberOfElements + 1
        END IF
      END DO
      IF( nTime == 1 ) THEN
        ParallelNodes = NINT( ParallelReduction( 1.0_dp * NumberOfNodes ) )
        ParallelElements = NINT( ParallelReduction( 1.0_dp * NumberOfElements ) )
        WRITE( Message,'(A,I8)') 'Total number of masked nodes:',ParallelNodes
        CALL Info('VtuOutputSolver',Message)
        WRITE( Message,'(A,I8)') 'Total number of masked elements:',ParallelElements
        CALL Info('VtuOutputSolver',Message)
      END IF
    END IF
  ELSE
    NumberOfNodes = Model % NumberOfNodes
    NumberOfElements = Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
  END IF

  IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
    Dir = TRIM(Mesh % Name) // "/"
  ELSE
    Dir = "./"
  END IF
  
  IF(Parallel .AND. Part == 0) THEN
    WRITE( PvtuFile,'(A,A,I4.4,".pvtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
    CALL WritePvtuFile( PvtuFile, Model )
  END IF
  
  IF ( Parallel ) THEN
    WRITE( VtuFile,'(A,A,I4.4,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),Part+1,"par",nTime
  ELSE
    WRITE( VtuFile,'(A,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
  END IF
  CALL WriteVtuFile( VtuFile, Model, FixedMesh )


  IF( MaskAllocated ) DEALLOCATE( MaskPerm ) 
  

CONTAINS

  
  SUBROUTINE WriteVtuFile( VtuFile, Model, RemoveDisp )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    TYPE(Model_t) :: Model 
    LOGICAL, INTENT(IN) :: RemoveDisp
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var,Var1
    CHARACTER(LEN=512) :: str
    INTEGER :: i,ii,j,k,dofs,Rank,cumn,n,dim,vari,sdofs,dispdofs, disp2dofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, TensorFieldName, FieldName, FieldName2
    LOGICAL :: ScalarsExist, VectorsExist, Found, ComponentVector, ComplementExists, Use2, ThisOnly
    TYPE(Variable_t), POINTER :: Solution
    INTEGER, POINTER :: Perm(:), Perm2(:), DispPerm(:), Disp2Perm(:)
    REAL(KIND=dp), POINTER :: Values(:), DispValues(:), Disp2Values(:), Values2(:), Values3(:)
    REAL(KIND=dp) :: x,y,z
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Element_t), POINTER :: CurrentElement

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    Solver => Model % Solver
    dim = Model % Mesh % MeshDim
    ThisOnly = .TRUE.
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <UnstructuredGrid>'
    WRITE( VtuUnit,'(A,I0,A,I0,A)') '    <Piece NumberOfPoints="',NumberOfNodes,&
        '" NumberOfCells="',NumberOfElements,'">'
    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Solver % Values,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Solver % Values,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF

    DispDofs = 0
    Disp2Dofs = 0
    IF(RemoveDisp) THEN
      Solution => VariableGet( Model % Mesh % Variables, 'Displacement', ThisOnly )     
      IF( ASSOCIATED( Solution ) ) THEN
        DispPerm => Solution % Perm
        DispValues => Solution % Values
        DispDofs = Solution % Dofs
      END IF
      
      Solution => VariableGet( Model % Mesh % Variables, 'Mesh Update', ThisOnly )     
      IF( ASSOCIATED( Solution ) ) THEN
        Disp2Perm => Solution % Perm
        Disp2Values => Solution % Values
        Disp2Dofs = Solution % Dofs
      END IF
    END IF
    
    
    DO Rank = 0,2
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          IF(Rank==2) WRITE(Txt,'(A,I2)') 'Tensor Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          IF(Rank==2) WRITE(Txt,'(A,I3)') 'Tensor Field',Vari
        END IF
        
        FieldName = GetString( Solver % Values, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
        
        IF(Rank == 2) THEN
          CALL Warn('VtuOutputSolver','Do the tensors')
          EXIT
        END IF
        

        !---------------------------------------------------------------------
        ! Find the variable with the given name in the normal manner 
        !---------------------------------------------------------------------
        Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName), ThisOnly )
        ComponentVector = .FALSE.
        IF(.NOT. ASSOCIATED(Solution)) THEN
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 1', ThisOnly )
          IF( ASSOCIATED(Solution)) THEN 
            ComponentVector = .TRUE.
          ELSE
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
        END IF
        
        IF( ASSOCIATED(Solution % EigenVectors)) THEN
          CALL Warn('WriteVtuXMLFile','Do the eigen values')
        END IF
        
        Perm => Solution % Perm
        dofs = Solution % DOFs
        Values => Solution % Values

        !---------------------------------------------------------------------
        ! Some vectors are defined by a set of components (either 2 or 3)
        !---------------------------------------------------------------------
        IF( ComponentVector ) THEN
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 2',ThisOnly )
          IF( ASSOCIATED(Solution)) THEN
            Values2 => Solution % Values
            dofs = 2
          END IF
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 3',ThisOnly )
          IF( ASSOCIATED(Solution)) THEN
            Values3 => Solution % Values
            dofs = 3
          END IF
        END IF

        !---------------------------------------------------------------------
        ! There may be special complementary variables such as 
        ! displacement & mesh update 
        !---------------------------------------------------------------------
        ComplementExists = .FALSE.
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2,A)') 'Scalar Field',Vari,' Complement'
          IF(Rank==1) WRITE(Txt,'(A,I2,A)') 'Vector Field',Vari,' Complement'
          IF(Rank==2) WRITE(Txt,'(A,I2,A)') 'Tensor Field',Vari,' Complement'
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3,A)') 'Scalar Field',Vari,' Complement'
          IF(Rank==1) WRITE(Txt,'(A,I3,A)') 'Vector Field',Vari,' Complement'
          IF(Rank==2) WRITE(Txt,'(A,I3,A)') 'Tensor Field',Vari,' Complement'
        END IF
        FieldName2 = GetString( Solver % Values, TRIM(Txt), Found )
        IF( Found ) THEN
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName2), ThisOnly )
          IF( ASSOCIATED(Solution)) THEN 
            Values2 => Solution % Values
            Perm2 => Solution % Perm 
            ComplementExists = .TRUE.
          ELSE
            CALL Warn('WriteVTUFile','Complement does not exist:'//TRIM(FieldName2))
          END IF
        END IF

        !---------------------------------------------------------------------
        ! Finally save the field values 
        !---------------------------------------------------------------------
        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii">'    
          DO ii = 1, NumberOfNodes
            i = ii
            IF( MaskExists ) i = MaskOrder(i)
            j = Perm(i)
            Use2 = (j == 0) .AND. ComplementExists 
            IF( Use2 ) j = Perm2(i)
            IF( Use2 .AND. j > 0) THEN
              WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values2(j)              
            ELSE IF(j > 0) THEN
              WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values(j)              
            ELSE
              WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
            END IF
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        ELSE
          sdofs = MAX(dofs,3)
          WRITE( VtuUnit,'(A,I1,A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii">'    
          
          DO ii = 1, NumberOfNodes
            i = ii
            IF( MaskExists ) i = MaskOrder(i)
            j = Perm(i)
            Use2 = (j == 0) .AND. ComplementExists 
            IF( Use2 ) j = Perm2(i)
            
            DO k=1,sdofs
              IF(j==0 .OR. k > dofs) THEN
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
              ELSE IF( ComponentVector ) THEN
                IF( k == 1 ) WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values(j)
                IF( k == 2 ) WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values2(j)
                IF( k == 3 ) WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values3(j)
              ELSE IF( Use2 ) THEN
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values2(dofs*(j-1)+k)              
              ELSE
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') Values(dofs*(j-1)+k)              
              END IF
            END DO
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        END IF
      END DO
    END DO
    
    IF( ScalarsExist .OR. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      </PointData>'
    END IF
    
    ! Elementwise information
    !-------------------------------------
    IF(.FALSE.) THEN
      WRITE( VtuUnit,'(A)') '      <CellData>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="body" format="ascii">'
      DO i = 1, Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
        CurrentElement => Model % Elements(i)
        IF(MaskExists) THEN
          IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
        END IF
        IF( i <= Model % NumberOfBulkElements ) THEN
          n = CurrentElement % BodyId 
        ELSE
          n = 0
        END IF
        WRITE( VtuUnit, '(I0," ")',ADVANCE='NO') n
      END DO
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '      </CellData>'
    END IF

    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <Points>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii">'    


    DO ii = 1, NumberOfNodes
      i = ii
      IF( MaskExists ) i = MaskOrder(i)
      x = Model % Mesh % Nodes % x(i)
      y = Model % Mesh % Nodes % y(i)
      z = Model % Mesh % Nodes % z(i)
        
      ! If displacement field is active remove the displacement from the coordinates
      IF( dispdofs > 0 .OR. disp2dofs > 0) THEN
        j = 0
        IF(dispdofs > 0) THEN
          j = DispPerm(i)
          IF( j > 0 ) THEN
            x = x - DispValues(dispdofs*(j-1)+1)
            y = y - DispValues(dispdofs*(j-1)+2)
            IF(dispdofs == 3) z = z - DispValues(dispdofs*(j-1)+3)
          END IF
        END IF
        IF(disp2dofs > 0 .AND. j==0) THEN
          j = Disp2Perm(i)
          IF( j > 0 ) THEN
            x = x - Disp2Values(disp2dofs*(j-1)+1)
            y = y - Disp2Values(disp2dofs*(j-1)+2)
            IF(disp2dofs == 3) z = z - Disp2Values(disp2dofs*(j-1)+3)
          END IF
        END IF
      END IF

      IF(dim == 3) THEN
        WRITE(VtuUnit,'(3ES16.7E3)') x, y, z
      ELSE
        WRITE(VtuUnit,'(2ES16.7E3," 0.0")') x, y
      END IF
    END DO

    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Points>'


    ! Write out the mesh
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <Cells>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="connectivity" format="ascii">'
    DO i = 1, Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      CurrentElement => Model % Elements(i)
      IF(MaskExists) THEN
        IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
        WRITE( VtuUnit, '(50(" ",I0))') MaskPerm( CurrentElement % NodeIndexes ) - 1
      ELSE
        WRITE( VtuUnit, '(50(" ",I0))') CurrentElement % NodeIndexes - 1
      END IF
    END DO
    WRITE( VtuUnit,'(A)') '        </DataArray>'

    cumn = 0
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="offsets" format="ascii">'
    DO i = 1, Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      CurrentElement => Model % Elements(i)
      IF(MaskExists) THEN
        IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
      END IF
      n = CurrentElement % TYPE % NumberOfNodes
      cumn = cumn + n
      WRITE( VtuUnit, '(I0," ")',ADVANCE='NO') cumn
    END DO
    WRITE( VtuUnit,'(A)') ' '
    WRITE( VtuUnit,'(A)') '        </DataArray>'

    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="types" format="ascii">'
    DO i = 1, Model % NumberOfBulkElements + Model % NumberOfBoundaryElements
      CurrentElement => Model % Elements(i)
      IF(MaskExists) THEN
        IF( .NOT. ALL(MaskPerm(CurrentElement % NodeIndexes) /= 0)) CYCLE
      END IF
      n = Elmer2VTKElement(CurrentElement % TYPE % ElementCode)
      WRITE( VtuUnit, '(I0," ")',ADVANCE='NO') n
    END DO
    WRITE( VtuUnit,'(A)') ' '
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Cells>'


    WRITE( VtuUnit,'(A)') '    </Piece>'
    WRITE( VtuUnit,'(A)') '  </UnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WriteVtuFile
    


  SUBROUTINE WritePvtuFile( VtuFile, Model )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    TYPE(Model_t) :: Model 
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var,Var1
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k,dofs,Rank,cumn,n,dim,vari,sdofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, TensorFieldName, FieldName
    LOGICAL :: ScalarsExist, VectorsExist, Found, VeloFlag, ComponentVector, ThisOnly
    TYPE(Variable_t), POINTER :: Solution
    INTEGER, POINTER :: Perm(:)
    REAL(KIND=dp), POINTER :: Values(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Element_t), POINTER :: CurrentElement

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    Solver => Model % Solver
    dim = Model % Mesh % MeshDim
    ThisOnly = .TRUE.
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <PUnstructuredGrid>'
    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Solver % Values,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Solver % Values,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF

    
    DO Rank = 0,2
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          IF(Rank==2) WRITE(Txt,'(A,I2)') 'Tensor Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          IF(Rank==2) WRITE(Txt,'(A,I3)') 'Tensor Field',Vari
        END IF
        
        FieldName = GetString( Solver % Values, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
        
        IF(Rank == 2) THEN
          CALL Warn('WritePvtuFile','Do the tensors')
          EXIT
        END IF
        
        Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName), ThisOnly )
        ComponentVector = .FALSE.

        IF(.NOT. ASSOCIATED(Solution)) THEN
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 1',ThisOnly )
          IF( ASSOCIATED(Solution)) THEN 
            ComponentVector = .TRUE.
          ELSE
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
        END IF

        IF( ASSOCIATED(Solution % EigenVectors)) THEN
          CALL Warn('WritePvtuFile','Do the eigen values')
        END IF

        dofs = Solution % DOFs
        IF( ComponentVector ) THEN
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 2',ThisOnly )
          IF( ASSOCIATED(Solution)) dofs = 2
          Solution => VariableGet( Model % Mesh % Variables, TRIM(FieldName)//' 3',ThisOnly )
          IF( ASSOCIATED(Solution)) dofs = 3
        END IF
        
        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii"/>'    
        ELSE
          sdofs = MAX(dofs,3)
          WRITE( VtuUnit,'(A,I1,A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii"/>'    
        END IF
      END DO
    END DO
    WRITE( VtuUnit,'(A)') '    </PPointData>'

    
    ! Elementwise information
    !-------------------------------------
    IF(.FALSE.) THEN
      WRITE( VtuUnit,'(A)') '      <PCellData>'
      WRITE( VtuUnit,'(A)') '        <PDataArray type="Int32" Name="body" format="ascii"/>'
      WRITE( VtuUnit,'(A)') '      </PCellData>'
    END IF

    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <PPoints>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii"/>'    
    WRITE( VtuUnit,'(A)') '      </PPoints>' 

    DO i=1,Partitions
      WRITE( VtuUnit,'(A,I4.4,A,I4.4,A)' ) '    <Piece Source="'//&
          TRIM(FilePrefix),i,"par",nTime,'.vtu"/>'
    END DO

    WRITE( VtuUnit,'(A)') '  </PUnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WritePvtuFile



  FUNCTION Elmer2VtkElement( ElmerCode ) RESULT ( VTKCode )
    INTEGER :: ElmerCode, VTKCode
    
    SELECT CASE (ElmerCode)
    CASE( 101 )
      VTKCode = 1
    CASE( 202 )
      VTKCode = 3
    CASE( 203 )
      VTKCode = 21
    CASE( 303 )
      VTKCode = 5
    CASE( 306 )
      VTKCode = 22
    CASE( 404 )
      VTKCode = 9
    CASE( 408 )
      VTKCode = 23
    CASE( 409 )
      CALL Fatal('Elmer2VtkElement','Implement 409')
    CASE( 504 )
      VTKCode = 10
    CASE( 510 )
      VTKCode = 24
    CASE( 605 )
      VTKCode = 14
    CASE( 706 )
      VTKCode = 13
    CASE( 808 )
      VTKCode = 12
    CASE( 820 )
      VTKCode = 25
    CASE DEFAULT
      PRINT *,'ElmerCode',ElmerCode
      CALL Fatal('Elmer2VtkElement','Not Implemented for elementtype')
      
    END SELECT
  END FUNCTION Elmer2VtkElement


!------------------------------------------------------------------------------
END SUBROUTINE VtuOutputSolver
!------------------------------------------------------------------------------
  
