 
MODULE ParticleUtils

   USE DefUtils
   USE Lists
   USE MeshUtils

   IMPLICIT NONE

   INTEGER, PARAMETER :: PARTICLE_ALLOCATED = 1, &
	                 PARTICLE_WAITING = 2, &
                         PARTICLE_INITIATED = 3, &
                         PARTICLE_LOCATED = 4, &
                         PARTICLE_FACEBOUNDARY = 5, &
                         PARTICLE_WALLBOUNDARY = 6, &
                         PARTICLE_PARTBOUNDARY = 7, &
                         PARTICLE_HIT = 8, & 
                         PARTICLE_READY = 9, &
                         PARTICLE_FIXEDCOORD = 10, &
                         PARTICLE_FIXEDVELO = 11, &
	                 PARTICLE_LOST = 12, &
	                 PARTICLE_GHOST = 13

CONTAINS



!---------------------------------------------------------
! The following subroutines make the data structure 
! transparent in the user subrouines and thereby make
! them more recilient to time.
!---------------------------------------------------------
FUNCTION GetParticleCoord(Particles,No,DerOrder) RESULT ( Coord )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  Coord(3) = 0.0_dp
  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Coord(1:dim) = Particles % Coordinate(no,:)
  ELSE IF( DerOrder == 1 ) THEN
    Coord(1:dim) = Particles % Velocity(no,:)
  ELSE IF( DerOrder == 2 ) THEN
    Coord(1:dim) = Particles % Force(no,:)
  END IF
END FUNCTION GetParticleCoord


SUBROUTINE SetParticleCoord(Particles,No,DerOrder,Coord)
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Particles % Coordinate(no,:) = Coord(1:dim)
  ELSE IF( DerOrder == 1 ) THEN
    Particles % Velocity(no,:) = Coord(1:dim)
  ELSE IF( DerOrder == 2 ) THEN
    Particles % Force(no,:) = Coord(1:dim)
  END IF
END SUBROUTINE SetParticleCoord


SUBROUTINE AddParticleCoord(Particles,No,DerOrder,Coord)
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Particles % Coordinate(no,:) = &
        Particles % Coordinate(no,:) + Coord(1:dim)
  ELSE IF( DerOrder == 1 ) THEN
    Particles % Velocity(no,:) = &
        Particles % Velocity(no,:) + Coord(1:dim)
  ELSE IF( DerOrder == 2 ) THEN
    Particles % Force(no,:) = &
        Particles % Force(no,:) + Coord(1:dim)
  END IF
END SUBROUTINE AddParticleCoord



FUNCTION GetParticleStatus(Particles,No) RESULT ( Status )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Status

  Status = Particles % Status(No)
END FUNCTION GetParticleStatus


SUBROUTINE SetParticleStatus(Particles,No,Status )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Status

  Particles % Status(No) = Status
END SUBROUTINE SetParticleStatus


FUNCTION GetParticleElement(Particles,No) RESULT ( Index ) 
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Index

  Index = Particles % ElementIndex(No)
END FUNCTION GetParticleElement


SUBROUTINE SetParticleElement(Particles,No,Index )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Index

  Particles % ElementIndex(No) = Index
END SUBROUTINE SetParticleElement



!---------------------------------------------------------
! The subroutine marks the elements which are not on the 
! boundary, either internal or external one. 
! This information may be used to speed up different 
! loops where particle-boundary interaction is needed.
!---------------------------------------------------------
SUBROUTINE MarkInternalElements( Particles )
 
  TYPE(Particle_t) :: Particles
  TYPE(Element_t), POINTER :: BulkElement, BulkElement2, BoundaryElement
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Body, Body2
  INTEGER :: t,i,j,imax,body_id,body_id2,mat_id,mat_id2,bf_id,bf_id2,dim,istat
  INTEGER :: NumberOfElements
  LOGICAL, POINTER :: InternalElements(:)
  LOGICAL :: Found,Hit

  Mesh => GetMesh()
  Dim = Mesh % MeshDim
  NumberOfElements = Mesh % NumberOfBulkElements

  IF(.NOT. ASSOCIATED( Particles % InternalElements )) THEN
    ALLOCATE( Particles % InternalElements(NumberOfElements),STAT=istat )
    IF( istat /= 0 ) THEN
      CALL Fatal('MarkInternalElements','Allocation error 1')
    END IF
  END IF

  InternalElements => Particles % InternalElements
  InternalElements = .TRUE.

  DO t=1,NumberOfElements

   BulkElement => Mesh % Elements(t)

    body_id = BulkElement % BodyId

    IF(.FALSE.) THEN
      Body => CurrentModel % Bodies(body_id) % Values
      mat_id = ListGetInteger( Body,'Material',Found)
      bf_id = ListGetInteger( Body,'Body Force',Found)
    END IF

    IF( dim == 3 ) THEN
      imax = BulkElement % TYPE % NumberOfFaces 
    ELSE
      imax = BulkElement % TYPE % NumberOfEdges  
    END IF

    Hit = .FALSE.

    DO i=1, imax
      IF( dim == 3 ) THEN
        j = BulkElement % FaceIndexes(i)
        BoundaryElement => Mesh % Faces( j )
      ELSE
        j = BulkElement % EdgeIndexes(i)
        BoundaryElement => Mesh % Edges(j)
      END IF

      IF( .NOT. ASSOCIATED( BoundaryElement % BoundaryInfo ) ) CYCLE
      
      IF( ASSOCIATED( BulkElement, BoundaryElement % BoundaryInfo % Right ) ) THEN
        BulkElement2 => BoundaryElement % BoundaryInfo % Left
      ELSE
        BulkElement2 => BoundaryElement % BoundaryInfo % Right
      END IF
      
      ! A true boundary element
      IF( .NOT. ASSOCIATED( BulkElement2 )) THEN
        Hit = .TRUE.
        EXIT
      END IF
       
      body_id2 = BulkElement2 % BodyId
      IF( body_id2 == body_id ) CYCLE

      ! If the bodies are the same then there is no boundary
      IF(.TRUE.) THEN
        IF( body_id2 /= body_id ) THEN
          Hit = .TRUE.
          EXIT
        END IF
      ELSE        
        Body2 => CurrentModel % Bodies(body_id2) % Values
        
        mat_id2 = ListGetInteger( Body2,'Material')
        IF( mat_id2 /= mat_id ) THEN
          Hit = .TRUE.
          EXIT
        END IF

        bf_id2 = ListGetInteger( Body2,'Body Force',Found)
        IF( bf_id2 /= bf_id ) THEN
          Hit = .TRUE.
          EXIT
        END IF
      END IF
    END DO

    IF( Hit ) InternalElements(t) = .FALSE.
  END DO

  i = COUNT( InternalElements )
  j = NumberOfElements - i

  PRINT *,'Internal Elements',i
  PRINT *,'Interface Elements',j


END SUBROUTINE MarkInternalElements




!---------------------------------------------------------
! Set up some preliminary information needed for the 
! particler tracker: timeorder, space dimension, 
! bounding box, and mesh edges/faces.
!---------------------------------------------------------
SUBROUTINE SetParticlePreliminaries(Particles,dim,TimeOrder)

  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: dim
  INTEGER, OPTIONAL :: TimeOrder

  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), s(3)
  INTEGER :: ierr

  Mesh => GetMesh()
  IF( .NOT. ASSOCIATED( Mesh ) ) THEN
    CALL Fatal('SetParticleDimensions','No Mesh associated')
  END IF

  IF(PRESENT(TimeOrder)) THEN
    Particles % TimeOrder = TimeOrder
  ELSE
    Particles % TimeOrder = 2
  END IF
  
  IF( PRESENT( dim ) ) THEN
    IF( dim == 2 .OR. dim == 3 ) THEN
      Particles % dim = dim
    ELSE
      CALL Fatal('SetParticleDimensions','Invalid dimension')
    END IF
  ELSE
    Particles % dim = Mesh % Meshdim
  END IF

  MinCoord(1) = MINVAL(Mesh % Nodes % x )
  MinCoord(2) = MINVAL(Mesh % Nodes % y )
  MinCoord(3) = MINVAL(Mesh % Nodes % z )

  MaxCoord(1) = MAXVAL(Mesh % Nodes % x )
  MaxCoord(2) = MAXVAL(Mesh % Nodes % y )
  MaxCoord(3) = MAXVAL(Mesh % Nodes % z )
  
  Particles % LocalMinCoord = MinCoord
  Particles % LocalMaxCoord = MaxCoord
 

  ! Make a parallel reduction
  IF( ParEnv % PEs > 1 ) THEN
    s = MinCoord
    CALL MPI_ALLREDUCE( s, mincoord, 3, MPI_DOUBLE_PRECISION, &
        MPI_MIN, MPI_COMM_WORLD, ierr )
    
    s = MaxCoord
    CALL MPI_ALLREDUCE( s, maxcoord, 3, MPI_DOUBLE_PRECISION, &
        MPI_MAX, MPI_COMM_WORLD, ierr )
  END IF

  Particles % GlobalMinCoord = MinCoord
  Particles % GlobalMaxCoord = MaxCoord
  

  ! Create list of faces / edges 
  !-------------------------------------------------------------------------
  Mesh => GetMesh()
  CALL FindMeshEdges( Mesh, .FALSE.)
  IF ( ParEnv % PEs > 1 ) THEN
    CALL SParEdgeNumbering(Mesh,Allmesh=.TRUE.)
    CALL SParFaceNumbering(Mesh,Allmesh=.TRUE.)
  END IF

  ! Mark elements that are not on boundary to make life faster in the future
  !-------------------------------------------------------------------------
  CALL MarkInternalElements( Particles )

END SUBROUTINE SetParticlePreliminaries



!---------------------------------------------------------
! Allocate particles before launching them
!---------------------------------------------------------
SUBROUTINE AllocateParticles(Particles,NoParticles)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles

  REAL(KIND=dp), POINTER :: Velocity(:,:), Force(:,:), &
       Coordinate(:,:), Distance(:),Dt(:)
  INTEGER, POINTER :: Status(:), ElementIndex(:), FaceIndex(:), Closest(:)
  INTEGER :: PrevNoParticles, dofs, No, n, dim, TimeOrder
  
  IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
    CALL Info('AllocateParticles','There are already enough particles')
    RETURN
  ELSE
    WRITE(Message,*) 'Allocating number of particles:',NoParticles
    CALL Info('AllocateParticles',Message)    
  END IF

  TimeOrder = Particles % TimeOrder
  dim = Particles % dim 
  dofs = dim

  IF( Particles % MaxNumberOfParticles == 0 ) THEN
    ALLOCATE( Particles % Coordinate(NoParticles,dofs))
    ALLOCATE( Particles % Distance(NoParticles))
    ALLOCATE( Particles % Dt(NoParticles))
    ALLOCATE( Particles % Status(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles))

    Particles % Coordinate = 0.0_dp
    Particles % Distance = 0.0_dp
    Particles % Dt = 0.0_dp
    Particles % Status = PARTICLE_ALLOCATED
    Particles % ElementIndex = 0
    Particles % MaxNumberOfParticles = NoParticles

    ALLOCATE( Particles % Velocity(NoParticles,dofs))
    Particles % Velocity = 0.0_dp

    ALLOCATE( Particles % Force(NoParticles,dofs) )
    Particles % Force = 0.0_dp

    ALLOCATE( Particles % FaceIndex(NoParticles))
    Particles % FaceIndex = 0
  ELSE 
    PrevNoParticles = Particles % NumberOfParticles 
    
    Coordinate => Particles % Coordinate
    Velocity => Particles % Velocity
    Force => Particles % Force
    Distance => Particles % Distance
    Status => Particles % Status
    Dt => Particles % Dt
    Closest => Particles % ClosestNode
    FaceIndex => Particles % FaceIndex
    ElementIndex => Particles % ElementIndex

    ALLOCATE( Particles % Coordinate(NoParticles,dofs) )
    IF ( ASSOCIATED(Velocity) ) &
      ALLOCATE( Particles % Velocity(NoParticles,dofs) )

    IF ( ASSOCIATED(Force) ) &
      ALLOCATE( Particles % Force(NoParticles,dofs) )

    IF ( ASSOCIATED(Closest) ) &
      ALLOCATE( Particles % ClosestNode(NoParticles) )

    ALLOCATE( Particles % Distance(NoParticles) )
    ALLOCATE( Particles % Status(NoParticles) )
    ALLOCATE( Particles % Dt(NoParticles) )
    ALLOCATE( Particles % FaceIndex(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles) )

    ! Delete lost particles...
    ! ------------------------
    n = 0
    DO No=1,PrevNoParticles
      IF ( Status(No) == PARTICLE_LOST ) CYCLE
      n=n+1
      Particles % Coordinate(n,:) = Coordinate(No,:)
      IF ( ASSOCIATED(Velocity) ) Particles % Velocity(n,:)=Velocity(No,:)
      IF ( ASSOCIATED(Force) ) Particles % Force(n,:)=Force(No,:)
      IF ( ASSOCIATED(Closest) ) Particles % ClosestNode(n)=Closest(No)
      Particles % Distance(n) = Distance(No)
      Particles % Status(n) = Status(No)
      Particles % Dt(n) = Dt(No)
      Particles % FaceIndex(n) = FaceIndex(No)
      Particles % ElementIndex(n) = ElementIndex(No)
    END DO
    PrevNoParticles = n
    Particles % NumberOfParticles = n

    IF ( ASSOCIATED(Force) ) DEALLOCATE(Force)
    IF ( ASSOCIATED(Velocity) ) DEALLOCATE(Velocity)
    IF ( ASSOCIATED(Closest) ) DEALLOCATE(Closest)
    DEALLOCATE(Coordinate, Distance, Status, ElementIndex, Dt, FaceIndex )

    IF ( ASSOCIATED(Particles % Velocity) ) & 
       Particles % Velocity(PrevNoParticles+1:NoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % Force) ) &
       Particles % Force(PrevNoParticles+1:NoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % ClosestNode) ) &
       Particles % ClosestNode(PrevNoParticles+1:NoParticles) = 0

    Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Dt(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % Distance(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0
    Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED

    Particles % MaxNumberOfParticles = NoParticles
  END IF
END SUBROUTINE AllocateParticles


!----------------------------------------------------
! Delete lost particles:
!----------------------------------------------------
SUBROUTINE DeleteLostParticles(Particles,DeleteBC)
  TYPE(Particle_t) :: Particles
  LOGICAL, OPTIONAL :: DeleteBC

  INTEGER :: No, n, PrevNoParticles

  PrevNoParticles = Particles % NumberOfParticles

  n = 0
  DO No=1,PrevNoParticles
    IF ( Particles % Status(No) == PARTICLE_LOST ) CYCLE
    IF ( PRESENT(DeleteBC)) THEN
      IF( DeleteBC .AND. Particles % Status(No) == PARTICLE_WALLBOUNDARY ) CYCLE
    END IF

    n=n+1
    IF ( n==No ) CYCLE

    Particles % Coordinate(n,:) = Particles % Coordinate(No,:)
    IF ( ASSOCIATED(Particles % Velocity) ) &
      Particles % Velocity(n,:)=Particles % Velocity(No,:)
    IF ( ASSOCIATED(Particles % Force) ) &
      Particles % Force(n,:)=Particles % Force(No,:)
    IF ( ASSOCIATED(Particles % ClosestNode) ) &
      Particles % ClosestNode(n)=Particles % ClosestNode(No)
    Particles % Distance(n) = Particles % Distance(No)
    Particles % Status(n) = Particles % Status(No)
    Particles % Dt(n) = Particles % Dt(No)
    Particles % FaceIndex(n) = Particles % FaceIndex(No)
    Particles % ElementIndex(n) = Particles % ElementIndex(No)
  END DO
  Particles % NumberOfParticles = n

  IF ( n<PrevNoParticles ) THEN
    IF ( ASSOCIATED(Particles % Velocity) ) & 
       Particles % Velocity(n+1:PrevNoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % Force) ) &
       Particles % Force(n+1:PrevNoParticles,:) = 0._dp

    IF ( ASSOCIATED(Particles % ClosestNode) ) &
       Particles % ClosestNode(n+1:PrevNoParticles) = 0

    Particles % Coordinate(n+1:PrevNoParticles,:) = 0._dp
    Particles % Dt(n+1:PrevNoParticles) = 0._dp
    Particles % Distance(n+1:PrevNoParticles) = 0._dp
    Particles % ElementIndex(n+1:PrevNoParticles) = 0
    Particles % Status(n+1:PrevNoParticles) = PARTICLE_ALLOCATED
  END IF
END SUBROUTINE DeleteLostParticles


!----------------------------------------------------
! Increase particle array size by given amount:
!----------------------------------------------------
SUBROUTINE IncreaseParticles(Particles,NoParticles)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles

  INTEGER :: Maxn

  ! Garbage collection:
  ! -------------------
  CALL DeleteLostParticles(Particles)
  
  ! Check if really need to allocate more space:
  ! --------------------------------------------
  Maxn = Particles % NumberOfParticles+NoParticles
  IF ( Maxn > Particles % MaxNumberOfParticles ) &
    CALL AllocateParticles( Particles,Maxn )

END SUBROUTINE IncreaseParticles



SUBROUTINE DestroyParticles(Particles) 
  TYPE(Particle_t) :: Particles

  IF ( ASSOCIATED(Particles % Velocity) ) &
       DEALLOCATE( Particles % Velocity ) 

  IF ( ASSOCIATED(Particles % Force) ) &
       DEALLOCATE( Particles % Force )

  DEALLOCATE( Particles % Coordinate ) 
  DEALLOCATE( Particles % Distance ) 
  DEALLOCATE( Particles % Dt ) 
  DEALLOCATE( Particles % Status ) 
  DEALLOCATE( Particles % FaceIndex )
  DEALLOCATE( Particles % ElementIndex ) 

  Particles % NumberOfParticles = 0
  Particles % MaxNumberOfParticles = 0
  
END SUBROUTINE DestroyParticles



!---------------------------------------------------------
! Subroutine for releaseing initiated but waiting particles.
!---------------------------------------------------------
SUBROUTINE ReleaseWaitingParticles(Particles) 
  TYPE(Particle_t) :: Particles

  TYPE(ValueList_t), POINTER :: Params
  INTEGER, POINTER :: Status(:)
  INTEGER :: i,j,NoParticles,ReleaseCount=0,ReleaseSet
  REAL(KIND=dp) :: ReleaseFraction
  LOGICAL :: Found,Visited = .FALSE.
  
  SAVE Visited, ReleaseCount
  
  ! Check whether all particles have already been released
  !-------------------------------------------------------
  NoParticles = Particles % NumberOfParticles
  IF( ReleaseCount >= NoParticles ) RETURN

  ! Get the size of the current release set
  !-------------------------------------------------------
  Params => GetSolverParams()
  ReleaseSet = GetInteger( Params,'Particle Release Number',Found)
  IF( .NOT. Found ) THEN
    ReleaseFraction = GetCReal( Params,'Particle Release Fraction',Found )
    IF(.NOT. Found ) THEN
      RETURN
    ELSE
      ReleaseSet = NINT( ReleaseFraction * NoParticles ) 
    END IF
  END IF
  IF( ReleaseSet <= 0 ) RETURN

  ! Release some waiting particles
  !-------------------------------------------------------
  Status => Particles % Status
  j = 0
  DO i=1,NoParticles
    IF( Status(i) == PARTICLE_WAITING ) THEN      
      Status(i) = PARTICLE_INITIATED 
      j = j + 1
      IF( j == ReleaseSet ) EXIT
    END IF
  END DO
  ReleaseCount = ReleaseCount + j

END SUBROUTINE ReleaseWaitingParticles


!---------------------------------------------------------
! Subroutine for chanching the partition of particles that
! cross the partition boundary.
!---------------------------------------------------------
FUNCTION ChangeParticlePartition(Particles) RESULT(nReceived)
!---------------------------------------------------------
  TYPE(Particle_t) :: Particles
!---------------------------------------------------------
  TYPE(Element_t), POINTER :: Face, Parent, Faces(:)

  INTEGER i,j,k,l,m,n,dim,NoPartitions, nextPart, nFaces, &
      Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived

  INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
           Recv_parts(:), Requests(:)
  TYPE(Mesh_t), POINTER :: Mesh

  INTEGER, POINTER :: Neighbours(:)
  LOGICAL, POINTER :: FaceInterface(:), IsNeighbour(:)

  TYPE ExchgInfo_t
    INTEGER :: n=0
    INTEGER, POINTER :: Gindex(:), Particles(:)
  END TYPE ExchgInfo_t

  REAL(KIND=dp), ALLOCATABLE :: Buf(:)
  TYPE(ExchgInfo_t), ALLOCATABLE :: Info(:)
!---------------------------------------------------------

  nReceived = 0
  IF( ParEnv% PEs == 1 ) RETURN

  Mesh => GetMesh()
  dim = Particles % dim

  ! Count & Identify neighbouring partitions:
  ! -----------------------------------------
  ALLOCATE(IsNeighbour(ParEnv % PEs))
  NoPartitions = MeshNeighbours(Mesh,IsNeighbour)
  ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
  Perm = 0

  NoPartitions=0
  DO i=1,ParEnv % PEs
    IF ( i-1==ParEnv % Mype ) CYCLE
    IF ( IsNeighbour(i) ) THEN
      NoPartitions=NoPartitions+1
      Perm(i) = NoPartitions
      Neigh(NoPartitions) = i-1
    END IF
  END DO
  DEALLOCATE(IsNeighbour)

  !
  ! Count particles to be sent to neighbours:
  ! -----------------------------------------
  ALLOCATE(Info(NoPartitions))
  Info % n = 0

  DO i=1,Particles % NumberOfParticles
    IF( Particles % Status(i)/=PARTICLE_WALLBOUNDARY ) CYCLE

    IF ( dim==2 ) THEN
       Face => Mesh % Edges(Particles % FaceIndex(i))
       FaceInterface  => Mesh % ParallelInfo % EdgeInterface
       Neighbours => Mesh % ParallelInfo %  &
          EdgeNeighbourList(Face % ElementIndex) % Neighbours
    ELSE
      Face => Mesh % Faces(Particles % FaceIndex(i))
      FaceInterface => Mesh % ParallelInfo % FaceInterface
      Neighbours => Mesh % ParallelInfo %  &
         FaceNeighbourList(Face % ElementIndex) % Neighbours
    END IF

    IF ( FaceInterface(Face % ElementIndex) ) THEN
      IF ( Face % BoundaryInfo % Constraint > 0 ) &
        CALL Warn("ChangeParticlePartition", "is this a BC after all?")

      nextPart = ParEnv % MyPE
      DO j=1,SIZE(Neighbours)
        IF ( ParEnv % Mype /= Neighbours(j) ) THEN
          nextPart = Neighbours(j)
          k = Perm(nextPart+1)
          IF ( k>0 ) THEN
            Info(k) % n=Info(k) % n+1
            Particles % Status(i) = PARTICLE_PARTBOUNDARY
          ELSE 
            Particles % Status(i)=PARTICLE_LOST
          END IF
          EXIT
        END IF
      END DO
    END IF
  END DO

  !
  ! Receive interface sizes:
  !--------------------------
  ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
  DO i=1,NoPartitions
    CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
         1000, MPI_COMM_WORLD, requests(i), ierr )
  END DO

  DO i=1,NoPartitions
    CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
             1000, MPI_COMM_WORLD, ierr )
  END DO
  CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )

  n = SUM(Recv_Parts)
  CALL MPI_ALLREDUCE( n, nReceived, 1, MPI_INTEGER, &
          MPI_SUM, MPI_COMM_WORLD, ierr )
  IF ( nReceived==0 ) THEN
    DEALLOCATE(Recv_Parts, Requests, Info, Perm, Neigh)
    RETURN
  END IF

  !
  ! Collect particles to be sent to neighbours:
  ! -------------------------------------------
  DO i=1,NoPartitions
    ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF( Particles % Status(i) /= PARTICLE_PARTBOUNDARY ) CYCLE

    IF ( dim==2 ) THEN
       Face => Mesh % Edges(Particles % FaceIndex(i))
       FaceInterface  => Mesh % ParallelInfo % EdgeInterface
       Neighbours => Mesh % ParallelInfo %  &
          EdgeNeighbourList(Face % ElementIndex) % Neighbours
    ELSE
      Face => Mesh % Faces(Particles % FaceIndex(i))
      FaceInterface => Mesh % ParallelInfo % FaceInterface
      Neighbours => Mesh % ParallelInfo %  &
         FaceNeighbourList(Face % ElementIndex) % Neighbours
    END IF

    IF ( FaceInterface(Face % ElementIndex) ) THEN
      nextPart = ParEnv % MyPE
      DO j=1,SIZE(Neighbours)
        IF ( ParEnv % Mype /= Neighbours(j) ) THEN
          nextPart = Neighbours(j);
          EXIT
        END IF
      END DO
      Particles % Status(i) = PARTICLE_LOST
      j = Perm(nextPart+1)
      IF ( j==0 ) THEN
        CALL Warn( 'ChangeParticlePartition', 'Neighbouring partition not found?')
        CYCLE
      END IF
      Info(j) % n = Info(j) % n+1
      n = Info(j) % n
      Info(j) % Particles(n) = i
      Info(j) % Gindex(n) = Face % GElementIndex
    END IF
  END DO


  n = 0
  DO i=1,NoPartitions
    n = n + Info(i) % n
  END DO
  n = 2*(n + 2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
  CALL CheckBuffer(n)

  ! Send particles:
  ! ---------------
  DO j=1,NoPartitions
    n = Info(j) % n
    IF ( n<=0 ) CYCLE

    CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, Neigh(j), &
               1001, MPI_COMM_WORLD, ierr )

    ALLOCATE(Buf(2*n*dim+n))
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
      END DO
    END DO
    DO l=1,n
      m = m + 1
      Buf(m) = Particles % Dt(Info(j) % Particles(l))
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
        END DO
      END DO
    END IF

    CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
        Neigh(j), 1002, MPI_COMM_WORLD, ierr )

    DEALLOCATE(Buf)
  END DO


  DEALLOCATE(Perm)
  DO i=1,NoPartitions
    DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
  END DO
  DEALLOCATE(Info)


  ! Recv particles:
  ! ---------------

  n = SUM(Recv_Parts)
  IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
    CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
               Particles % MaxNumberOfParticles )
  END IF

  IF(Particles % dim==2 ) THEN
    nFaces = Mesh % NumberOfEdges
    Faces => Mesh % Edges
  ELSE
    Faces => Mesh % Faces
    nFaces = Mesh % NumberOfFaces
  END IF


  DO i=1,NoPartitions
    n = Recv_Parts(i)
    IF ( n<=0 ) CYCLE

    proc = Neigh(i)
    ALLOCATE(Indexes(n))

    CALL MPI_RECV( Indexes, n, MPI_INTEGER, proc, &
          1001, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    DO j=1,n
      k=SearchElement( nFaces, Faces, Indexes(j) )
      IF ( k<=0 ) THEN
         PRINT*,ParEnv % myPE, 'failed'
         CYCLE
      END IF

      Face => Faces(k) 
      Parent => Face % BoundaryInfo % Left
      IF ( .NOT.ASSOCIATED(Parent) ) &
        Parent => Face % BoundaryInfo % Right

      n_part = n_part+1
      Particles % Status(n_part) = PARTICLE_PARTBOUNDARY
      Particles % ElementIndex(n_part) = Parent % ElementIndex
    END DO

    ALLOCATE(Buf(2*n*dim+n))

    m = n*dim+n
    IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim
    CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
           1002, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Particles % Coordinate(n_part+l,k)=Buf(m)
      END DO
    END DO

    DO l=1,n
      m = m + 1
      Particles % Dt(n_part+l) = Buf(m)
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Velocity(n_part+l,k)=Buf(m)
        END DO
      END DO
    END IF
    DEALLOCATE(Buf)

    Particles % NumberOfParticles = Particles % NumberOfParticles+n
    DEALLOCATE(Indexes)
  END DO

  DEALLOCATE(Recv_Parts, Neigh, Requests)
  CALL MPI_BARRIER( MPI_COMM_WORLD, ierr )

CONTAINS
  
  !
  ! Search an element Item from an ordered Element_t array(N) and return
  ! Index to that array element. Return value -1 means Item was not found.
  !
  FUNCTION SearchElement( N, IArray, Item ) RESULT(Indx)
    IMPLICIT NONE
  
    INTEGER :: Item, Indx, i
    INTEGER :: N
    TYPE(Element_t) :: Iarray(:)

    ! Local variables

    INTEGER :: Lower, Upper, lou

    !*********************************************************************

    Indx  = -1
    Upper =  N
    Lower =  1

    ! Handle the special case

    IF ( Upper < Lower ) RETURN
  
    DO WHILE( .TRUE. )
      IF ( IArray(Lower) % GelementIndex == Item ) THEN
        Indx = Lower
        EXIT
      ELSE IF ( IArray(Upper) % GelementIndex == Item ) THEN
        Indx = Upper
        EXIT
      END IF

      IF ( (Upper - Lower) > 1 ) THEN
        Lou = ISHFT((Upper + Lower), -1)
        IF ( IArray(lou) % GelementIndex < Item ) THEN
          Lower = Lou
        ELSE
          Upper = Lou
        END IF
      ELSE
        EXIT
      END IF
    END DO
  END FUNCTION SearchElement
END FUNCTION ChangeParticlePartition
  

!---------------------------------------------------------
! Computes the means of coordinates / velocities / force
! The statistics could be made more detailed...
!---------------------------------------------------------
SUBROUTINE ParticleStatistics( Particles, DerOrder ) 
  TYPE(Particle_t) :: Particles
  INTEGER :: DerOrder

  REAL(KIND=dp) :: Coord(3),MeanCoord(3),AbsCoord(3),VarCoord(3), &
      MinCoord(3), MaxCoord(3)
  
  INTEGER :: i,j,Cnt,NoParticles,TotParticles,dim
  REAL(KIND=dp), POINTER :: TargetVector(:,:)
  INTEGER, POINTER :: Status(:)

  MeanCoord = 0.0_dp
  AbsCoord = 0.0_dp
  VarCoord = 0.0_dp
  MinCoord = HUGE( MinCoord )
  MaxCoord = -HUGE( MaxCoord )

  Cnt = 0
  NoParticles =  Particles % NumberOfParticles
  dim = Particles % dim
  Coord = 0.0_dp

  IF( DerOrder == 0 ) THEN
    TargetVector => Particles % Coordinate
  ELSE IF( DerOrder == 1 ) THEN
    TargetVector => Particles % Velocity
  ELSE IF( DerOrder == 2 ) THEN
    TargetVector => Particles % Force
  ELSE
    CALL Fatal('ParticleStatistics','Unknown value for DerOrder!')
  END IF

  Status => Particles % Status

  DO i=1,NoParticles
    IF( Status(i) >= PARTICLE_LOST ) CYCLE
    IF( Status(i) < PARTICLE_INITIATED ) CYCLE

    Coord(1:dim) = TargetVector(i,1:dim)

    MeanCoord = MeanCoord + Coord
    AbsCoord = AbsCoord + ABS( Coord )
    VarCoord = VarCoord + Coord**2
    DO j=1,dim
      MinCoord(j) = MIN( MinCoord(j), Coord(j) )
      MaxCoord(j) = MAX( MaxCoord(j), Coord(j) )
    END DO
    Cnt = Cnt + 1
  END DO
  
  TotParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )

  IF( TotParticles > 0 ) THEN
    ! Compute parallel sums?
    DO j=1,dim
      MeanCoord(j) = ParallelReduction( MeanCoord(j) )
      AbsCoord(j) = ParallelReduction( AbsCoord(j) ) 
      VarCoord(j) = ParallelReduction( varCoord(j) )
      MinCoord(j) = ParallelReduction( MinCoord(j),1 )
      MaxCoord(j) = ParallelReduction( MaxCoord(j),2 )
    END DO

    MeanCoord = MeanCoord / TotParticles
    AbsCoord = AbsCoord / TotParticles
    VarCoord = SQRT( VarCoord / TotParticles - MeanCoord**2 ) 

    IF( ParEnv % myPE == 0 ) THEN
      IF( DerOrder == 0 ) THEN
        PRINT *,'Statistical info on coordinate values:'
      ELSE IF( DerOrder == 1 ) THEN
        PRINT *,'Statistical info on velocity values:'
      ELSE IF( DerOrder == 2 ) THEN
        PRINT *,'Statistical info on force values:'
      END IF
      
      PRINT *,'Mean:',MeanCoord(1:dim)
      PRINT *,'Abs: ',AbsCoord(1:dim)
      PRINT *,'Var: ',VarCoord(1:dim)
      PRINT *,'Min: ',MinCoord(1:dim)
      PRINT *,'Max: ',MaxCoord(1:dim)
    END IF
  ELSE
    CALL Warn('MeanParticleCoordinate','No active particles!')
  END IF

END SUBROUTINE ParticleStatistics
   


!---------------------------------------------------------
! Computes the characterestic speed for time integration.
! The speed may be either computed for the whole set or
! alternatively to just one particle.
!---------------------------------------------------------
FUNCTION CharacteristicSpeed( Particles, No ) RESULT ( CharSpeed )
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: CharSpeed
  INTEGER, OPTIONAL :: No

  REAL(KIND=dp) :: Velo(3),Speed,SumSpeed,MaxSpeed
  INTEGER :: i,j,Cnt,NoParticles,dim,ParallelParticles
  REAL(KIND=dp), POINTER :: Velocity(:,:)
  INTEGER, POINTER :: Status(:)
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: UseMax, Visited = .FALSE.

  SAVE Visited, UseMax

  IF(.NOT. Visited ) THEN
    Params => GetSolverParams()
    UseMax = GetLogical( Params,'Max Characteristic Speed')
    Visited = .TRUE.
  END IF


  dim = Particles % dim
  Velocity => Particles % Velocity

  IF( PRESENT(No)) THEN
    Velo(1:dim) = Velocity(No,1:dim)
    CharSpeed = SQRT( SUM( Velo(1:dim) ** 2 ) )
    RETURN
  END IF

  NoParticles =  Particles % NumberOfParticles
  Status => Particles % Status
  CharSpeed = 0.0_dp
  Velo = 0.0_dp
  Cnt = 0

  ! Compute characteristic speed for square since it avoids taking the sqrt
  DO i=1,NoParticles
    IF( Status(i) >= PARTICLE_LOST ) CYCLE
    IF( Status(i) < PARTICLE_INITIATED ) CYCLE

    Cnt = Cnt + 1
    Velo(1:dim) = Velocity(i,1:dim)
    Speed = SUM( Velo(1:dim) ** 2 ) 
    SumSpeed = SumSpeed + Speed
    MaxSpeed = MAX( MaxSpeed, Speed ) 
  END DO

  IF( Cnt == 0 ) RETURN
  
  IF( UseMax ) THEN 
    CharSpeed = ParallelReduction( MaxSpeed, 2 )
  ELSE
    ParallelParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )
    CharSpeed = ParallelReduction( SumSpeed ) / ParallelParticles
  END IF
  CharSpeed = SQRT( CharSpeed ) 

  IF(.FALSE.) THEN
    WRITE( Message,'(A,E12.6)') 'Speed for timestep control: ',CharSpeed
    CALL Info('CharacteristicSpeed',Message )
  END IF

END FUNCTION CharacteristicSpeed


!---------------------------------------------------------
! Computes the characterestic time spent in an element
! Currently computed just for one element as computing the 
! size of element is a timeconsuming operation.
!---------------------------------------------------------
FUNCTION CharacteristicElementTime( Particles, No ) RESULT ( CharTime )
    
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: CharTime
  INTEGER, OPTIONAL :: No

  REAL(KIND=dp) :: CharSpeed, ElementSize, u, v, w, DetJ
  REAL(KIND=dp), POINTER :: Basis(:)
  LOGICAL :: Stat, Visited = .FALSE.
  TYPE(Element_t), POINTER :: Element
  TYPE(Nodes_t) :: Nodes
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: n, dim, ElementFamily

  SAVE Visited, ElementSize
  
  IF( .NOT. Visited ) THEN
    Visited = .TRUE.

    ! Note: the elements are assumed to be of equal size!!!
    Mesh => GetMesh()
    dim = Mesh % MeshDim
    Element => Mesh % Elements(1)

    CALL GetElementNodes( Nodes, Element ) 
    n = Element % TYPE % NumberOfNodes
    ALLOCATE( Basis(n) )
    ElementFamily  = GetElementFamily( Element )

    u = 0.0_dp
    v = 0.0_dp
    w = 0.0_dp

    IF( ElementFamily == 3 ) THEN
      u = 1.0/3.0_dp
      v = 1.0/3.0_dp
      w = 0.0_dp
    ELSEIF( ElementFamily == 5 ) THEN
      u = 0.25_dp
      v = 0.25_dp
      w = 0.25_dp
    END IF

    stat = ElementInfo( Element, Nodes, U, V, W, detJ, Basis )
    ElementSize = detJ ** ( 1.0_dp / dim )

    DEALLOCATE( Basis )
    PRINT *,'ElementSize:',ElementSize
  END IF

  CharSpeed = CharacteristicSpeed( Particles, No ) 
  CharTime = ElementSize / CharSpeed
  
END FUNCTION CharacteristicElementTime



!------------------------------------------------------------------------
! Initialize particle positions and velocities.
!-------------------------------------------------------------------------
SUBROUTINE InitializeParticles( Particles, InitParticles, AppendParticles ) 

  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: InitParticles
  LOGICAL, OPTIONAL :: AppendParticles

  TYPE(ValueList_t), POINTER :: Params 
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t), POINTER :: CurrentElement
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: Offset, NewParticles,LastParticle,NoElements
  INTEGER :: dim, ElementIndex
  REAL(KIND=dp), POINTER :: rWork(:,:),Coordinate(:,:), Velocity(:,:)
  REAL(KIND=dp) :: Velo(3), Coord(3), Center(3), time0, dist
  CHARACTER(LEN=MAX_NAME_LEN) :: InitMethod
  INTEGER :: i,j,k,n,nonodes, InitStatus, TotParticles
  INTEGER, POINTER :: MaskPerm(:), InvPerm(:), NodeIndexes(:)
  LOGICAL :: GotIt, GotMask, RequirePositivity
  REAL(KIND=dp), POINTER :: InitialValues(:,:)
  REAL(KIND=dp) :: mass,boltz,temp,coeff,eps,frac,meanval 
  REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), Diam
  REAL(KIND=dp), POINTER :: MaskVal(:)
  INTEGER :: nx,ny,nz,nmax,ix,iy,iz,ind
  LOGICAL, POINTER :: DoneParticle(:)
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  

  Mesh => GetMesh()
  Params => GetSolverParams()
  dim = Particles % Dim

  !------------------------------------------------------------------------
  ! Position may be initialized using a given list, or using the nodal
  ! coordinates to initalize positions.
  !-------------------------------------------------------------------------
  
  InitMethod = ListGetString( Params,'Coordinate Initialization Method',gotIt ) 

  !------------------------------------------------------------------------
  ! The user may use a mask to initialize the particles only at a part of the 
  ! domain, or to utilize the ordeing of the permutation vector.
  ! Create the mask before deciding on the number which may be relative
  !-------------------------------------------------------------------------  
  GotMask = .FALSE.
  VariableName = ListGetString( Params,'Initialization Condition Variable',GotIt )
  IF(GotIt) THEN
    RequirePositivity = .TRUE.
  ELSE
    VariableName = ListGetString( Params,'Initialization Mask Variable',GotIt )
    RequirePositivity = .FALSE.
  END IF
  
  IF(GotIt) THEN
    Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
    IF( .NOT. ASSOCIATED( Var ) ) THEN
      CALL Fatal('InitializeParticles','Mask / Condition variable does not exist!')
    END IF

    MaskPerm => Var % Perm
    MaskVal => Var % Values

    IF(.NOT. ( ASSOCIATED( MaskPerm ) .AND. ASSOCIATED(MaskVal)) ) THEN
      CALL Warn('InitializeParticles','Initialization variable does not exist?')
    ELSE IF( MAXVAL( MaskPerm ) == 0 ) THEN
      CALL Warn('InitializeParticles','Initialization variable of size zero?')
      nonodes = 0
      noelements = 0
      InvPerm => NULL()
    ELSE
      GotMask = .TRUE.
      IF( InitMethod(1:5) == 'nodal') THEN
        ALLOCATE( InvPerm(SIZE(MaskPerm)) )
        InvPerm = 0
        j = 0
        DO i=1,SIZE(MaskPerm)
          k = MaskPerm(i)
          IF( k == 0 ) CYCLE
          IF( RequirePositivity ) THEN
            IF( MaskVal( k ) < 0.0_dp ) CYCLE
          END IF
          j = j + 1
          InvPerm(j) = i
        END DO
        nonodes = j
        
        PRINT *,'Total nodes vs. masked',Mesh % NumberOfNodes,nonodes
      ELSE IF( InitMethod(1:9) == 'elemental') THEN
        ALLOCATE( InvPerm( MAX( Mesh % NumberOfBulkElements, Mesh % NumberOfBoundaryElements ) ) ) 
        InvPerm = 0
        
        j = 0
        DO i=1,Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
          CurrentElement => Mesh % Elements(i)
          NodeIndexes =>  CurrentElement % NodeIndexes
          n = CurrentElement % TYPE % NumberOfNodes
          
          IF( i == Mesh % NumberOfBulkElements ) THEN
            IF( j > 0 ) EXIT
          END IF
          
          IF( ANY( MaskPerm( NodeIndexes ) == 0 ) ) CYCLE
          
          IF( RequirePositivity ) THEN
            meanval = SUM( MaskVal( MaskPerm( NodeIndexes ) ) ) 
            IF( meanval < 0.0_dp ) CYCLE
          END IF
          
          ! If some of bulk elements have been found avtive
          j = j + 1
          InvPerm(j) = i
          
        END DO
        noelements = j
        
        PRINT *,'Total elements vs. masked',Mesh % NumberOfBulkElements,noelements
      END IF
    END IF
  ELSE
    nonodes = Mesh % NumberOfNodes
    noelements = Mesh % NumberOfBulkElements
  END IF

  
  !------------------------------------------------------------------------
  ! Use a simple bounding box for initializatin
  ! By default a local bounding box is used...
  !-------------------------------------------------------------------------  
  IF( InitMethod(1:3) == 'box') THEN
    Eps = GetCReal( Params,'Wall Particle Radius',GotIt)
    IF(.NOT. GotIt) eps = 1.0d-8
    
    MinCoord(1) = GetCReal( Params,'Min Initial Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MinCoord(1) = Particles % LocalMinCoord(1) + eps
    
    MaxCoord(1) = GetCReal( Params,'Max Initial Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MaxCoord(1) = Particles % LocalMaxCoord(1) - eps

    MinCoord(2) = GetCReal( Params,'Min Initial Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MinCoord(2) = Particles % LocalMinCoord(2) + eps
    
    MaxCoord(2) = GetCReal( Params,'Max Initial Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MaxCoord(2) = Particles % LocalMaxCoord(2) - eps
    
    MinCoord(3) = GetCReal( Params,'Min Initial Coordinate 3',GotIt) 
    IF(.NOT. GotIt) MinCoord(3) = Particles % LocalMinCoord(3) 
    
    MaxCoord(3) = GetCReal( Params,'Max Initial Coordinate 3',GotIt) 
    IF(.NOT. GotIt) MaxCoord(3) = Particles % LocalMaxCoord(3) - eps
  END IF


  IF( InitMethod == 'box random cubic') THEN
    Diam = 2 * GetCReal( Params,'Particle Cell Radius',GotIt)
    IF(.NOT. GotIt ) THEN
      Diam = 2 * GetCReal( Params,'Particle Radius',GotIt)
    END IF
    IF(.NOT. GotIt ) THEN
      CALL Fatal('InitializeParticles','Size of unit cell not given')
    END IF
    
    nx = NINT ( ( MaxCoord(1) - MinCoord(1) ) / Diam )
    ny = NINT( ( MaxCoord(2) - MinCoord(2) ) / Diam )
    IF( dim == 3 ) THEN
      nz = NINT( ( MaxCoord(3) - MinCoord(3) ) / Diam )
    ELSE
      nz = 1
    END IF

    PRINT *,'n:',nx,ny,nz,nx*ny*nz
    PRINT *,'Min:',MinCoord
    PRINT *,'Max:',MaxCoord
  END IF


  !------------------------------------------------------------------------
  ! Now decide on the number of particles.
  !-------------------------------------------------------------------------  
  IF( PRESENT( AppendParticles ) ) THEN
    Offset = Particles % NumberOfParticles
  ELSE
    Offset = 0
  END IF
  
  IF( PRESENT( InitParticles ) ) THEN
    NewParticles = InitParticles
  ELSE
    NewParticles = GetInteger( Params,'Number of Particles',GotIt) 
    IF(.NOT. GotIt ) THEN
      frac = GetCReal( Params,'Particle Node Fraction',GotIt)      
      IF( GotIt ) THEN
        NewParticles = NINT( frac * nonodes )
      ELSE
        frac = GetCReal( Params,'Particle Element Fraction',GotIt)
        IF( GotIt ) THEN
          NewParticles = NINT( frac * noelements )
        ELSE
          frac = GetCReal( Params,'Particle Cell Fraction',GotIt)
          IF( GotIt ) THEN
            NewParticles = NINT( frac * nx * ny * nz )
          ELSE
            CALL Fatal('InitializeParticles','Could not determine the number of new particles!')
          END IF
        END IF
      END IF
    END IF
  END IF

  IF( ParEnv% PEs == 1 ) THEN
    TotParticles = NewParticles
  ELSE
    TotParticles = NINT( ParallelReduction( 1.0_dp * NewParticles ) )
  END IF

  IF( TotParticles == 0 ) THEN
    CALL Fatal('InitializeParticles','No Particles to Initialize')
  ELSE
    WRITE( Message,'(A,I8)') 'Total Number of Particles:',TotParticles
    CALL Info('InitializeParticles',Message)
  END IF

  !------------------------------------------------------------------------
  ! If there are no particles in this partition, nothing to do
  !------------------------------------------------------------------------- 
  IF( NewParticles == 0 ) RETURN

    
  !------------------------------------------------------------------------
  ! Interval of particles
  !-------------------------------------------------------------------------  
  IF( PRESENT( AppendParticles ) ) THEN
    Offset = Particles % NumberOfParticles
  ELSE
    Offset = 0
  END IF
  LastParticle = Offset + NewParticles


  !------------------------------------------------------------------------
  ! Allocate particles
  !-------------------------------------------------------------------------    
  CALL AllocateParticles( Particles, LastParticle )

  Particles % NumberOfParticles = LastParticle

  Velocity => Particles % Velocity
  Coordinate => Particles % Coordinate
  

  SELECT CASE ( InitMethod ) 
    
  CASE ('nodal ordered')
    NewParticles = MIN(NoElements,NewParticles)
    Particles % NumberOfParticles = NewParticles
    PRINT *,'Initializing particles in nodes:',NewParticles,nonodes
    DO i=1,NewParticles
      k = Offset + i
      j = (nonodes-1)*(i-1)/(NewParticles-1)+1
      j = MODULO( i * NewParticles -1 , nonodes ) + 1
      IF( GotMask ) j = InvPerm(j)
      Coordinate(k,1) = Mesh % Nodes % x(j)
      Coordinate(k,2) = Mesh % Nodes % y(j)
      IF( dim == 3 ) Coordinate(k,3) = Mesh % Nodes % z(j)
    END DO

  CASE ('elemental ordered')
    NewParticles = MIN(NoElements,NewParticles)
    Particles % NumberOfParticles = NewParticles
    PRINT *,'Initializing particles in elements:',NewParticles,noelements
    DO i=1,NewParticles
      k = Offset + i
      j = (NoElements-1)*(i-1)/(NewParticles-1)+1
      IF( GotMask ) j = InvPerm(j)


      IF( j > Mesh % NumberOfBulkElements ) THEN
        PRINT *,'j too large',j,i,k,(NoElements-1)*(i-1)/(NewParticles-1)+1
      END IF

      CurrentElement => Mesh % Elements(j)
      NodeIndexes =>  CurrentElement % NodeIndexes
      n = CurrentElement % TYPE % NumberOfNodes
      Coordinate(k,1) = SUM( Mesh % Nodes % x(NodeIndexes ) ) / n
      Coordinate(k,2) = SUM( Mesh % Nodes % y(NodeIndexes ) ) / n
      IF( dim == 3 ) Coordinate(k,3) = SUM( Mesh % Nodes % z(NodeIndexes ) ) / n

      ! Only a bulk element may own a particle
      IF( j <= Mesh % NumberOfBulkElements ) THEN
        Particles % ElementIndex(i) = j
      END IF
    END DO
    PRINT *,'done init'

  CASE ('sphere random')
    Diam = GetCReal( Params,'Initial Sphere Radius')
    rWork => ListGetConstRealArray( Params,'Initial Sphere Center')
    IF ( ASSOCIATED(rwork) ) THEN
      Center = rWork(1:3,1)
    ELSE
      Center = 0.0_dp
    END IF

    i = 0
    DO WHILE (.TRUE.) 
      DO j=1,dim
        Coord(j) = Diam*(2*EvenRandom()-1)
      END DO
      ! Is the point within sphere (or circle in 2d)
      IF( SUM( Coord(1:dim)**2 ) > Diam*Diam ) CYCLE

      i = i + 1
      k = Offset + i      
      Coordinate(k,:) = Center + Coord(1:dim)
      IF( i == NewParticles ) EXIT
    END DO

  CASE ('box random')
    DO i=1,NewParticles
      k = Offset + i      
      DO j=1,dim
        Coord(j) = MinCoord(j) + (MaxCoord(j)-MinCoord(j)) * EvenRandom()
      END DO
      Coordinate(k,:) = Coord(1:dim)
    END DO

  CASE ('box random cubic')
    nmax = nx * ny * nz
    IF( nmax < NewParticles ) THEN
      CALL Fatal('InitializeParticles','More particles than places in unit cell')
    END IF

    ALLOCATE( DoneParticle(nx*ny*nz) )

    IF( NewParticles == nmax ) THEN
      ! if the list is full just set all true
      DoneParticle = .TRUE.
    ELSE IF( NewParticles < nmax / 2 ) THEN
      ! If there are few particles start from an empty list and count upwards
      DoneParticle = .FALSE.
      i =  0
      DO WHILE(.TRUE.) 
        ind = NINT( NewParticles * EvenRandom() + 0.5 )
        IF( .NOT. DoneParticle(i) ) THEN
          DoneParticle(ind) = .TRUE.
          i = i + 1
          IF( i == NewParticles ) EXIT
        END IF
      END DO
    ELSE    
      ! if there are many particles start from a full list and count downwards
      DoneParticle = .TRUE.
      i = nmax
      DO WHILE(.TRUE.) 
        ind = NINT( NewParticles * EvenRandom() + 0.5 )
        IF( DoneParticle(i) ) THEN
          DoneParticle(ind) = .FALSE.
          i = i - 1
          IF( i == NewParticles ) EXIT
        END IF
      END DO
    END IF

    ! set the coordinates 
    i = 0
    DO ix = 1, nx
      DO iy = 1, ny
        DO iz = 1, nz
          ind = nx*ny*(iz-1) + nx*(iy-1) + ix
          IF( DoneParticle(ind) ) THEN
            i = i + 1
            k = Offset + i
            Coordinate(k,1) = MinCoord(1) + ( 1.0_dp*ix - 0.5) * Diam 
            Coordinate(k,2) = MinCoord(2) + ( 1.0_dp*iy - 0.5) * Diam 
            IF( dim == 3 ) THEN
              Coordinate(k,3) = MinCoord(3) + ( 1.0_dp*iz - 0.5) * Diam 
            END IF
          END IF
        END DO
      END DO
    END DO
    DEALLOCATE( DoneParticle ) 

    
  CASE DEFAULT 
    
    InitialValues => ListGetConstRealArray(Params,'Initial Coordinates',gotIt)    
      IF(gotIt) THEN
        IF( SIZE(InitialValues,2) /= dim ) THEN
          CALL Fatal('ParticleTracker','Wrong dimension in Initial Coordinates')
        ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
          DO i=1,NewParticles
            k = offset + i
            Coordinate(k,1:dim) = InitialValues(1,1:dim)
          END DO
        ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
          CALL Fatal('ParticleTracker','Wrong number of particles in Initial Coordinates')
        ELSE
          DO i=1,NewParticles
            k = Offset + i
            Coordinate(k,1:dim) = InitialValues(i,1:dim)
          END DO
        END IF
      ELSE
        CALL Fatal('ParticleTracker','Initial Coordinates not given')
      END IF
    END SELECT

    IF( GotMask .AND. ASSOCIATED(InvPerm) ) DEALLOCATE( InvPerm ) 

    !------------------------------------------------------------------------
    ! Velocities may be initialized using a given list, or obtaining them
    ! from random even or maxwell boltzmann distributions. These are additive to 
    ! allow bulk velocities with the random one.
    !-------------------------------------------------------------------------

    InitialValues => ListGetConstRealArray(Params,'Initial Velocities',gotIt)
    IF(gotIt) THEN
      IF( SIZE(InitialValues,2) /= DIM ) THEN
        CALL Fatal('ParticleTracker','Wrong dimension in Initial Velocities')
      ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
        DO i=1,NewParticles
          k = Offset + i
          Velocity(k,1:dim) = InitialValues(1,1:DIM)
        END DO
      ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
        CALL Fatal('ParticleTracker','Wrong number of particles in Initial Velocities')
      ELSE
        DO i=1,NewParticles
          k = Offset + i
          Velocity(k,1:dim) = InitialValues(i,1:dim)
        END DO
      END IF
    END IF


    InitMethod = ListGetString( Params,'Velocity Initialization Method',gotIt ) 
    coeff = ListGetCReal( Params,'Initial Velocity Amplitude',GotIt)

    SELECT CASE ( InitMethod ) 
      
    CASE ('thermal random')  
      
      IF(.NOT. GotIt) THEN
        mass = ListGetConstReal( Params,'Particle Mass')
        temp = ListGetConstReal( Params,'Particle Temperature')
        boltz = ListGetConstReal( CurrentModel % Constants,'Boltzmann constant')
        coeff = SQRT(boltz * temp / mass )
      END IF

      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) = coeff * NormalRandom()
        END DO
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE ('even random')
      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) = coeff * (2*EvenRandom()-1)
        END DO
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE ('constant random')
      DO i=1,NewParticles
        k = Offset + i
        DO j=1,dim
          Velo(j) =  coeff * (2*EvenRandom()-1)
        END DO
        Velo(1:dim) = Velo(1:dim) / SQRT(SUM(Velo(1:dim)**2))
        Velocity(k,:) = Velocity(k,:) + Velo(1:dim)
      END DO

    CASE DEFAULT

    END SELECT


    ! There may be a timestep related to initial velocity,
    ! which may be used to have the initial status developed
    ! from the initial coordinates.
    !-------------------------------------------------------
    time0 = ListGetCReal(Params,'Initial Velocity Time',gotIt)
    IF( GotIt ) THEN
      DO i=1,NewParticles
        k = Offset + i
        Coord(1:dim) = time0 * Velocity(k,:)
        Coordinate(k,:) = Coordinate(k,:) + Coord(1:dim)

        dist = SQRT( SUM( Coord(1:dim)**2 ) )
        Particles % Distance(k) = dist
      END DO
    END IF

    ! Initialize coordinate with octree if requested
    !-------------------------------------------------------
    IF( ListGetLogical(Params,'Initial Coordinate Search',gotIt) ) THEN
      Coord = 0.0_dp
      DO i=1,NewParticles
        k = Offset + i
        ElementIndex = Particles % ElementIndex(k)
        IF( ElementIndex > 0 ) CYCLE       
        Coord(1:dim) = Coordinate(k,:) 
        CALL LocateParticleInMeshOctree( ElementIndex, Coord )
        Particles % ElementIndex(k) = ElementIndex
      END DO
    END IF
    
    !------------------------------------------------------
    ! The initial status of particles is different if using 
    ! gradual release strategy. 
    !-------------------------------------------------------
    IF( ListCheckPresent( Params,'Particle Release Number') .OR. &
      ListCheckPresent( Params,'Particle Release Fraction') ) THEN
      InitStatus = PARTICLE_WAITING
    ELSE
      InitStatus = PARTICLE_INITIATED
    END IF
    
    DO i=1,NewParticles
      k = Offset + i
      Particles % Status(k) = InitStatus
    END DO


  END SUBROUTINE InitializeParticles

 

!---------------------------------------------------------------------------
! This subroutine finds the possible intersection between elementfaces 
! and a line segment.
!---------------------------------------------------------------------------
  SUBROUTINE SegmentElementIntersection(Mesh,BulkElement,&
      Rinit,Rfin,MinLambda,FaceElement)
!---------------------------------------------------------------------------
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER   :: BulkElement
  REAL(KIND=dp) :: Rinit(3), Rfin(3), MinLambda
  TYPE(Element_t), POINTER :: FaceElement

  TYPE(Element_t), POINTER   :: BoundaryElement
  TYPE(Nodes_t), SAVE :: BoundaryNodes
  REAL(KIND=dp) :: Lambda, Epsilon
  INTEGER :: i,j,n
  INTEGER, POINTER :: NodeIndexes(:)
  LOGICAL :: AtBoundary, Visited = .FALSE.


  SAVE  Visited

  MinLambda = HUGE( MinLambda ) 
  Epsilon = TINY( Lambda ) 
  FaceElement => Null()

  IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
    DO i=1, BulkElement % TYPE % NumberOfFaces  
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)

      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 
      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  ELSE
    DO i=1, BulkElement % TYPE % NumberOfEdges  
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges(j)
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)
     
      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 

      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  END IF

END SUBROUTINE SegmentElementIntersection


!------------------------------------------------------------------------
! Find the particle in the mesh using actree based search. 
! This could be preferred in the initial finding of the correct elements.
! The major downside of the method is that there is no controlled face
! detection needed for wall interaction, for example.
!------------------------------------------------------------------------
SUBROUTINE LocateParticleInMeshOctree( ElementIndex, GlobalCoords, &
    LocalCoords )
  
  USE Lists

  INTEGER :: ElementIndex
  REAL(KIND=dp) :: GlobalCoords(3)
  REAL(KIND=dp), OPTIONAL :: LocalCoords(3)

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  LOGICAL :: Hit, Stat
  INTEGER :: i,j,k,n
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element
  TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
  REAL(kind=dp) :: BoundingBox(6), eps2, eps1, uvw(3)
  

  Mesh => GetMesh()

  ! Check that the previous hit is not hit even now
  !-------------------------------------------------
  IF( ElementIndex > 0 ) THEN
    Element => Mesh % Elements( ElementIndex ) 
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)
    
    IF ( PointInElement( Element, ElementNodes, &
        GlobalCoords, LocalCoords ) ) RETURN
  END IF

  !-----------------------------------------------------------
  ! Find the right element using an octree search
  ! This is optimal when the particles are searched only once.
  !-----------------------------------------------------------
  IF ( .NOT.ASSOCIATED(Mesh % RootQuadrant) ) THEN
    BoundingBox(1) = MINVAL( Mesh % Nodes % x )
    BoundingBox(2) = MINVAL( Mesh % Nodes % y )
    BoundingBox(3) = MINVAL( Mesh % Nodes % z )
    BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
    BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
    BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
    
    eps1 = 1.0e-3
    eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
    BoundingBox(1:3) = BoundingBox(1:3) - eps2
    BoundingBox(4:6) = BoundingBox(4:6) + eps2
    
    CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
  END IF
  RootQuadrant => Mesh % RootQuadrant

  Element => Null()
  ElementIndex = 0
  CALL FindLeafElements(GlobalCoords, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
  IF ( ASSOCIATED(LeafQuadrant) ) THEN
    DO i = 1, LeafQuadrant % NElemsInQuadrant
      j = LeafQuadrant % Elements(i)
      Element => Mesh % Elements(j)
      
      n = GetElementNOFNodes( Element )
      CALL GetElementNodes( ElementNodes, Element)
      
      IF ( PointInElement( Element, ElementNodes, GlobalCoords, uvw ) ) THEN
        IF( PRESENT( LocalCoords) ) LocalCoords = uvw
        ElementIndex = j
        RETURN
      END IF
    END DO
  END IF

  IF( ElementIndex == 0 ) THEN
    CALL Warn('LocateParticleInMeshOctree','Could not locate particle in the mesh!')
  END IF
  
END SUBROUTINE LocateParticleInMeshOctree


!------------------------------------------------------------------------
! Locate the particle using controlled marching from element to element.
! The crossing point between given trajectory and all face elements is 
! computed. The one that is passed at first is associated to the next 
! bulk element.
!-------------------------------------------------------------------------
SUBROUTINE LocateParticleInMeshMarch( ElementIndex, Rinit, Rfin, Init, &
    ParticleStatus, StopFaceIndex, Lambda )
  
  INTEGER :: ElementIndex
  REAL(KIND=dp) :: Rinit(3), Rfin(3)
  LOGICAL :: Init
  REAL(KIND=dp), OPTIONAL :: Lambda
  INTEGER :: ParticleStatus
  INTEGER, OPTIONAL :: StopFaceIndex

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: Rtmp(3), MinLambda, eps 
  LOGICAL :: Hit, DoInit, Stat, StopAtFace, AtWall, Visited = .FALSE.,&
      Debug,UseCenter
  INTEGER :: i,j,k,n,FaceIndex,MaxTrials
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element, FaceElement, LeftElement, RightElement, &
      NextElement
  
  INTEGER, POINTER :: Neighbours(:)
  INTEGER :: NextPartition
  LOGICAL, POINTER :: FaceInterface(:)

  SAVE :: Mesh, StopAtFace, Debug, MaxTrials

  Mesh => GetMesh()


  IF( .NOT. Visited ) THEN
    Params => GetSolverParams()
    StopAtFace = ListGetLogical( Params,'Particle Stop At Face',Stat)
    MaxTrials = ListGetInteger( Params,'Max Particle Search Trials',Stat)
    IF(.NOT. Stat) MaxTrials = Mesh % NumberOfBulkElements

    Debug = .FALSE.
    Visited = .TRUE.
  END IF

  ParticleStatus = PARTICLE_LOST
  IF( PRESENT (StopFaceIndex) ) StopFaceIndex = 0
  IF( PRESENT( Lambda ) ) Lambda = 1.0_dp
  
  !--------------------------------------------------------------------
  ! This is a recursive algorithm that checks the intersections 
  ! of line segments and points until correct element is found.
  ! This is optimal when the stepsize is small and there are many steps.
  !--------------------------------------------------------------------
  DoInit = Init
  IF( ElementIndex == 0 ) THEN
    DoInit = .TRUE.
    ElementIndex = 1
    UseCenter = .TRUE.
  ELSE	
    UseCenter = .NOT. StopAtFace
  END IF
  
  Element => Mesh % Elements( ElementIndex ) 
  eps = 1.0d-10
  
  DO i=1,MaxTrials
    n = GetElementNOFNOdes(Element)
    CALL GetElementNodes(ElementNodes,Element)

    ! Use the previous element center if the true path is of no importance
    !---------------------------------------------------------------------	
    IF( UseCenter ) THEN
      Rtmp(1) = SUM( ElementNodes % x(1:n) ) / n
      Rtmp(2) = SUM( ElementNodes % y(1:n) ) / n
      Rtmp(3) = SUM( ElementNodes % z(1:n) ) / n
    ELSE
      Rtmp = Rinit
    END IF

    CALL SegmentElementIntersection(Mesh,Element,&
        Rtmp,Rfin,MinLambda,FaceElement )
    
    IF( .NOT. ASSOCIATED( FaceElement ) ) THEN
      ! The likely cause for unsuccessful operation is that the 
      ! initial node and target node are the same
      IF( SUM ( ( Rtmp - Rfin )**2 ) < eps**2 ) THEN
        ParticleStatus = PARTICLE_HIT
        EXIT
      ELSE
        CALL Warn('LocateParticleInMesh','No intersection found?')
        PRINT *,'Rtmp',Rtmp
        PRINT *,'Rfin',Rfin
        EXIT
      END IF
    ELSE IF( MinLambda > 1.0 - eps ) THEN
      ParticleStatus = PARTICLE_HIT
      Rtmp = Rfin
      EXIT
    ELSE 
      LeftElement  => FaceElement % BoundaryInfo % Left
      RightElement => FaceElement % BoundaryInfo % Right
      
      IF( ASSOCIATED( LeftElement) .AND. ASSOCIATED(RightElement)) THEN
        IF( ASSOCIATED(Element, LeftElement)) THEN
          NextElement => RightElement
        ELSE
          NextElement => LeftElement
        END IF
        
        IF( StopAtFace .AND. .NOT. DoInit ) ParticleStatus = PARTICLE_FACEBOUNDARY
      ELSE
        ParticleStatus = PARTICLE_WALLBOUNDARY
      END IF
      
      ! There are different reasons why the particle is only integrated until the face
      IF( ParticleStatus == PARTICLE_WALLBOUNDARY .OR. &
          ParticleStatus == PARTICLE_FACEBOUNDARY ) THEN
        IF( PRESENT( Lambda ) ) Lambda = MinLambda
        Rtmp = Rinit + MinLambda * (Rfin - Rinit) 
        StopFaceIndex = FaceElement % ElementIndex
        EXIT                      
      END IF
    END IF
    
    ! continue the search to new elements
    Element => NextElement
  END DO
  ElementIndex = Element % ElementIndex
  
END SUBROUTINE LocateParticleInMeshMarch



!------------------------------------------------------------------------
! Locate all the new elements of the particles
!-------------------------------------------------------------------------
SUBROUTINE LocateParticles( Particles, PartitionChangesOnly )

  USE Lists

  TYPE(Particle_t) :: Particles
  LOGICAL, OPTIONAL :: PartitionChangesOnly

  INTEGER :: Status, ElementIndex, No, NoParticles, dim
  REAL(KIND=dp) :: Rinit(3), Rfin(3)
  LOGICAL :: InitLocation, Visited=.FALSE.
  INTEGER :: FaceIndex
  REAL(KIND=dp) :: Lambda
  TYPE(Mesh_t), POINTER :: Mesh


  NoParticles = Particles % NumberOfParticles
  dim = Particles % dim
  

  DO No = 1, NoParticles

    Status = Particles % Status( No )

    IF( Status >= PARTICLE_LOST ) CYCLE
    IF( Status < PARTICLE_INITIATED ) CYCLE

    IF ( PRESENT(PartitionChangesOnly) ) THEN
      IF ( PartitionChangesOnly .AND. Status /= PARTICLE_PARTBOUNDARY ) CYCLE
    END IF
    
    ElementIndex = Particles % ElementIndex( No )
    
    ! We only need to find the right element, path is not of importance
    InitLocation = ( Status < PARTICLE_LOCATED ) 
    Rfin(1:dim) = GetParticleCoord( Particles, No, 0 )
    ElementIndex = GetParticleElement( Particles, No )

    ! Note that if we want proper collisions with the boundary done within this
    ! routine the initial coordinates should really not be rfin!!
    !---------------------------------------------------------------------------
    CALL LocateParticleInMeshMarch(ElementIndex, Rfin, Rfin, InitLocation, &
        Status, FaceIndex, Lambda )

    Particles % FaceIndex(No) = FaceIndex
    Particles % Status(No) = Status
    Particles % ElementIndex(No) = ElementIndex
  END DO

END SUBROUTINE LocateParticles



!--------------------------------------------------------------------------
! Given the element & global coordinates returns the local coordinates.
! The idea of this routine is to transparently block the local coordinate
! search from the user by directly giving the basis function values related
! to a global coordinate.
!--------------------------------------------------------------------------
FUNCTION ParticleElementInfo( CurrentElement, GlobalCoord, &
    SqrtElementMetric, Basis, dBasisdx ) RESULT ( stat )
  
  TYPE(Element_t), POINTER :: CurrentElement
  REAL(KIND=dp) :: GlobalCoord(:), SqrtElementMetric
  REAL(KIND=dp) :: Basis(:)
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:)
  LOGICAL :: Stat

  TYPE(Nodes_t) :: ElementNodes
  REAL(KIND=dp) :: LocalCoord(3),u,v,w
  INTEGER :: n

  SAVE ElementNodes

  n = CurrentElement % TYPE % NumberOfNodes
  CALL GetElementNodes(ElementNodes,CurrentElement)
  
  Stat = PointInElement( CurrentElement, ElementNodes, &
      GlobalCoord, LocalCoord ) 
  IF( .NOT. Stat ) THEN
    CALL Warn('GlobalElementInfo','Should have found the node!')
    PRINT *,'GlobalCoord:',GlobalCoord
    RETURN
  END IF
  
  u = LocalCoord(1)
  v = LocalCoord(2)
  w = LocalCoord(3)
    
  stat = ElementInfo( CurrentElement, ElementNodes, U, V, W, SqrtElementMetric, &
      Basis, dBasisdx )

END FUNCTION ParticleElementInfo



!-------------------------------------------------------------------------
! The routine returns velocity and optionally a gradient of velocity.
! These kind of functions are needed repeated and therefore to reduced the 
! size of individual solvers it has been hard coded here. 
! This may seem stupid but probably there are just a few fields where this
! has to be done...
!--------------------------------------------------------------------------

SUBROUTINE GetVectorFieldInMesh(Var, CurrentElement, Basis, Velo, dBasisdx, GradVelo )
  
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t) :: CurrentElement
  REAL(KIND=dp) :: Basis(:), Velo(:) 
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradVelo(:,:)

  INTEGER, POINTER :: LocalPerm(:)
  REAL(KIND=dp), POINTER :: LocalVelo(:,:)
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: VeloFieldDofs
  REAL(KIND=dp) :: SumBasis
  INTEGER :: i,j,k,n,npos,ind,dim
  LOGICAL :: GotIt
  LOGICAL :: Visited


  SAVE :: Visited, Dim, LocalVelo, LocalPerm

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    n = Mesh % MaxElementNodes
    ALLOCATE( LocalPerm(n), LocalVelo(n,3) )
    LocalPerm = 0
    LocalVelo = 0.0_dp
    Dim = Mesh % MeshDim
    Visited = .TRUE.
  END IF

  Velo = 0.0_dp
  IF( PRESENT( GradVelo ) ) GradVelo = 0.0_dp

  n = CurrentElement % TYPE % NumberOfNodes
  LocalPerm(1:n) = Var % Perm( CurrentElement % NodeIndexes )
  npos = COUNT ( LocalPerm(1:n) > 0 )


  IF( npos == 0 ) RETURN

  !-----------------------------------------------------------------
  ! compute the velocity also for case when the particle
  ! has just crossed the boundary. For example, its floating on the 
  ! fluid boundary. This is a little bit fishy and could perhaps 
  ! only be done conditionally....
  ! Can't really determine the gradient here
  !-----------------------------------------------------------------
  VeloFieldDofs = Var % Dofs
  IF( npos == n ) THEN
    DO i=1,n
      j = LocalPerm(i)
      LocalVelo(i,1:dim) = Var % Values( VeloFieldDofs*(j-1)+1:dim)
    END DO
  ELSE    
    SumBasis = 0.0_dp
    DO i=1,n
      j = LocalPerm(i)
      IF( j > 0 ) THEN
        SumBasis = SumBasis + Basis(i)
        LocalVelo(i,1:dim) = Var % Values( VeloFieldDofs*(j-1)+1:dim)
      ELSE
        LocalVelo(i,1:dim) = 0.0_dp
      END IF
    END DO
  END IF

  DO i=1,dim
    Velo(i) = SUM( Basis(1:n) * LocalVelo(1:n,i) )
    IF( PRESENT( GradVelo ) ) THEN
      DO j=1,dim
        GradVelo(i,j) = SUM( dBasisdx(1:n,j) * LocalVelo(1:n,i) )
      END DO
    END IF
  END DO

  IF( npos < n ) THEN
    Velo = Velo / SumBasis
    GradVelo = GradVelo / SumBasis
  END IF

END SUBROUTINE GetVectorFieldInMesh


!-------------------------------------------------------------------------
! The routine returns a potential and its gradient.
!--------------------------------------------------------------------------

SUBROUTINE GetScalarFieldInMesh(Var, CurrentElement, Basis, Pot, dBasisdx, GradPot )
   
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t) :: CurrentElement
  REAL(KIND=dp) :: Basis(:), Pot 
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradPot(:)

  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER, POINTER :: LocalPerm(:)
  REAL(KIND=dp), POINTER :: LocalField(:)
  INTEGER :: i,j,n,dim
  LOGICAL :: Visited


  SAVE :: Visited, Mesh, Dim, LocalPerm, LocalField

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    n = Mesh % MaxElementNodes
    ALLOCATE( LocalPerm(n), LocalField(n) )
    LocalPerm = 0
    LocalField = 0.0_dp
    Dim = Mesh % MeshDim
    Visited = .TRUE.
  END IF

  Pot = 0.0_dp
  IF( PRESENT( GradPot ) ) GradPot = 0.0_dp

  IF(.NOT. ASSOCIATED( Var ) ) RETURN

  n = CurrentElement % TYPE % NumberOfNodes
  LocalPerm(1:n) = Var % Perm( CurrentElement % NodeIndexes )

  IF( .NOT. ALL ( LocalPerm(1:n) > 0 )) RETURN

  LocalField(1:n) = Var % Values( LocalPerm(1:n) )
  Pot = SUM( Basis(1:n) * LocalField(1:n) )

  IF( PRESENT( GradPot ) ) THEN
    DO i=1,dim
      GradPot(i) = SUM( dBasisdx(1:n,i) * LocalField(1:n) )
    END DO
  END IF

END SUBROUTINE GetScalarFieldInMesh



!-------------------------------------------------------------------------
! The routine returns the possible intersection of a secondary element 
! with a different material property and the circle / sphere.
! For example, the buoyancy at the interface will depend on the weighted
! sum of the densities of the two materials. 
!--------------------------------------------------------------------------

FUNCTION GetParticleElementIntersection(Particles,BulkElement, Basis, Coord, &
    Radius, BulkElement2, VolumeFraction, AreaFraction ) RESULT ( Intersect )
  
  TYPE(Particle_t) :: Particles
  TYPE(Element_t), POINTER :: BulkElement, BulkElement2
  REAL(KIND=dp) :: Basis(:)
  REAL(KIND=dp) :: Coord(3), Radius, VolumeFraction
  REAL(KIND=dp), OPTIONAL :: AreaFraction
  LOGICAL :: Intersect

  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: Dist, Normal(3), SumBasis
  TYPE(ValueList_t), POINTER :: Material, Material2, BC
  TYPE(Element_t), POINTER :: BoundaryElement, Left, Right
  TYPE(Nodes_t) :: BoundaryNodes
  INTEGER :: i,j,k,n,imax,body_id,body_id2,mat_id,mat_id2,dim,ind
  LOGICAL :: Visited


  SAVE :: Visited, Mesh, Dim

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    Dim = Mesh % MeshDim
    Visited = .TRUE.    
  END IF

  Intersect = .FALSE.
  VolumeFraction = 0.0_dp

  ! This element has no boundary / material interface
  IF( Particles % InternalElements( BulkElement % ElementIndex ) ) RETURN

  ! If the radius of the particle is zero then it sees only the properties of one point
  IF( Radius < TINY( Radius ) ) RETURN

  n = BulkElement % TYPE % NumberOfNodes
  body_id = BulkElement % BodyId
  mat_id = ListGetInteger( CurrentModel % Bodies(body_id) % Values,'Material' )

  IF( dim == 3 ) THEN
    imax = BulkElement % TYPE % NumberOfFaces 
  ELSE
    imax = BulkElement % TYPE % NumberOfEdges  
  END IF
  
  DO i=1, imax
 
   IF( dim == 3 ) THEN
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
    ELSE
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges(j)
    END IF
   
    IF( .NOT. ASSOCIATED( BoundaryElement % BoundaryInfo ) ) CYCLE
    
    Left => BoundaryElement % BoundaryInfo % Left
    Right => BoundaryElement % BoundaryInfo % Right

    IF(.NOT. (ASSOCIATED( Left ) .AND. ASSOCIATED( Right ) ) ) CYCLE

    IF( ASSOCIATED( BulkElement, Right ) ) THEN
      BulkElement2 => Left
    ELSE 
      BulkElement2 => Right 
    END IF
    
    IF( .NOT. ASSOCIATED( BulkElement2 ) ) CYCLE

    body_id2 = BulkElement2 % BodyId

    IF( body_id2 > CurrentModel % NumberOfBodies ) THEN
      PRINT *,'BodyIds:',body_id,body_id2,CurrentModel % NumberOfBodies
      PRINT *,'ElemIds:',BulkElement % ElementIndex, BulkElement2 % ElementIndex
      PRINT *,'Types:',BulkElement % TYPE % NumberOfNodes, &
          BulkElement2 % TYPE % NumberOfNodes
      body_id2 = 0
    END IF

    IF( body_id2 == 0 ) CYCLE

    mat_id2 = ListGetInteger( CurrentModel % Bodies(body_id2) % Values,'Material' )
    
    ! If the materials are the same the density is ok
    IF( mat_id2 == mat_id ) CYCLE
    


    ! If there is an material interface, check for distance
    CALL GetElementNodes(BoundaryNodes,BoundaryElement)
    Dist = PointFaceDistance(BoundaryElement,BoundaryNodes,Coord,Normal)
    Dist = ABS( Dist )       
    
    ! Is is assumed that each element may only have one density interface
    IF( Dist > Radius ) RETURN
        
    IF( dim == 3 ) THEN
      ! based on the formula of sphere-sphere intersection as in Wolfram MathWorld
      VolumeFraction = (Radius + Dist / 2 ) * (Radius - Dist)**2 / Radius**3
      IF( PRESENT( AreaFraction ) ) THEN
        AreaFraction = ( 1.0_dp - Dist/Radius )/2.0_dp
      END IF
    ELSE
      ! based on the formula of circle-circle intersection as in Wolfram MathWorld
      VolumeFraction = ( ( Radius ** 2) * ACOS( Dist / Radius ) &
          - Dist * SQRT( Radius ** 2 - Dist ** 2 ) ) / (PI * Radius**2) 
      IF( PRESENT( AreaFraction ) ) THEN
        AreaFraction = ACOS( Dist / Radius ) / PI
      END IF
    END IF

    !     PRINT *,'VolumeFraction:',VolumeFraction, Density
    RETURN
  END DO

END FUNCTION GetParticleElementIntersection


!-------------------------------------------------------------
! This subroutine may be used to enquire position dependent material data.
! Also if the particle is splitted between two elements then this 
! routine can assess the data on the secondary mesh.
!-------------------------------------------------------------
FUNCTION GetMaterialPropertyInMesh(PropertyName, BulkElement, Basis, &
    BulkElement2, VolumeFraction ) RESULT ( Property )
  
  CHARACTER(LEN=MAX_NAME_LEN) :: PropertyName
  TYPE(Element_t), POINTER :: BulkElement
  REAL(KIND=dp) :: Basis(:)
  TYPE(Element_t), POINTER, OPTIONAL :: BulkElement2
  REAL(KIND=dp), OPTIONAL :: VolumeFraction
  REAL(KIND=dp) :: Property

  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp), POINTER :: ElemProperty(:)
  REAL(KIND=dp) :: Property2
  TYPE(ValueList_t), POINTER :: Material, Material2
  INTEGER :: i,j,k,n,mat_id,mat_id2
  LOGICAL :: Visited


  SAVE :: Visited, Mesh, ElemProperty

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    n = Mesh % MaxElementNodes
    ALLOCATE( ElemProperty( n ) )
    ElemProperty = 0.0_dp
    Visited = .TRUE.    
  END IF

  NodeIndexes => BulkElement % NodeIndexes
  n = BulkElement % TYPE % NumberOfNodes
  mat_id = ListGetInteger( CurrentModel % Bodies(BulkElement % BodyId) % Values,'Material' )
  Material => CurrentModel % Materials(mat_id) % Values

  ElemProperty(1:n) = ListGetReal( Material,PropertyName,n,NodeIndexes) 
  Property = SUM( Basis(1:n) * ElemProperty(1:n) )

  IF( .NOT. PRESENT ( VolumeFraction ) ) RETURN
  IF( .NOT. PRESENT ( BulkElement2 ) ) RETURN
  IF( VolumeFraction < TINY( VolumeFraction) ) RETURN
      
  IF( ASSOCIATED( BulkElement2 ) ) THEN
    mat_id2 = ListGetInteger( CurrentModel % Bodies(BulkElement2 % BodyId) % Values,'Material' )
  ELSE
    mat_id2 = 0
  END IF
    
  ! If the materials are the same the density is ok
  IF( mat_id2 == mat_id ) RETURN
  
  ! If there is an material interface, check for distance
  IF( mat_id2 == 0 ) THEN
    Property2 = 0.0_dp
  ELSE
    NodeIndexes => BulkElement2 % NodeIndexes
    n = BulkElement2 % TYPE % NumberOfNodes
    Material2 => CurrentModel % Materials(mat_id2) % Values
    
    ElemProperty(1:n) = ListGetReal( Material,PropertyName,n,NodeIndexes) 

    ! One cannot use the basis functions of the primary element. 
    ! and this is valid for cases with constant material parameters.
    !------------------------------------------------------------------
    Property2 = SUM( ElemProperty(1:n) ) / n
  END IF

  Property = VolumeFraction * Property2 + (1-VolumeFraction) * Property
  !     PRINT *,'VolumeFraction:',VolumeFraction, Property
  RETURN

END FUNCTION GetMaterialPropertyInMesh


!-------------------------------------------------------------------------
! The routine returns .TRUE. if velocity should be fixed
!--------------------------------------------------------------------------

FUNCTION GetConditionInMesh(Var, CurrentElement, Basis ) RESULT ( Cond )
  
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t) :: CurrentElement
  REAL(KIND=dp) :: Basis(:)
  LOGICAL :: Cond

  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER, POINTER :: LocalPerm(:)
  REAL(KIND=dp), POINTER :: LocalValues(:)
  REAL(KIND=dp) :: val
  INTEGER :: i,j,n
  LOGICAL :: Visited

  SAVE :: Visited, LocalValues, LocalPerm

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    n = Mesh % MaxElementNodes
    ALLOCATE( LocalPerm(n), LocalValues(n) )
    LocalPerm = 0
    LocalValues = 0.0_dp
    Visited = .TRUE.
  END IF

  Cond = .FALSE.
  IF(.NOT. ASSOCIATED(Var) ) RETURN

  n = CurrentElement % TYPE % NumberOfNodes
  LocalPerm(1:n) = Var % Perm( CurrentElement % NodeIndexes )
  IF(.NOT. ALL(LocalPerm(1:n) > 0 )) RETURN 
  
  LocalValues(1:n) = Var % Values( LocalPerm(1:n) ) 
  val = SUM( Basis(1:n) * LocalValues(1:n) )
  
  IF( val > 0.0_dp ) Cond = .TRUE.

END FUNCTION GetConditionInMesh



!-------------------------------------------------------------
! This routine cretates the nearest neighbours for all nodes
! The particle-particle connections may then be found by going
! through all the nodes of elements
!-------------------------------------------------------------
SUBROUTINE CreateNeighbourList( Particles ) 

  TYPE(Particle_t) :: Particles
  
  INTEGER :: ElementIndex, dim
  REAL(KIND=dp) :: Coord(3), dist, mindist
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: i,j,k,n,node
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element
  INTEGER :: NoNodes, NoParticles, MaxClosest  

  Mesh => GetMesh()
  NoNodes = Mesh % NumberOfNodes

  NoParticles = Particles % NumberOfParticles
  IF( .NOT. Particles % NeighbourTable ) THEN
    ALLOCATE( Particles % NoClosestParticle( NoNodes ) ) 
    ALLOCATE( Particles % CumClosestParticle( NoNodes+1 ) ) 
    Particles % NeighbourTable = .TRUE.
  END IF

  IF ( ASSOCIATED(Particles % ClosestNode) ) &
   DEALLOCATE(Particles % ClosestNode )
  ALLOCATE( Particles % ClosestNode(Particles % MaxNumberOfParticles) )
  
  dim = Particles % dim 

  ! First find the closest node to each particle
  !-----------------------------------------------
  Particles % ClosestNode = 0
  Particles % NoClosestParticle = 0
  DO i=1,NoParticles 
    IF( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    ElementIndex = Particles % ElementIndex(i)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)    
    Coord(1:dim) = Particles % Coordinate(i,1:dim)

    ! Find the minimum distance node (using squares is faster)
    mindist = HUGE( mindist ) 
    DO j=1,n
      dist = ( ElementNodes % x(j) - Coord(1) )**2
      dist = dist +  ( ElementNodes % y(j) - Coord(2) )**2
      IF( dim == 3 ) THEN
        dist = dist +  ( ElementNodes % z(j) - Coord(3) )**2
      END IF
      IF( dist < mindist ) THEN
        mindist = dist 
        k = j
      END IF
    END DO    
    node = Element % NodeIndexes(k)
    Particles % ClosestNode(i) = node
    Particles % NoClosestParticle(node) = Particles % NoClosestParticle(node) + 1
  END DO

  CALL ExchangeNeighbourParticles(Particles)
  NoParticles = Particles % NumberOfParticles

  ! Count the cumulative number of closest particles for given node
  !-----------------------------------------------------------------
  Particles % CumClosestParticle(1) = 1
  MaxClosest = 0
  DO i=1,NoNodes
    j = Particles % NoClosestParticle(i)
    MaxClosest = MAX( MaxClosest, j )
    Particles % CumClosestParticle(i+1) = Particles % CumClosestParticle(i)+j
  END DO
  Particles % MaxClosestParticles = MaxClosest

  ! And finally, add the closest neigbours to the table 
  !----------------------------------------------------------------
  IF ( ASSOCIATED(Particles % ClosestParticle) ) &
    DEALLOCATE(Particles % ClosestParticle )
  ALLOCATE( Particles % ClosestParticle(Particles % CumClosestParticle(NoNodes+1)) )

  Particles % NoClosestParticle = 0
  Particles % ClosestParticle = 0
  DO i=1,NoParticles     
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE
    node = Particles % ClosestNode(i) 
    j = Particles % NoClosestParticle(node) 
    k = Particles % CumClosestParticle(node)
    Particles % ClosestParticle(k+j) = i
    Particles % NoClosestParticle(node) = j + 1
  END DO
END SUBROUTINE CreateNeighbourList


SUBROUTINE ExchangeNeighbourParticles(Particles)
  TYPE(Particle_t) :: Particles
!---------------------------------------------------------
  INTEGER i,j,k,l,m,n,dim,NoPartitions, node, &
      Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived

  INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
           Recv_parts(:), Requests(:)
  TYPE(Mesh_t), POINTER :: Mesh

  TYPE(ParallelInfo_t), POINTER :: PI

  LOGICAL, ALLOCATABLE :: IsNeighbour(:)
  INTEGER, POINTER :: Neighbours(:), Closest(:)

  TYPE ExchgInfo_t
    INTEGER :: n=0
    INTEGER, POINTER :: Gindex(:), Particles(:)
  END TYPE ExchgInfo_t

  REAL(KIND=dp), ALLOCATABLE :: Buf(:)
  TYPE(ExchgInfo_t), POINTER :: Info(:)
!--------------------------------------------------------

  nReceived = 0
  IF( ParEnv% PEs == 1 ) RETURN

  Mesh => GetMesh()
  dim = Particles % dim

  ! Count & Identify neighbouring partitions:
  ! -----------------------------------------
  ALLOCATE(IsNeighbour(ParEnv % PEs))
  NoPartitions = MeshNeighbours(Mesh,IsNeighbour)
  ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
  Perm = 0

  NoPartitions=0
  DO i=1,ParEnv % PEs
    IF ( i-1==ParEnv % Mype ) CYCLE
    IF ( IsNeighbour(i) ) THEN
      NoPartitions=NoPartitions+1
      Perm(i) = NoPartitions
      Neigh(NoPartitions) = i-1
    END IF
  END DO
  DEALLOCATE(IsNeighbour)

  ! Receive interface sizes:
  !--------------------------
  ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
  DO i=1,NoPartitions
    CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
         2000, MPI_COMM_WORLD, requests(i), ierr )
  END DO

  PI => Mesh % ParallelInfo

  ! Exchange interface particles
  ! ----------------------------
  ALLOCATE(Info(NoPartitions))
  DO i=1,NoPartitions
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    node = Particles % ClosestNode(i)
    IF ( .NOT. PI % INTERFACE(node) ) CYCLE
    Neighbours => PI % NeighbourList(node) % Neighbours
    DO j=1,SIZE(Neighbours)
      proc = Neighbours(j)
      IF ( Proc==Parenv % mype ) CYCLE
      proc = Perm(proc+1)
      IF ( Proc<=0 ) CYCLE
      Info(proc) % n = Info(proc) % n+1
    END DO
  END DO

  DO i=1,NoPartitions
    CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
             2000, MPI_COMM_WORLD, ierr )
  END DO

  !
  ! Collect particles to be sent to neighbours:
  ! -------------------------------------------
  DO i=1,NoPartitions
    IF ( Info(i) % n==0 ) CYCLE
    ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    node = Particles % ClosestNode(i)
    IF ( .NOT. PI % INTERFACE(node) ) CYCLE
    Neighbours => PI % NeighbourList(node) % Neighbours
    DO j=1,SIZE(Neighbours)
      proc = Neighbours(j)
      IF ( Proc==Parenv % mype ) CYCLE
      proc = Perm(proc+1)
      IF ( Proc<=0 ) CYCLE
      Info(proc) % n = Info(proc) % n+1
      Info(proc) % Particles(Info(proc) % n) = i
      Info(proc) % Gindex(Info(proc) % n) = PI % GlobalDOFs(node)
    END DO
  END DO

  n = 0
  DO i=1,NoPartitions
    n = n + Info(i) % n
  END DO
  n = 2*(n+2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
  CALL CheckBuffer(n)

  ! Send particles:
  ! ---------------
  DO j=1,NoPartitions
    n = Info(j) % n
    IF ( n<=0 ) CYCLE

    CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, &
        Neigh(j), 2001, MPI_COMM_WORLD, ierr )

    ALLOCATE(Buf(2*n*dim+n))
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
      END DO
    END DO
    DO l=1,n
      m = m + 1
      Buf(m) = Particles % Dt(Info(j) % Particles(l))
    END DO
    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
            Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
        END DO
      END DO
    END IF
    CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
        Neigh(j), 2002, MPI_COMM_WORLD, ierr )
    DEALLOCATE(Buf)
  END DO

  CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )
  n = SUM(Recv_Parts)
  IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
    CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
                   Particles % MaxNumberOfParticles )
  END IF


  ! Recv particles:
  ! ---------------
  DO i=1,NoPartitions
    n = Recv_Parts(i)
    IF ( n<=0 ) CYCLE

    proc = Neigh(i)

    ALLOCATE(Indexes(n))
    CALL MPI_RECV( Indexes, n, MPI_DOUBLE_PRECISION, proc, &
         2001, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    DO j=1,n
      n_part = n_part+1
      Particles % Status(n_part) = PARTICLE_GHOST
      node = SearchNode(PI,Indexes(j))
      IF ( node<=0 ) STOP 'a'
      Particles % ClosestNode(n_part) = node
      Particles % NoClosestParticle(node) = &
              Particles % NoClosestParticle(node) + 1
    END DO
    DEALLOCATE(Indexes)

    m = n+n*dim
    IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim

    ALLOCATE(Buf(m))
    CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
        2002, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Particles % Coordinate(n_part+l,k)=Buf(m)
      END DO
    END DO

    DO l=1,n
      m = m + 1
      Particles % Dt(n_part+l) = Buf(m)
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Velocity(n_part+l,k)=Buf(m)
        END DO
      END DO
    END IF
    DEALLOCATE(Buf)
    Particles % NumberOfParticles = Particles % NumberOfParticles+n
  END DO
  
  DEALLOCATE(Perm)
  DO i=1,NoPartitions
    IF ( Info(i) % n==0 ) CYCLE
    DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
  END DO
  DEALLOCATE(Info, Recv_Parts, Neigh, Requests)

END SUBROUTINE ExchangeNeighbourParticles
!------------------------------------------------------------





!------------------------------------------------------------
! For the first call of given node do the list, thereafter 
! Return the index until the list is finished
!------------------------------------------------------------
FUNCTION GetNextNeighbour( Particles, No ) RESULT ( No2 )
   IMPLICIT NONE

  TYPE(Particle_t) :: Particles
  INTEGER :: No, No2

  INTEGER :: PrevNo = 0
  INTEGER, POINTER :: NodeIndexes(:), NeighbourList(:) => NULL(), TmpList(:) => NULL()
  INTEGER :: i,j,k,n,ListSize,NoNeighbours,ElementIndex,Cnt
  LOGICAL :: Visited = .FALSE.
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER :: Element
  
  SAVE Visited,PrevNo,NeighbourList,ListSize,NoNeighbours,Cnt

  IF( PrevNo /= No ) THEN
    PrevNo = No
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes 
      ListSize = n * Particles % MaxClosestParticles + 10
      ALLOCATE( NeighbourList( ListSize ) )
      NeighbourList = 0 
      Mesh => GetMesh()
    END IF

    Mesh => GetMesh()
    ElementIndex = Particles % ElementIndex(No)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    NodeIndexes => Element % NodeIndexes

    NoNeighbours = 0
    DO i=1,n
      j = NodeIndexes(i)

      DO k=Particles % CumClosestParticle(j),Particles % CumClosestParticle(j+1)-1 
        No2 = Particles % ClosestParticle(k)

        ! No self coupling in this list	
        IF( No2 == No ) CYCLE

        ! Set symmetric forces Fij=-Fij so no need to go through twice
        IF ( No2 < No ) CYCLE

        NoNeighbours = NoNeighbours + 1

        IF( NoNeighbours > ListSize ) THEN
          ALLOCATE( TmpList( ListSize + 20 ) )
          TmpList(1:ListSize) = NeighbourList
          DEALLOCATE( NeighbourList ) 
          NeighbourList => TmpList
          ListSize = ListSize + 20
          NULLIFY( TmpList ) 
          WRITE(Message,'(A,I6)') 'Allocating more space:',ListSize
          CALL Info('GetNextNeighbour',Message)
        END IF

        NeighbourList(NoNeighbours) = No2
      END DO
    END DO
    Cnt = 0
  END IF 

  Cnt = Cnt + 1
  IF( Cnt > NoNeighbours ) THEN
    No2 = 0
  ELSE
    No2 = NeighbourList( Cnt ) 
  END IF

END FUNCTION GetNextNeighbour



!---------------------------------------------------------
! Initialize the time for next time integration step
!---------------------------------------------------------
SUBROUTINE ParticleInitializeTime( Particles, No )
  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: No

  IF( PRESENT( No ) ) THEN
    Particles % Force( No, : ) = 0.0_dp
  ELSE
    Particles % Force = 0.0_dp
  END IF

END SUBROUTINE ParticleInitializeTime


!---------------------------------------------------------
! Take a time step
!---------------------------------------------------------
SUBROUTINE ParticleAdvanceTime( Particles, dtime, ind )
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: dtime
  INTEGER, OPTIONAL :: ind

  REAL(KIND=dp) :: Drag, Mass, ds, dCoord(3)
  INTEGER :: dim
  INTEGER :: Status, TimeOrder, No
  TYPE(ValueList_t), POINTER :: Params
  INTEGER :: NoStart, NoFin
  LOGICAL :: Found, Visited = .FALSE.
  
  SAVE TimeOrder, dim, Mass, Drag, Visited


  IF(.NOT. Visited ) THEN
    Params => GetSolverParams()
    TimeOrder = Particles % TimeOrder
    dim = Particles % dim

    IF( TimeOrder == 2 ) THEN
      Mass = ListGetConstReal( Params,'Particle Mass',Found)
      IF(.NOT. Found) CALL Fatal('ParticleAdvanceTime',&
          '> Particle Mass < should be given!')
    ELSE 
      Drag = ListGetConstReal( Params,'Particle Drag Coefficient',Found)
      IF(.NOT. Found) CALL Fatal('ParticleAdvanceTime',&
          '> Particle Drag Coefficient < should be given!')
    END IF
    
    dCoord = 0.0_dp
    Visited = .TRUE.
  END IF

  IF( PRESENT( ind ) ) THEN
    NoStart = ind
    NoFin = ind
  ELSE
    NoStart = 1
    NoFin = Particles % NumberOfParticles
  END IF


  DO No=NoStart,NoFin
    Status = Particles % Status(No)

    IF ( Status >= PARTICLE_LOST ) CYCLE
    IF ( Status <= PARTICLE_INITIATED ) CYCLE
   
   IF( ANY( ISNAN( Particles % Force(No,:) ) ) ) THEN
      PRINT *,'dCoord',dCoord(1:dim),dtime
      PRINT *,'velo',Particles % Velocity(No,:)
      PRINT *,'coord',Particles % Coordinate(No,:)
      PRINT *,'force',Particles % Force(No,:)
    END IF

    IF ( Status == PARTICLE_FIXEDCOORD ) THEN
      Particles % Velocity(No,:) = 0.0_dp
    ELSE IF( Status == PARTICLE_FIXEDVELO ) THEN
      CONTINUE
    ELSE IF( TimeOrder == 2 ) THEN
      Particles % Velocity(No,:) = Particles % Velocity(No,:) + &
          dtime * Particles % Force(No,:) / Mass
    ELSE
      Particles % Velocity(No,:) = Particles % Force(No,:) / Drag      
    END IF

    dCoord(1:dim) = dtime * Particles % Velocity(No,:)
    Particles % Coordinate(No,:) = Particles % Coordinate(No,:) + &
        dCoord(1:dim)

    ds = SQRT( SUM( (dCoord(1:dim))**2 ) )
    Particles % Distance(No) = Particles % Distance(No) + ds    
    
    Particles % Force(No,:)= 0.0_dp
    Particles % Status(No) = PARTICLE_READY
  END DO
END SUBROUTINE ParticleAdvanceTime


!---------------------------------------------------------------    
! Checks the boundaries for rectangular and hexahedral shapes and 
! enforces periodic BCs. Currently the only supported way
! for setting periodic BCs.
!---------------------------------------------------------------    
SUBROUTINE ParticleBoxPeriodic( Particles, ind )
  
  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: ind

  TYPE(Solver_t), POINTER :: Solver
  REAL(KIND=dp) :: Coord, Rad
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Params
  REAL(KIND=dP) :: MinCoord(3), MaxCoord(3)
  INTEGER :: i,j,k,dim, ierr, PeriodicDir(3),NoPeriodic
  LOGICAL :: Mapped,Reflect,Found,Visited = .FALSE.
  INTEGER :: Operations, No, NoStart, NoFin, Status
  INTEGER, POINTER :: TmpInteger(:)
  
  SAVE Visited, Reflect, PeriodicDir, NoPeriodic, MinCoord, MaxCoord, dim
  
  IF( .NOT. Visited ) THEN
    Visited = .TRUE.
    Mesh => GetMesh()
    Params => GetSolverParams()
    dim = Mesh % Meshdim
    
    NoPeriodic = 0
    PeriodicDir = 0

    TmpInteger => ListGetIntegerArray( &
        Params,'Box Periodic Directions',Found )     
    IF( Found ) THEN
      NoPeriodic = SIZE( TmpInteger )
      DO i=1,NoPeriodic
        PeriodicDir(i) = TmpInteger(i)
      END DO
    ELSE IF( ListGetLogical( Params,'Box Particle Periodic',Found)) THEN
      NoPeriodic = dim
      DO i=1,dim
        PeriodicDir(i) = i
      END DO
    END IF

    MinCoord = Particles % GlobalMinCoord
    MaxCoord = Particles % GlobalMaxCoord
  END IF

  IF( NoPeriodic == 0 ) RETURN

  IF( PRESENT( ind ) ) THEN
    NoStart = ind
    Nofin = ind
  ELSE
    NoStart = 1
    NoFin = Particles % NumberOfParticles
  END IF


  DO No = NoStart, NoFin
    Status = Particles % Status(No) 
    IF( Status >= PARTICLE_LOST ) CYCLE
    IF( Status < PARTICLE_INITIATED ) CYCLE

    ! Boundary conditions for periodic BCs
    !------------------------------------------
    DO i=1,NoPeriodic
      Mapped = .FALSE.
      DO j=1,NoPeriodic
        k = PeriodicDir(j)
        coord = Particles % Coordinate(No,k)
        IF( coord < MinCoord(k) ) THEN
          coord = MaxCoord(k) - MinCoord(k) + coord
          Particles % Coordinate(No,k) = coord
          Mapped = .TRUE.
        ELSE IF ( coord > MaxCoord(k) ) THEN
          Coord = MinCoord(k) - MaxCoord(k) + Coord
          Particles % Coordinate(No,k) = coord           
          Mapped = .TRUE.
        END IF
      END DO
      IF(.NOT. Mapped ) EXIT
    END DO
  END DO
  
END SUBROUTINE ParticleBoxPeriodic


!---------------------------------------------------------------    
! Checks the boundaries for rectangular and hexahedral shapes and 
! enforces elastic reflection. This is alternative and 
! computationally more economic way and is ideal for testing
! purposes, at least.
!---------------------------------------------------------------    
SUBROUTINE ParticleBoxContact(Particles, ind)
  
  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: ind

  TYPE(Solver_t), POINTER :: Solver
  REAL(KIND=dp) :: Coord, Velo, Rad, Spring
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Params
  REAL(KIND=dP) :: MinCoord(3), MaxCoord(3), eta
  INTEGER :: i,j,k,dim, ierr,ContactDir(3)
  LOGICAL :: Mapped,Found,CollisionBC,ContactBC,Visited = .FALSE.
  INTEGER :: No, NoStart, NoFin, Status, NoContact
  INTEGER, POINTER :: TmpInteger(:)
  
  SAVE Visited, NoContact, ContactDir, MinCoord, MaxCoord, dim, &
      CollisionBC, ContactBC, Spring
  
  IF( .NOT. Visited ) THEN
    Visited = .TRUE.
    Mesh => GetMesh()
    Params => GetSolverParams()
    dim = Mesh % Meshdim
    
    NoContact = 0
    ContactDir = 0
     
    ContactBC = ListGetLogical(Params,'Box Particle Contact',Found)
    CollisionBC = ListGetLogical( Params,'Box Particle Collision',Found)
    
    IF( ContactBC .OR. CollisionBC ) THEN
      TmpInteger => ListGetIntegerArray( &
          Params,'Box Contact Directions',Found )     
      IF( Found ) THEN
        NoContact = SIZE( TmpInteger )
        DO i=1,NoContact
          ContactDir(i) = TmpInteger(i)
        END DO
      ELSE
        DO i=1,dim
          ContactDir(i) = i
        END DO
        NoContact = dim
      END IF
    ELSE
      NoContact = 0
    END IF
    IF( NoContact == 0 ) RETURN
    
    MinCoord = Particles % GlobalMinCoord
    MaxCoord = Particles % GlobalMaxCoord

    ! Particles of finite size collide before their center 
    ! hits the wall.
    Rad = GetCReal( Params,'Wall Particle Radius',Found)    
    IF( Found ) THEN
      MaxCoord = MaxCoord - Rad
      MinCoord = MinCoord + Rad
    END IF
    
    IF( ContactBC ) THEN
      Spring = GetCReal(Params,'Wall Particle Spring',Found)
      IF(.NOT. Found) CALL Fatal('ParticleBoxContact',&
          '> Wall Particle Spring < needed!')
    END IF

  END IF
  
  IF( NoContact == 0) RETURN

  IF( PRESENT( ind ) ) THEN
    NoStart = ind
    Nofin = ind
  ELSE
    NoStart = 1
    NoFin = Particles % NumberOfParticles
  END IF
  
  DO No = NoStart, NoFin
    Status = Particles % Status(No) 
    IF( Status >= PARTICLE_LOST ) CYCLE
    IF( Status < PARTICLE_INITIATED ) CYCLE
    
    ! Boundary conditions for reflection. 
    ! Multiple reflections may be carried out.
    !------------------------------------------
    DO i=1,NoContact

      IF( CollisionBC ) THEN        
        Mapped = .FALSE.
        DO j=1,NoContact
          k = ContactDir(j)
          Coord = Particles % Coordinate(No,k)
          
          IF( Coord < MinCoord(k) ) THEN
            Coord = 2 * MinCoord(k) - Coord
            Particles % Coordinate(No,k) = Coord
            Particles % Velocity(No,k) = -Particles % Velocity(No,k)
            Mapped = .TRUE.
          ELSE IF ( Coord > MaxCoord(k) ) THEN
            Coord = 2 * MaxCoord(k) - Coord
            Particles % Coordinate(No,k) = Coord          
            Particles % Velocity(No,k) = -Particles % Velocity(No,k)
            Mapped = .TRUE.
          END IF
        END DO
        IF(.NOT. Mapped ) EXIT
      ELSE        
        k = ContactDir(i)
        Coord = Particles % Coordinate(No,k)
        
        IF( MinCoord(k) - Coord > 0.0_dp ) THEN
          eta = MinCoord(k) - Coord          
          Particles % Force(No,k) = Particles % Force(No,k) + eta * Spring
        ELSE IF( Coord - MaxCoord(k) > 0.0_dp ) THEN
          eta = Coord - MaxCoord(k) 
          Particles % Force(No,k) = Particles % Force(No,k) - eta * Spring
        END IF
      END IF
    END DO
  
  END DO

END SUBROUTINE ParticleBoxContact



!---------------------------------------------------------------    
! Subroutine for getting particle-particle interaction 
! The subroutine may return the new positions and new 
! coordinates, or alternatively the initial coordinates are tampered 
! so that with standard time-integration the final position will
! be the same.
!---------------------------------------------------------------    
FUNCTION ParticleParticleCollision(dt,Coord,Coord2,Velo,Velo2,&
    Force,Force2) RESULT ( Collision ) 
  
  REAL(KIND=dp):: dt,Coord(3),Coord2(3),Velo(3),Velo2(3),Force(3),Force2(3)
  LOGICAL :: Collision 
  
  REAL(KIND=dp)::  v1na,v2na,v1nb,v2nb
  REAL(KIND=dp) :: dist,maxdist=0.0_dp
  REAL(KIND=dp) :: Rad1, Rad2, Mass1, Mass2, Coeff 
  REAL(KIND=dp) :: a,b,c,d,dr(3),dv(3),dra(3),rn(3),dta,dtb
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: Found, TrueCollision,SimilarParticles,Debug 
  LOGICAL :: Visited=.FALSE.
  
  SAVE Visited, maxdist, SimilarParticles, Rad1, Rad2, Mass1, Mass2, Coeff, &
      TrueCollision
  
  IF(.NOT. Visited ) THEN
    Params => GetSolverParams()
    Rad1 = GetCReal(Params,'Particle Radius',Found)
    IF(.NOT. Found) THEN
      CALL Fatal('ParticleParticleCollision','> Particle Radius < needed!')
    END IF
    Coeff = GetCReal(Params,'Particle Bounciness',Found)
    IF(.NOT. Found ) Coeff = 1.0_dp
    Mass1 = GetCReal(Params,'Particle Mass',Found)  
    Mass2 = Mass1 
    IF(.NOT. Found) THEN
      CALL Fatal('ParticleParticleCollision','> Particle Mass < needed!')
    END IF
    TrueCollision = GetLogical( Params,'True Collision Mode')
    SimilarParticles = .TRUE.
    Visited = .TRUE.
  END IF
  
  Collision = .FALSE.
  Debug = .FALSE.
  
  ! relative displacement and velocity    
  dr = Coord - Coord2
  dv = Velo - Velo2
  
  ! the collision time is found from the conditins |r1(t)-r2(t)|=R1+R2
  ! which results to 2nd order equation for the timestep, here a,b,c
  ! are the coefficicient in the equation. 
  b = SUM( dr * dv )
  
  ! The distance is only growing, there was a collision in history only
  IF( b >= 0.0_dp ) RETURN
  
  a = SUM( dv * dv ) 
  IF( SimilarParticles ) THEN
    c = SUM( dr * dr ) - 4*Rad1**2       
  ELSE
    c = SUM( dr * dr ) - ( Rad1 + Rad2 )**2
  END IF
  d = b*b - a*c
  
  ! negative discriminant means no solution
  IF( d < 0.0_dp ) RETURN
  
  ! time for first collision
  dta = (-b-SQRT(d))/a
  
  ! if time larger than given timestep
  IF( dta >= dt ) RETURN
  
  ! time remaining after the collision
  dtb = dt - dta
  
  ! vector at collision 
  dra = dr + dta * dv
  
  ! normal components at collision 
  rn = dra / SQRT( SUM( dra*dra ) )
  v1na = SUM( Velo * rn )
  v2na = SUM( Velo2 * rn ) 
  
  IF( SimilarParticles ) THEN
    v1nb = ( Coeff * (v2na - v1na) + v1na + v2na ) / 2
    v2nb = ( Coeff * (v1na - v2na) + v2na + v1na ) / 2
  ELSE
    v1nb = ( Coeff * Mass2 * (v2na - v1na) + Mass1 * v1na + Mass2 * v2na ) / ( Mass1 + Mass2 )
    v2nb = ( Coeff * Mass1 * (v1na - v2na) + Mass2 * v2na + Mass1 * v1na ) / ( Mass1 + Mass2 )
  END IF
  
  ! Set either force or velocity directly 
  ! only the normal component of velocity/force is affected by collisions    
  !----------------------------------------------------------------------
  IF( TrueCollision ) THEN
    ! compute the path until the collision
    Coord = Coord + dta * rn * Velo
    Coord2 = Coord2 + dta * rn * Velo2
    
    Velo = Velo + (v1nb-v1na) * rn
    Velo2 = Velo2 + (v2nb-v2na) * rn
    
    ! compute the path after the collision
    Coord = Coord + dtb * Velo
    Coord2 = Coord2 + dtb * Velo2
  ELSE
    Coord = Coord + (v1na-v1nb) * rn * dta
    Coord2 = Coord2 + (v2na-v2nb) * rn * dta
    
    Force = Mass1 * (v1nb-v1na) * rn / dt
    Force2 = Mass2 * (v2nb-v2na) * rn / dt
  END IF
  
  Collision = .TRUE.
  
END FUNCTION ParticleParticleCollision
  


!---------------------------------------------------------------    
! Checks the boundaries for general limits. 
! The radius is still assumed to be constant.
!---------------------------------------------------------------    
SUBROUTINE ParticleWallContact(Particles, dt, No ) 

  IMPLICIT NONE
  
  TYPE(Particle_t) :: Particles
  INTEGER :: No
  REAL(KIND=dp) :: dt

  LOGICAL :: Hit
  REAL(KIND=dp) :: Coord(3), Velo(3), WallVelo(3), Rad, Dist, Mass, Normal(3), Force(3), &
      Coeff, Spring
  REAL(KIND=dp), POINTER :: NodalVelo(:,:)
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Params, BC
  INTEGER :: i,j,k,n,dim, ierr, imax
  LOGICAL :: Collision,ContactAny,Contact,Found,WallVeloAny,CollisionAny,Visited = .FALSE., &
      TrueCollision, Debug
  INTEGER :: NoParticles, Status, ElementIndex
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: BulkElement, BoundaryElement
  TYPE(Nodes_t) :: ElementNodes, BoundaryNodes
  REAL(KIND=dp) :: vn, dta, dtb, rn(3), v1na, v1nb, v2na, eta


  SAVE Visited, dim, Rad, Mass, Mesh, WallVeloAny, CollisionAny,ContactAny, BoundaryNodes, &
      TrueCollision, WallVelo, Coeff, Velo, NodalVelo, Coord, Spring
 
  IF( .NOT. Visited ) THEN
    Mesh => GetMesh()
    Params => GetSolverParams()
    dim = Mesh % Meshdim
    n = Mesh % MaxElementNodes

    ALLOCATE( NodalVelo(3,n) )

    ! Currently, one may need a different radius if the mesh leaks i.e. is 
    ! include triangles or tetrahedrans with nodes, but no faces on the surface
    !---------------------------------------------------------------    
    Rad = GetCReal( Params,'Wall Particle Radius',Found)
    IF(.NOT. Found) Rad = GetCReal( Params,'Particle Radius',Found)
    IF(.NOT. Found) THEN
      CALL Fatal('ParticleWallContact','> Particle Radius < needed!')
    END IF

    
    WallVeloAny = .FALSE.
    CollisionAny = .FALSE. 
    ContactAny = .FALSE.

    DO k=1,CurrentModel % NumberOfBCs
      BC => CurrentModel % BCs(k) % Values
      Collision = GetLogical( BC,'Wall Particle Collision',Found) 
      Contact = GetLogical( BC,'Wall Particle Contact',Found) 

      IF( Contact ) THEN
        ContactAny = .TRUE.
      ELSE IF( Collision ) THEN
        CollisionAny = .TRUE.
        WallVeloAny = WallVeloAny .AND. &
            ListCheckPresent( BC,'Wall Velocity 1') .OR. &
            ListCheckPresent( BC,'Wall Velocity 2') .OR. &
            ListCheckPresent( BC,'Wall Velocity 3')
      END IF
    END DO

    IF( ContactAny ) THEN
      Spring = GetCReal( Params,'Wall Particle Spring',Found)      
      IF(.NOT. Found) THEN
        CALL Fatal('ParticleWallContact','> Wall Particle Spring < needed!')
      END IF
    END IF

    IF( CollisionAny ) THEN
      Mass = GetCReal( Params,'Particle Mass',Found)
      IF(.NOT. Found) THEN
        CALL Fatal('ParticleWallContact','> Particle Mass < needed!')
      END IF
      
      Coeff = GetCReal( Params,'Wall Particle Bounciness', Found ) 
      IF(.NOT. Found) Coeff = 1.0_dp       
      
      TrueCollision = GetLogical( Params,'True Collision Mode',Found)      
    END IF

    PRINT *,'Flags:',ContactAny,CollisionAny,WallVeloAny
    
    WallVelo = 0.0_dp
    Velo = 0.0_dp
    Coord = 0.0_dp

    Visited = .TRUE.
  END IF

  IF(.NOT. (CollisionAny .OR. ContactAny) ) RETURN

  Hit = .FALSE.
  Status = Particles % Status(No) 
  IF( Status >= PARTICLE_LOST ) RETURN
  IF( Status < PARTICLE_INITIATED ) RETURN
  
  ElementIndex = Particles % ElementIndex( No ) 
  IF( ElementIndex == 0 ) RETURN
  
  IF( Particles % InternalElements(  ElementIndex ) ) RETURN



  BulkElement => Mesh % Elements( ElementIndex )
  
  IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
    imax =  BulkElement % TYPE % NumberOfFaces 
  ELSE
    imax = BulkElement % TYPE % NumberOfEdges  
  END IF
  
  DO i=1, imax
    IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
    ELSE
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges(j)
    END IF
    
    Found = .FALSE.
    DO k=1,CurrentModel % NumberOfBCs
      IF(.NOT. ASSOCIATED( BoundaryElement % BoundaryInfo ) ) CYCLE
      IF ( BoundaryElement % BoundaryInfo % Constraint == &
          CurrentModel % BCs(k) % Tag ) THEN
        Found = .TRUE.
        EXIT
      END IF
    END DO
    IF( .NOT. Found ) CYCLE

    BC => CurrentModel % BCs(k) % Values
    Collision = GetLogical( BC,'Wall Particle Collision',Found)      
    Contact = GetLogical( BC,'Wall Particle Contact',Found)      
    IF(.NOT. (Collision .OR. Contact) ) CYCLE
    
    Coord(1:dim) = Particles % Coordinate(No,1:dim)
    CALL GetElementNodes(BoundaryNodes,BoundaryElement)
    Dist = PointFaceDistance(BoundaryElement,BoundaryNodes,Coord,Normal)
    
    Debug = .FALSE.
    

    IF( Contact ) THEN

      eta = Dist - Rad
      IF( eta > 0.0 ) CYCLE

      Force = eta * Spring * Normal 

!      PRINT *,'Force:',Coord(1:dim),eta,Dist,Rad
!      PRINT *,'Normal',Normal,Force

      Particles % Force(No,1:dim) = Particles % Force(No,1:dim) + Force(1:dim)         

    ELSE
      ! Note this should rather be really computed at the true point of contact!
      IF( WallVeloAny ) THEN
        NodeIndexes => BoundaryElement % NodeIndexes
        n = BoundaryElement % TYPE % NumberOfNodes          
        NodalVelo(1,1:n) = ListGetReal( BC,'Wall Velocity 1',n, NodeIndexes, Found )
        NodalVelo(2,1:n) = ListGetReal( BC,'Wall Velocity 2',n, NodeIndexes, Found )
        IF( dim == 3 ) THEN
          NodalVelo(3,1:n) = ListGetReal( BC,'Wall Velocity 3',n, NodeIndexes, Found )
        END IF
        DO j=1,dim
          WallVelo(j) = SUM( NodalVelo(j,1:n) ) / n
        END DO
      END IF
      
      Velo(1:dim) = Particles % Velocity(No,1:dim)
      vn = SUM( Normal(1:dim) * ( Velo(1:dim) - WallVelo(1:dim) ) )
      
      dta = ( Dist - Rad ) / vn
      
      IF( dta >= dt ) CYCLE        
      
      ! A historical collision but the distance is growing
      IF( dta < 0.0 .AND. Dist - Rad > 0.0 ) CYCLE
      
      
      IF( dta < 0.0 ) THEN
        PRINT *,'Coord:',Coord(1:dim)
        PRINT *,'Velo:',Velo(1:dim)
        PRINT *,'Dist',Dist,Rad
        PRINT *,'vn',vn,dta,dt
      END IF
      
      
      ! these are defined as is so that we could reuse the binary particle collision stuff
      ! at the limit Mass2 -> infinity
      dtb = dt - dta
      rn = -Normal
      v1na = SUM( Velo(1:dim) * rn(1:dim) )
      v2na = SUM( WallVelo(1:dim) * rn(1:dim) ) 
      
      v1nb = Coeff * (v2na - v1na) + v2na 
      
      ! Set either force or velocity directly 
      ! only the normal component of velocity/force is affected by collisions    
      IF( TrueCollision ) THEN
        ! compute the path until the collision
        Coord = Coord + dta * Velo
        Velo = Velo + (v1nb-v1na) * rn
        ! compute the path after the collision
        Coord = Coord + dtb * Velo
      ELSE
        Coord = Coord + (v1na-v1nb) * rn * dta
        Force = Mass * (v1nb-v1na) * rn / dt
      END IF
      
      IF( dta < 0.0 ) THEN
        PRINT *,'dtb',dtb
        PRINT *,'rn',rn
        PRINT *,'na',v1na,v2na,v1nb
        PRINT *,'Coord2',Coord
        PRINT *,'Force2',Force
      END IF
      
      IF( TrueCollision ) THEN
        Particles % Coordinate(No,1:dim) = Coord(1:dim)
        Particles % Velocity(No,1:dim) = Velo(1:dim)
      ELSE
        Particles % Coordinate(No,1:dim) = Coord(1:dim)
        Particles % Force(No,1:dim) = Particles % Force(No,1:dim) + Force(1:dim)         
      END IF

      ! Only one collision for each particle & element
      EXIT
    END IF

  END DO

END SUBROUTINE ParticleWallContact





 !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutput( Particles ) 
    
    TYPE(Particle_t) :: Particles
    LOGICAL :: Visited = .FALSE.
    TYPE(ValueList_t), POINTER :: Params     
    CHARACTER(LEN=MAX_NAME_LEN) :: FileFormat
    LOGICAL :: VtuFormat, TableFormat, Found

    SAVE :: TableFormat, VtuFormat, Visited
    
    IF( .NOT. Visited ) THEN
      Params => GetSolverParams()
      TableFormat = GetLogical( Params,'Table Format',Found)
      VtuFormat = GetLogical( Params,'Vtu Format',Found)
      FileFormat = GetString( Params,'Output Format',Found) 
      IF( Found ) THEN
        IF( FileFormat == 'vtu') VtuFormat = .TRUE.
        IF( FileFormat == 'table') TableFormat = .TRUE.
      END IF
      
      IF(.NOT. ListCheckPresent( Params,'Filename Prefix') ) THEN
        CALL ListAddString( Params,'Filename Prefix','particles')
      END IF
      Visited = .TRUE.
    END IF


    IF( TableFormat ) CALL ParticleOutputTable( Particles )
    IF( VtuFormat ) CALL ParticleOutputVtu( Particles ) 

  END SUBROUTINE ParticleOutput


  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutputTable( Particles ) 
    
    TYPE(Particle_t) :: Particles

    TYPE(Variable_t), POINTER :: TimeVar
    TYPE(ValueList_t), POINTER :: Params 
    CHARACTER(LEN=MAX_NAME_LEN) :: FilePrefix, FileName
    LOGICAL :: Found, NumberFilesByParticles, NumberFilesBySteps
    REAL(KIND=dp), POINTER :: Coord(:,:), Velo(:,:), Dist(:)
    REAL(KIND=dp) :: time
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,dim, NoParticles, MinSaveStatus, MaxSaveStatus
    INTEGER :: VisitedTimes = 0

    SAVE :: VisitedTimes, Params, FilePrefix, NumberFilesByParticles, NumberFilesBySteps, &
        MinSaveStatus, MaxSaveStatus, TimeVar

    VisitedTimes = VisitedTimes + 1

    Mesh => GetMesh()
    dim = Particles % dim

    Coord => Particles % Coordinate
    Velo => Particles % Velocity 
    Dist => Particles % Distance
    Status => Particles % Status

    IF( VisitedTimes == 1 ) THEN
      Params => GetSolverParams()
      FilePrefix = ListGetString(Params,'Filename Prefix')
      CALL WriteParticleFileNames(FilePrefix, dim)

      NumberFilesByParticles = ListGetLogical( Params,'Filename Particle Numbering',Found) 
      NumberFilesBySteps = ListGetLogical( Params,'Filename Timestep Numbering',Found) 
      IF( NumberFilesByParticles .AND. NumberFilesBySteps ) THEN
        CALL Fatal('ParticleTracker','Files may be numbered either by steps or particles')
      END IF
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      IF(.NOT. Found ) MinSaveStatus = PARTICLE_INITIATED

      MaxSaveStatus = ListGetInteger( Params,'Max Status for Saving',Found)
      IF(.NOT. Found ) MaxSaveStatus = PARTICLE_LOST-1

      TimeVar => VariableGet( Mesh % Variables,'time')
    END IF

    time = TimeVar % Values(1)
    NoParticles = Particles % NumberOfParticles

    IF(.NOT. NumberFilesByParticles ) THEN
      IF( NumberFilesBySteps ) THEN
        CALL OpenParticleFile(FilePrefix, VisitedTimes )
      ELSE
        CALL OpenParticleFile(FilePrefix, 0 )        
      END IF
      DO i = 1, NoParticles
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i )        
      END DO
      CALL CloseParticleFile()
    ELSE
      DO i = 1, NoParticles
        CALL OpenParticleFile(FilePrefix, i)
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i ) 
        CALL CloseParticleFile()
      END DO
    END IF


  CONTAINS

    !------------------------------------------------------------------------
    ! Write the names file for user information. Remember to update this if 
    ! SaveParticleStep is modified.
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleFileNames( Prefix, Dim ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: dim

      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      INTEGER :: i,j
      
      WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat.names'
      
      OPEN (10, FILE=FileName )
      
      WRITE( 10, '(A)' ) 'Variables in file: '//TRIM(FilePrefix)//'*.dat'
      WRITE( 10, '(A,I2)' ) 'Dimension of particle set is',dim
      i = 1
      WRITE( 10, '(I2,A)' )  i,': time'
      WRITE( 10, '(I2,A)' )  i+1,': Coordinate_1'
      WRITE( 10, '(I2,A)' )  i+2,': Coordinate_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Coordinate_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Velocity_1'
      WRITE( 10, '(I2,A)' )  i+2,': Velocity_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Velocity_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Distance'
      i = i + 1
      
      CLOSE( 10 )
      
    END SUBROUTINE WriteParticleFileNames



    !------------------------------------------------------------------------
    ! Open a numbered file for each particle. These must be separate since the 
    ! number of steps for each particle may vary greatly
    !-------------------------------------------------------------------------
    SUBROUTINE OpenParticleFile( Prefix, FileNo ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: FileNo
      LOGICAL, SAVE :: Visited = .FALSE.


      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      
      IF( FileNo == 0 ) THEN
        WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat'
        IF( .NOT. Visited ) THEN
          CALL Info( 'ParticleTracker', 'Saving particle paths to file: '//TRIM(FileName), Level=4 )
        END IF
      ELSE
        IF ( FileNo==1 .AND.  .NOT. Visited ) THEN
          WRITE( Message, * ) 'Saving particle paths to files: ', TRIM(FilePrefix)//'_*.dat'
          CALL Info( 'ParticleTracker', Message, Level=4 )
        END IF
        FileName=TRIM(FilePrefix)//'_'//TRIM(i2s(fileno))//'.dat'
      END IF
      IF ( ParEnv % Pes>1 ) FileName=TRIM(FileName)//TRIM(i2s(ParEnv % myPE))

      
      IF( VisitedTimes == 1 .OR. NumberFilesBySteps ) THEN
        OPEN (10, FILE=FileName )
        WRITE( 10, '()', ADVANCE='no' ) ! delete old contents
      ELSE
        OPEN (10, FILE=FileName,POSITION='APPEND' )
      END IF

      Visited = .TRUE.

    END SUBROUTINE OpenParticleFile
    
    
    !------------------------------------------------------------------------
    ! Save one line in the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleLine( Dim, No )
      INTEGER :: Dim, No
      
      IF( NumberFilesBySteps ) THEN
        WRITE( 10, * ) time, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      ELSE IF( NumberFilesByParticles ) THEN
        WRITE( 10, * ) time, VisitedTimes, Coord(No,1:Dim), Velo(No,1:dim), Dist(No) 
      ELSE       
        WRITE( 10, * ) time, VisitedTimes, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      END IF

    END SUBROUTINE WriteParticleLine
    
    
    !------------------------------------------------------------------------
    ! Close the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE CloseParticleFile( )
      
      CLOSE( 10 )
      
    END SUBROUTINE CloseParticleFile
           
  END SUBROUTINE ParticleOutputTable




  SUBROUTINE ParticleToFieldSolver( Solver,WeightVector,ForceVector)
    
    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp), POINTER :: WeightVector(:),ForceVector(:)
    
    REAL(KIND=dp) :: Norm


    CALL DefaultInitialize()  
    CALL BulkAssembly()
    CALL DefaultFinishAssembly()
    CALL DefaultDirichletBCs()
    Norm = DefaultSolve()
    
    
  CONTAINS 
    
    !------------------------------------------------------------------------
    ! Assemblies by Galerkin method the problem where a continuous field is 
    ! fitted to the data by discrete particles. The particles have a contribution
    ! on the r.h.s. There are two different methods
    ! 1) without normalization it is assumed that the r.h.s is already physically
    !    relevant sum of the data.
    ! 2) with normalization it is assumed that the r.h.s. scales with the weight
    !    and division by weight is needed to obtain a statistical average.
    ! In both cases regularization by a diffusion coefficient may be used but 
    ! it is essenitial only in the latter.
    !-------------------------------------------------------------------------
    SUBROUTINE BulkAssembly()
      
      INTEGER, POINTER :: BoundaryPerm(:), Indexes(:)
      INTEGER :: i,j,k,t,n,istat,active,BoundaryNodes
      TYPE(Element_t), POINTER :: Element
      TYPE(GaussIntegrationPoints_t) :: IP
      CHARACTER(LEN=MAX_NAME_LEN) :: BoundaryName
      TYPE(Nodes_t) :: Nodes
      REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:)
      REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:)
      REAL(KIND=dp) :: Coeff, detJ, RealWeightSum, IdealWeightSum, WeightCorr, val
      TYPE(Matrix_t), POINTER :: StiffMatrix 
      LOGICAL :: stat, Normalize, Visited = .FALSE.
      
      
      SAVE Visited, BoundaryPerm, Nodes, STIFF, FORCE, Basis, dBasisdx
      
      IF(.NOT. Visited ) THEN
        Visited = .TRUE.
        N = Solver % Mesh % MaxElementNodes 
        ALLOCATE( Basis(n), dBasisdx(n, 3), FORCE(N), STIFF(N,N), STAT=istat )
        
        N = Solver % Mesh % NumberOfNodes
        ALLOCATE( BoundaryPerm(n) )
        BoundaryPerm = 0
        BoundaryNodes = 0
        BoundaryName = 'Free Point Boundary'
        CALL MakePermUsingMask( CurrentModel,Solver,Solver % Mesh,BoundaryName, &
            .FALSE., BoundaryPerm, BoundaryNodes )
        PRINT *,'Number of nodes on free boundary:',BoundaryNodes
      END IF
      
      ! Assembly the diffusion part used for regularization
      !----------------------------------------------------------
      Coeff = GetCReal( Solver % Values,'Particle Property Diffusion Coefficient')
      active = GetNOFActive()
      StiffMatrix => Solver % Matrix

      Normalize = GetLogical( Solver % Values,'Particle Property Normalize')
      IdealWeightSum = 0.0_dp
      
      DO t=1,active
        Element => GetActiveElement(t)
        n = GetElementNOFNodes(Element)
        Indexes => Element % NodeIndexes
        
        CALL GetElementNodes( Nodes, Element )
        STIFF = 0.0d0
        FORCE = 0.0d0
        
        ! Numerical integration:
        !----------------------
        IP = GaussPoints( Element )
        DO k=1,IP % n
          ! Basis function values & derivatives at the integration point:
          !--------------------------------------------------------------
          stat = ElementInfo( Element, Nodes, IP % U(k), IP % V(k), &
              IP % W(k),  detJ, Basis, dBasisdx )
          
          ! Finally, the elemental matrix & vector:
          !----------------------------------------
          DO i=1,n
            val = IP % s(k) * DetJ * Basis(i) 
            IdealWeightSum = IdealWeightSum + val
            IF(.NOT. Normalize ) THEN
              STIFF(i,i) = STIFF(i,i) + val
            END IF
            
            ! This condition removes the natural boundary condition that would 
            ! try to fix the normal gradient of the field to zero.
            !--------------------------------------------------------------------
            IF( BoundaryPerm( Indexes(i) ) > 0 ) CYCLE
            DO j=1,n
              STIFF(i,j) = STIFF(i,j) + IP % s(k) * Coeff * DetJ * &
                  SUM( dBasisdx(i,:) * dBasisdx(j,:) ) 
            END DO
          END DO
        END DO
        
        CALL DefaultUpdateEquations( STIFF, FORCE )
      END DO

      IF( Normalize ) THEN
        ! Set the weight to the diagonal i.e. make the mass matrix contribution  
        ! The data is normalized so that if it would be constant it would yield the 
        ! same equation as the normal one and the weights would also be constant.
        ! This way diffusion will not depend on the amount of data, whether
        ! that is desirable, or not, I don't know. 
        !-----------------------------------------------------------------------
        RealWeightSum = SUM( WeightVector ) 
        WeightCorr = IdealWeightSum / RealWeightSum 
        StiffMatrix => Solver % Matrix
        DO i=1,SIZE( WeightVector ) 
          val = WeightCorr * WeightVector(i)  
          CALL AddToMatrixElement( StiffMatrix,i,i,val )
        END DO
        StiffMatrix % rhs = WeightCorr * ForceVector        
      ELSE
        StiffMatrix % rhs = ForceVector
      END IF

    END SUBROUTINE BulkAssembly

  END SUBROUTINE ParticleToFieldSolver




!------------------------------------------------------------------------------
  SUBROUTINE CreateParticleVariable( Particles, Name, DOFs, Category, Output ) 
!------------------------------------------------------------------------------
    TYPE(Particle_t) :: Particles
    CHARACTER(LEN=*) :: Name
    INTEGER, OPTIONAL :: DOFs
    INTEGER, OPTIONAL :: Category
    LOGICAL, OPTIONAL :: Output
!------------------------------------------------------------------------------
    TYPE(ParticleVariable_t), POINTER :: Variables
    REAL(KIND=dp), POINTER :: Values(:)
    LOGICAL :: stat
    TYPE(ParticleVariable_t), POINTER :: ptr,ptr1,ptr2
    INTEGER :: NoParticles
!------------------------------------------------------------------------------

    Variables => Particles % Variables
    IF ( .NOT.ASSOCIATED(Variables) ) THEN
      ALLOCATE(Variables)
      ptr => Variables
    ELSE
      ALLOCATE( ptr )
    END IF
    
    ! note: sets confusinly also ptr % name 
    ptr % NameLen = StringToLowerCase( ptr % Name,Name )
    
    ! get the next free handle?
    IF ( .NOT. ASSOCIATED(ptr, Variables) ) THEN
      ptr1 => Variables
      ptr2 => Variables
      DO WHILE( ASSOCIATED( ptr1 ) )
        IF ( ptr % Name == ptr1 % Name ) THEN
          DEALLOCATE( ptr )
          RETURN
        END IF
        ptr2 => ptr1
        ptr1 => ptr1 % Next
      END DO
      ptr2 % Next => ptr
    END IF
    ptr % Next => Null()
    
    ptr % Norm = 0.0d0
    ptr % PrevNorm = 0.0d0
    ptr % DOFs = 1
    ptr % Valid  = .TRUE.
    ptr % Output = .TRUE.
    ptr % ValuesChanged = .TRUE.
    
    IF( PRESENT( DOFs ) ) ptr % DOFs = DOFs
    IF ( PRESENT( Category ) ) ptr % Category = Category
    IF ( PRESENT( Output ) ) ptr % Output = Output
    
    NoParticles = Particles % MaxNumberOfParticles
    ALLOCATE( Values( NoParticles * ptr % Dofs ) )
    Values = 0.0_dp
    ptr % Values => Values

!------------------------------------------------------------------------------
  END SUBROUTINE CreateParticleVariable
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!  Given a variable name, get handle to it
!------------------------------------------------------------------------------
  FUNCTION GetParticleVariable( Particles, Name ) RESULT ( Var )
    
    TYPE(Particle_t) :: Particles
    CHARACTER(LEN=*) :: Name
    TYPE(ParticleVariable_t), POINTER :: Var
!------------------------------------------------------------------------------
    TYPE(ParticleVariable_t), POINTER :: Tmp
    CHARACTER(LEN=LEN_TRIM(Name)) :: str
    INTEGER :: k
      
!------------------------------------------------------------------------------
    k = StringToLowerCase( str,Name,.TRUE. )
    
    Tmp => Particles % Variables
    DO WHILE( ASSOCIATED(tmp) )
      IF ( Tmp % NameLen == k ) THEN
        IF ( Tmp % Name(1:k) == str(1:k) ) THEN
          
          IF ( Tmp % Valid ) THEN
            Var => Tmp
            RETURN
          END IF
          EXIT
          
        END IF
      END IF
      Tmp => Tmp % Next
    END DO
    Var => Tmp

  END FUNCTION GetParticleVariable



  SUBROUTINE ParticleOutputVtu( Particles )
!------------------------------------------------------------------------------

    USE DefUtils 
    USE MeshUtils
    USE ElementDescription
    
    IMPLICIT NONE
    TYPE(Particle_t) :: Particles  
    
    TYPE(ValueList_t),POINTER :: Params
    INTEGER, SAVE :: nTime = 0
    LOGICAL :: GotIt, Parallel, FixedMesh, DeleteBC
    CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
    CHARACTER(MAX_NAME_LEN) :: VtuFile, PvtuFile 
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Variable_t), POINTER :: Var
    INTEGER :: i, j, k, Partitions, Part, ExtCount, FileindexOffSet, &
        Status, MinSaveStatus, MaxSaveStatus
    CHARACTER(MAX_NAME_LEN) :: Dir
    REAL(KIND=dp) :: SaveNodeFraction
    LOGICAL :: Found,Visited = .FALSE.
    
    CHARACTER(MAX_NAME_LEN) :: Str
    INTEGER :: NumberOfNodes, ParallelNodes, Dim
    
    SAVE :: MinSaveStatus, MaxSaveStatus
    
    Params => GetSolverParams()
    Mesh => GetMesh()
    
    ExtCount = ListGetInteger( Params,'Output Count',GotIt)
    IF( GotIt ) THEN
      nTime = ExtCount
    ELSE
      nTime = nTime + 1
    END IF
    FileIndexOffset = ListGetInteger( Params,'Fileindex offset',GotIt)
    
    DeleteBC = ListGetLogical( Params,'Delete Wall Particles',GotIt)
    
    IF ( nTime == 1 ) THEN
      FilePrefix = GetString( Params,'Filename Prefix')
      CALL Info('ParticleOutputVtu','Saving results in VTK XML format to file:'//TRIM(FilePrefix))
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      IF(.NOT. Found ) MinSaveStatus = PARTICLE_INITIATED
      
      MaxSaveStatus = ListGetInteger( Params,'Max Status for Saving',Found)
      IF(.NOT. Found ) MaxSaveStatus = PARTICLE_LOST-1
      
    END IF
    
    Partitions = ParEnv % PEs
    Part = ParEnv % MyPE
    Parallel = (Partitions > 1) .OR. ListGetLogical(Params,'Enforce Parallel format',GotIt)
    
    Dim = Particles % dim
    
    CALL DeleteLostParticles(Particles,DeleteBC)
    
    
    NumberOfNodes = 0
    DO i=1,Particles % NumberOfParticles
      IF ( Particles % Status(i) > MaxSaveStatus .OR. &
          Particles % Status(i) < MinSaveStatus )  CYCLE
      NumberOfNodes = NumberOfNodes + 1
    END DO
    
    SaveNodeFraction = ListGetCReal( Params,'Particle Save Fraction',GotIt)
    IF(GotIt) NumberOfNodes = NINT( SaveNodeFraction * NumberOfNodes )
    
    IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
      Dir = TRIM(Mesh % Name) // "/"
    ELSE
      Dir = "./"
    END IF
    
    IF(Parallel .AND. Part == 0) THEN
      WRITE( PvtuFile,'(A,A,I4.4,".pvtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
      CALL WritePvtuFile( PvtuFile )
    END IF
    
    IF ( Parallel ) THEN
      WRITE( VtuFile,'(A,A,I4.4,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),Part+1,"par",nTime
    ELSE
      WRITE( VtuFile,'(A,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
    END IF
    CALL WriteVtuFile( VtuFile )
    

  CONTAINS

  
    SUBROUTINE WriteVtuFile( VtuFile )
      CHARACTER(LEN=*), INTENT(IN) :: VtuFile
      INTEGER, PARAMETER :: VtuUnit = 58
      TYPE(Variable_t), POINTER :: Var
      CHARACTER(LEN=512) :: str
      INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
      CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
      LOGICAL :: ScalarsExist, VectorsExist, Found
      INTEGER, POINTER :: Perm(:)
      REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
      REAL(KIND=dp) :: x,y,z
      
      
      OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
      
      WRITE( VtuUnit,'(A)') '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'
      WRITE( VtuUnit,'(A)') '  <UnstructuredGrid>'
      WRITE( VtuUnit,'(A,I0,A)') '    <Piece NumberOfPoints="',NumberOfNodes,&
          '" NumberOfCells="0">'
    
      ! nodewise information
      !-------------------------------------
      ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
      VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
      IF( ScalarsExist .AND. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)&
            //'" Vectors="'//TRIM(VectorFieldName)//'">'
      ELSE IF( ScalarsExist ) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)//'">'
      ELSE IF( VectorsExist ) THEN
        WRITE( VtuUnit,'(A)') '      <PointData Vectors="'//TRIM(VectorFieldName)//'">'
      END IF
      
      DO Rank = 0,1
        DO Vari = 1, 99
          IF( Vari < 10 ) THEN
            IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          ELSE
            IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          END IF
          
          FieldName = GetString( Params, TRIM(Txt), Found )
          IF(.NOT. Found) EXIT
        
          !---------------------------------------------------------------------
          ! Find the variable with the given name in the normal manner 
          !---------------------------------------------------------------------
          IF( FieldName == 'velocity' ) THEN
            VectorValues => Particles % Velocity
          ELSE IF( FieldName == 'force') THEN
            VectorValues => Particles % Force 
          ELSE IF( FieldName == 'distance') THEN
            ScalarValues => Particles % Distance
          ELSE IF( FieldName == 'dt') THEN
            ScalarValues => Particles % dt
          ELSE
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
          
          !---------------------------------------------------------------------
          ! Finally save the field values 
          !---------------------------------------------------------------------
          j = 0
          IF( Rank == 0) THEN
            WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="1" format="ascii">'    
            DO i = 1, Particles % NumberOfParticles
              
              IF ( Particles % Status(i) > MaxSaveStatus .OR. &
                  Particles % Status(i) < MinSaveStatus )  CYCLE
              j = j + 1
              IF(.TRUE.) THEN
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') ScalarValues(i)              
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
              END IF
              IF( j == NumberOfNodes ) EXIT            
            END DO
            WRITE( VtuUnit,'(A)') ' '
            WRITE( VtuUnit,'(A)') '        </DataArray>'
          ELSE
            sdofs = 3
            WRITE( VtuUnit,'(A,I1,A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="',sdofs,'" format="ascii">'    
            
            DO i = 1, Particles % NumberOfParticles
              IF ( Particles % Status(i) > MaxSaveStatus .OR. &
                  Particles % Status(i) < MinSaveStatus )  CYCLE
              j = j + 1
              IF( dim == 2 ) THEN
                IF( .TRUE. ) THEN
                  WRITE( VtuUnit,'(2ES16.7E3,A)', ADVANCE='no') VectorValues(i,1:dim),' 0.0'
                ELSE
                  WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
                END IF
              ELSE
                IF( .TRUE. ) THEN
                  WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') VectorValues(i,1:dim)
                ELSE
                  WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
                END IF
              END IF
              IF( j == NumberOfNodes ) EXIT            
            END DO
            WRITE( VtuUnit,'(A)') ' '
            WRITE( VtuUnit,'(A)') '        </DataArray>'
          END IF
        END DO
      END DO
      
      IF( ScalarsExist .OR. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '      </PointData>'
      END IF
      
    
      ! Coordinates of each point
      !-------------------------------------
      WRITE( VtuUnit,'(A)') '      <Points>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii">'    
      
      
      DO i = 1, Particles % NumberOfParticles
        IF ( Particles % Status(i) > MaxSaveStatus .OR. &
            Particles % Status(i) < MinSaveStatus )  CYCLE
        j = j + 1
        DO k=1,dim
          WRITE(VtuUnit,'(ES16.7E3)', ADVANCE='no') Particles % Coordinate(i,k)
        END DO
        IF( dim == 3 ) THEN
          WRITE(VtuUnit,'(A)') ' '
        ELSE
          WRITE(VtuUnit,'(A)') ' 0.0'
        END IF
        IF( j == NumberOfNodes ) EXIT
      END DO
      
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '      </Points>'
      

      WRITE( VtuUnit,'(A)') '      <Cells>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="connectivity" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="offsets" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="types" format="ascii">'
      WRITE( VtuUnit,'(A)') '        </DataArray>'
      WRITE( VtuUnit,'(A)') '      </Cells>'
      
      WRITE( VtuUnit,'(A)') '    </Piece>'
      WRITE( VtuUnit,'(A)') '  </UnstructuredGrid>'
      WRITE( VtuUnit,'(A)') '</VTKFile>'
      
      CLOSE( VtuUnit )
      
    END SUBROUTINE WriteVtuFile
    


    SUBROUTINE WritePvtuFile( VtuFile )
      CHARACTER(LEN=*), INTENT(IN) :: VtuFile
      INTEGER, PARAMETER :: VtuUnit = 58
      TYPE(Variable_t), POINTER :: Var
      CHARACTER(LEN=512) :: str
      INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
      CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
      LOGICAL :: ScalarsExist, VectorsExist, Found
      REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
      
      
      OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
      
      WRITE( VtuUnit,'(A)') '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
      WRITE( VtuUnit,'(A)') '  <PUnstructuredGrid>'
      
      ! nodewise information
      !-------------------------------------
      ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
      VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
      IF( ScalarsExist .AND. VectorsExist) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)&
            //'" Vectors="'//TRIM(VectorFieldName)//'">'
      ELSE IF( ScalarsExist ) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)//'">'
      ELSE IF( VectorsExist ) THEN
        WRITE( VtuUnit,'(A)') '    <PPointData Vectors="'//TRIM(VectorFieldName)//'">'
      END IF
      
    
      DO Rank = 0,1
        DO Vari = 1, 99
          IF( Vari < 10 ) THEN
            IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
          ELSE
            IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
            IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
          END IF
          
          FieldName = GetString( Params, TRIM(Txt), Found )
          IF(.NOT. Found) EXIT
          
          IF( FieldName /= 'velocity' .AND. FieldName /= 'force' .AND. &
              FieldName /= 'distance' .AND. FieldName /= 'dt' ) THEN
            WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
            CALL Warn('WriteVtuXMLFile', Txt)
            CYCLE
          END IF
          
          IF( Rank == 0) THEN
            WRITE( VtuUnit,'(A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="1" format="ascii"/>'    
          ELSE
            sdofs = 3
            WRITE( VtuUnit,'(A,I1,A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
                //'" NumberOfComponents="',sdofs,'" format="ascii"/>'    
          END IF
        END DO
      END DO
      WRITE( VtuUnit,'(A)') '    </PPointData>'
      
      ! Coordinates of each point
      !-------------------------------------
      WRITE( VtuUnit,'(A)') '      <PPoints>'
      WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii"/>'    
      WRITE( VtuUnit,'(A)') '      </PPoints>' 
      
      DO i=1,Partitions
        WRITE( VtuUnit,'(A,I4.4,A,I4.4,A)' ) '    <Piece Source="'//&
            TRIM(FilePrefix),i,"par",nTime,'.vtu"/>'
      END DO
      
      WRITE( VtuUnit,'(A)') '  </PUnstructuredGrid>'
      WRITE( VtuUnit,'(A)') '</VTKFile>'
      
      CLOSE( VtuUnit )
      
    END SUBROUTINE WritePvtuFile
   

!------------------------------------------------------------------------------
  END SUBROUTINE ParticleOutputVtu
!------------------------------------------------------------------------------



!--------------------------------------------------------------------------
! Set a the timestep for the particles in two possible modes
! 1) "No" is given => define step for each particle separately
! 2) "No" is not given => define the same step size for all particles
!-------------------------------------------------------------------------
FUNCTION GetParticleTimeStep(Particles, InitInterval, No, tinit ) RESULT ( dt )
  
  TYPE(Particle_t) :: Particles
  LOGICAL :: InitInterval
  INTEGER, OPTIONAL :: No
  REAL(KIND=dp), OPTIONAL :: tinit
  REAL(KIND=dp) :: dt

  REAL(KIND=dp) :: dt0,tfin,tprev,dsgoal,hgoal,dtmax,dtmin,dtup,dtlow, &
      CharSpeed, CharTime
  LOGICAL :: GotIt,TfinIs,NStepIs,DsGoalIs,HgoalIs,DtIs
  INTEGER :: nstep, TimeStep, PrevTimeStep = -1
  TYPE(ValueList_t), POINTER :: Params

  SAVE dt0,dsgoal,hgoal,dtmax,dtmin,DtIs,&
      tprev,Tfin,TfinIs,DsGoalIs,HgoalIs,PrevTimeStep
  
  IF( InitInterval ) THEN
    Params => GetSolverParams()
    
    ! directly defined timestep
    dt0 = GetCReal(Params,'Timestep Size',DtIs)
    
    ! Constraint by absolute step size taken (in length units)
    dsgoal = GetCReal( Params,'Timestep Distance',DsGoalIs)
    
    ! Constraint by relative step size taken (1 means size of the element)
    hgoal = GetCReal( Params,'Timestep Courant Number',HGoalIs)
    
    Nstep = GetInteger( Params,'Max Timestep Intervals',NstepIs)

    ! Constraint timestep directly
    dtmax = GetCReal( Params,'Max Timestep Size',GotIt)
    IF(.NOT. GotIt ) dtmax = HUGE( dtmax ) 
    dtmin = GetCReal( Params,'Min Timestep Size',GotIt)
    IF(.NOT. GotIt ) dtmin = 0.0 

    TfinIs = .FALSE.
    IF( GetLogical(Params,'Simulation Timestep Sizes',GotIt) ) THEN
      tfin = GetTimeStepsize()
      TfinIs = .TRUE.
    ELSE
      tfin = GetCReal(Params,'Max Cumulative Time',TfinIs)
    END IF

    tprev = 0.0_dp
  END IF

  IF( TfinIs .AND. ABS( tprev - tfin ) < TINY ( tfin ) ) THEN
    dt = 0.0_dp
    RETURN
  END IF


  ! Get upper and lower constraints for timestep size
  ! These generally depend on the velocity field and mesh
  !--------------------------------------------------------------------
  IF( DtIs ) THEN
    dt = dt0
  ELSE IF( DsGoalIs ) THEN
    CharSpeed = CharacteristicSpeed( Particles, No )     
    dt = dsgoal / CharSpeed
  ELSE IF( HgoalIs ) THEN
    CharTime = CharacteristicElementTime( Particles, No )     
    dt = Hgoal * CharTime ! ElementH / Speed
  ELSE IF( tfinIs .AND. NstepIs ) THEN
    dt = tfin / Nstep
  ELSE
    CALL Fatal('GetParticlesTimeStep','Cannot determine timestep size!')
  END IF

  ! Constrain the timestep
  !------------------------------------------------------------------
  dt = MAX( MIN( dt, dtmax ), dtmin )

  ! Do not exceed the total integration time
  !-------------------------------------------
  IF( PRESENT( tinit ) ) tprev = tinit
  IF( TfinIs .AND. dt + tprev > tfin ) THEN
    dt = tfin - tprev
  END IF
  tprev = tprev + dt

  
END FUNCTION GetParticleTimeStep

!------------------------------------------------------------------------------
END MODULE ParticleUtils
!------------------------------------------------------------------------------
