SUBROUTINE DistanceSolver( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! *
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! *
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!

!******************************************************************************
!
!  Solve the equation: (grad(d),grad(d))=1
!
!  
!    Authors: Juha Ruokolainen
!    Email:   Juha.Ruokolainen@csc.fi
!    Web:     http://www.csc.fi/elmer
!    Address: CSC - Scientific Computing Ltd.
!             Keilaranta 14
!             02101 Espoo, Finland
!  
!    Original Date: 09 Nov 2007
!  
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  LOGICAL :: AllocationsDone = .FALSE., Found
  TYPE(Element_t),POINTER :: Element

  TYPE(ValueList_t), POINTER :: SolverParams, BC

  REAL(KIND=dp) :: Pnorm,Norm,RelaxDT,TOL,x0,y0,z0,x1,y1,z1
  INTEGER :: n, nb, nd, t, i,j,k,istat, active, MaxIter
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: BodyForce
  REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:)

  SAVE STIFF, FORCE, AllocationsDone
!------------------------------------------------------------------------------

  !Allocate some permanent storage, this is done first time only:
  !--------------------------------------------------------------
  Mesh => GetMesh()

  IF ( .NOT. AllocationsDone ) THEN
     N = Solver % Mesh % MaxElementDOFs  ! just big enough for elemental arrays
     ALLOCATE( FORCE(N), STIFF(N,N), STAT=istat )
     IF ( istat /= 0 ) THEN
        CALL Fatal( 'PoissonSolve', 'Memory allocation error.' )
     END IF

     n = Mesh % NumberOfNodes
     IF ( ALL( Solver % Variable % Values == 0.0_dp ) ) &
       Solver % Variable % Values(Solver % Variable % Perm(1:n)) = &
           SQRT( Mesh % Nodes % x(1:n)**2 + &
                 Mesh % Nodes % y(1:n)**2 + &
                 Mesh % Nodes % z(1:n)**2 )

     AllocationsDone = .TRUE.
  END IF

  SolverParams => GetSolverParams()
  RelaxDT = GetCReal( SolverParams, 'Distance Pseudo dt', Found )

  MaxIter = GetInteger( SolverParams, 'Nonlinear System Max Iterations', Found )
  IF ( .NOT. Found ) MaxIter = 100

  TOL = GetCReal( SolverParams, 'Nonlinear System Convergence Tolerance', Found )
  IF ( .NOT. Found ) TOL = 1d-8

  DO i=1,Model % NumberOFBCs
    BC => Model % BCs(i) % Values
    IF ( GetLogical( BC, 'Noslip Wall BC', Found ) ) &
      CALL ListAddConstReal( BC, ComponentName(Solver % Variable), 0.0_dp )
  END DO

  DO i=1,MaxIter
    !System assembly:
    !----------------
    Active = GetNOFActive()
    CALL DefaultInitialize()
    DO t=1,Active
      Element => GetActiveElement(t)
      n  = GetElementNOFNodes()
      nd = GetElementNOFDOFs()
      nb = GetElementNOFBDOFs()

      !Get element local matrix and rhs vector:
      !----------------------------------------
      CALL LocalMatrix(  STIFF, FORCE, Element, n, nd+nb )
      CALL LCondensate( nd, nb, STIFF, FORCE )
      CALL DefaultUpdateEquations( STIFF, FORCE )
    END DO

    CALL DefaultFinishAssembly()
    CALL DefaultDirichletBCs()

    ! And finally, solve:
     !--------------------
    Norm = DefaultSolve()
    IF ( Solver % Variable % NonlinChange <= TOL ) EXIT
  END DO

CONTAINS

!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix(  STIFF, FORCE, Element, n, nd )
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: STIFF(:,:), FORCE(:)
    INTEGER :: n, nd
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(nd),dBasisdx(nd,3),DetJ, &
            SOL(nd),Grad(3),SU(nd),stab,uabs
    LOGICAL :: Stat
    INTEGER :: i,j,t,dim
    TYPE(GaussIntegrationPoints_t) :: IP

    TYPE(Nodes_t) :: Nodes
    SAVE Nodes
!------------------------------------------------------------------------------
    CALL GetElementNodes( Nodes )
    STIFF = 0.0d0
    FORCE = 0.0d0

    dim  = CoordinateSystemDimension()
    CALL GetScalarLocalSolution( SOL )

    !Numerical integration:
    !----------------------
    IP = GaussPoints( Element )
    DO t=1,IP % n
      stat = ElementInfo( Element, Nodes, IP % U(t), IP % V(t), &
               IP % W(t), detJ, Basis, dBasisdx )

      DO i=1,dim
        Grad(i) = SUM( dBasisdx(1:nd,i) * SOL(1:nd) )
      END DO

      Uabs = SQRT( SUM( Grad(1:dim)**2 ) )
      Grad(1:dim) = Grad(1:dim) / Uabs
      stab = Element % hk/2

      SU = 0.0_dp
      DO i=1,nd
        DO j=1,dim
          SU(i) = SU(i) + Grad(j) * dBasisdx(i,j)
        END DO
      END DO

      DO i=1,nd
      DO j=1,nd
         STIFF(i,j) = STIFF(i,j) + IP % s(t) * DetJ * &
           SUM( Grad(1:dim) * dBasisdx(j,1:dim) ) * Basis(i)

         STIFF(i,j) = STIFF(i,j) + IP % s(t) * DetJ * stab * SU(i) * SU(j)

         IF ( RelaxDT > 0 ) STIFF(i,j) = STIFF(i,j) + &
          1._dp/RelaxDT*IP % s(t) * detJ * Basis(j) * Basis(i)
      END DO
      END DO
      FORCE(1:nd) = FORCE(1:nd) + IP % s(t) * DetJ * (Basis(1:nd)+stab*SU(1:nd))

      IF ( RelaxDT > 0 ) FORCE(1:nd) = FORCE(1:nd) + &
         1._dp/RelaxDT*IP % s(t) * DetJ * Basis(1:nd)*SUM(Basis(1:nd)*SOL(1:nd))
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE LCondensate( N, Nb, K, F )
!------------------------------------------------------------------------------
    USE LinearAlgebra
    INTEGER :: N, Nb
    REAL(KIND=dp) :: K(:,:),F(:),Kbb(Nb,Nb), &
         Kbl(Nb,N), Klb(N,Nb), Fb(Nb)

    INTEGER :: m, i, j, l, p, Ldofs(N), Bdofs(Nb)

    IF ( Nb <= 0 ) RETURN

    Ldofs = (/ (i, i=1,n) /)
    Bdofs = (/ (i, i=n+1,n+nb) /)

    Kbb = K(Bdofs,Bdofs)
    Kbl = K(Bdofs,Ldofs)
    Klb = K(Ldofs,Bdofs)
    Fb  = F(Bdofs)

    CALL InvertMatrix( Kbb,nb )

    F(1:n) = F(1:n) - MATMUL( Klb, MATMUL( Kbb, Fb  ) )
    K(1:n,1:n) = &
         K(1:n,1:n) - MATMUL( Klb, MATMUL( Kbb, Kbl ) )
!------------------------------------------------------------------------------
  END SUBROUTINE LCondensate
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
END SUBROUTINE DistanceSolver
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
SUBROUTINE DistanceSolver1( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------

!******************************************************************************
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  LOGICAL :: AllocationsDone = .FALSE., Found
  TYPE(Element_t),POINTER :: Element

  TYPE(ValueList_t), POINTER :: SolverParams, BC

  REAL(KIND=dp) :: Pnorm,Norm,RelaxDT,TOL,x0,y0,z0,dist
  INTEGER :: n, nb, nd, t, i,j,k,istat, active, MaxIter
  INTEGER, POINTER :: APerm(:), BPerm(:)
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: BodyForce
  REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:)

  SAVE STIFF, FORCE, AllocationsDone
!------------------------------------------------------------------------------

  Mesh => GetMesh()
  ALLOCATE( APerm(Mesh % NumberOfNodes), BPerm(Mesh % NumberOfNodes) )
  Aperm = 0
  Bperm = 0
  nb = 0
  DO t=1,Mesh % NumberOfBoundaryElements
    Element => GetBoundaryElement(t)
    IF ( .NOT. ActiveBoundaryElement() ) CYCLE

    BC => GetBC()
    IF ( ListCheckPresent(BC,ComponentName(Solver % Variable)).OR. &
         GetLogical( BC, 'Noslip Wall BC', Found ) ) THEN
      n = GetElementNOFNodes()
      DO i=1,n
        j = Element % NodeIndexes(i)
        IF ( Bperm(j) == 0 ) THEN
          nb = nb + 1
          Aperm(nb) = j
          Bperm(j)  = nb
        END IF
      END DO
    END IF
  END DO

  Solver % Variable % Values = HUGE(1._dp)
  DO i=1,Mesh % NumberOfNodes
    k = Solver % Variable % Perm(i)
    IF ( k <= 0 ) CYCLE

    IF ( Bperm(i) /= 0 ) THEN
      Solver % Variable % Values(k) = 0.0_dp
      CYCLE
    END IF

    x0 = Mesh % Nodes % x(i)
    y0 = Mesh % Nodes % y(i)
    z0 = Mesh % Nodes % z(i)
    DO j=1,nb
      dist = (Mesh % Nodes % x(Aperm(j))-x0)**2 + &
             (Mesh % Nodes % y(Aperm(j))-y0)**2 + &
             (Mesh % Nodes % z(Aperm(j))-z0)**2
      Solver % Variable % Values(k) = MIN(Solver % Variable % Values(k), dist)
    END DO
  END DO
  Solver % Variable % Norm   = SQRT(SUM(Solver % Variable % Values)) 
  Solver % Variable % Values = SQRT(Solver % Variable % Values)

  DEALLOCATE( APerm, BPerm )
!------------------------------------------------------------------------------
END SUBROUTINE DistanceSolver1
!------------------------------------------------------------------------------
