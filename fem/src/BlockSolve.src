MODULE BlockSolve

 USE DefUtils

 IMPLICIT NONE

 TYPE SubVector_t
    TYPE(Variable_t), POINTER :: Var
    REAL(KIND=dp) :: rnorm, bnorm, xnorm
    REAL(KIND=dp), ALLOCATABLE :: rhs(:)
  END TYPE SubVector_t

  TYPE SubMatrix_t
     TYPE(Matrix_t), POINTER :: Mat
     TYPE(Matrix_t), POINTER :: PrecMat
  END TYPE SubMatrix_t

  TYPE BlockMatrix_t
    INTEGER :: NoVar = 0, MaxSize, TotSize
    INTEGER, POINTER :: Offset(:)
    TYPE(Solver_t), POINTER :: Solver
    REAL(KIND=dp) :: rnorm, bnorm, xnorm
    TYPE(SubMatrix_t), ALLOCATABLE :: SubMatrix(:,:)
    LOGICAL, ALLOCATABLE :: SubMatrixActive(:,:)
    TYPE(SubVector_t), POINTER :: SubVector(:) => NULL()
    INTEGER, POINTER :: BlockStruct(:)
    LOGICAL :: GotBlockStruct
  END TYPE BlockMatrix_t

  TYPE(BlockMatrix_t), TARGET, SAVE :: TotMatrix

  LOGICAL, PRIVATE :: isParallel=.FALSE.

  


CONTAINS


  !-----------------------------------------------------------------------------------
  !> If a block variable does not exist it will be created. 
  !> Here only normal nodal elements are supported for the moment. 
  !> Then also the creation of permutation vector is straight-forward.
  !> Note that no reordering is currently performed.
  !
  !> There is limitation regarding non-nodal elements which stems partly from the fact
  !> that an elementtype is solver specific while this one solver could have a number of
  !> different elementtypes for different equations.
  !-----------------------------------------------------------------------------------
  FUNCTION CreateBlockVariable( Solver, VariableNo, VarName, ExtDofs, ExtPerm ) RESULT ( Var )
    
    TYPE(Solver_t), POINTER :: Solver
    INTEGER :: VariableNo
    CHARACTER(LEN=max_name_len) :: VarName
    INTEGER, OPTIONAL :: ExtDofs
    INTEGER, POINTER, OPTIONAL :: ExtPerm(:)
    TYPE(Variable_t), POINTER :: Var
    
    TYPE(Solver_t), POINTER :: PSolver
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: Element
    INTEGER :: i,j,t,n,ndeg,body_id,body_id_prev,eq_id,solver_id,Dofs,nsize
    INTEGER, POINTER :: VarPerm(:), ActiveVariables(:)
    INTEGER, ALLOCATABLE :: Indexes(:)
    REAL(KIND=dp), POINTER :: Values(:)
    LOGICAL :: Hit, GotIt
    CHARACTER(LEN=max_name_len) :: str, eq
    
    LOGICAL :: GlobalBubbles, Found
    INTEGER :: MaxNDOFs, MaxDGDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs


    Mesh => Solver % Mesh
    Params => Solver % Values

    IF( PRESENT( ExtDofs ) ) THEN
      Dofs = ExtDofs
    ELSE 
      WRITE (str,'(A,I0,A)') 'Variable ',VariableNo,' Dofs'
      Dofs = ListGetInteger( Params, TRIM(str), GotIt )
      IF(.NOT. GotIt) Dofs = 1
    END IF
    
    IF( PRESENT( ExtPerm ) ) THEN
      nsize = MAXVAL( ExtPerm ) 
      varPerm => ExtPerm
      GOTO 100
    END IF
    
    Ndeg = 0
    MaxNDOFs  = 0
    MaxBDOFs = 0
    MaxDGDOFs = 0
    DO i=1, Mesh % NumberOFBulkElements
      Element => Mesh % Elements(i)
      MaxNDOFs  = MAX( MaxNDOFs,  Element % NDOFs )
      MaxBDOFs  = MAX( MaxBDOFs,  Element % BDOFs )
      MaxDGDOFs = MAX( MaxDGDOFs, Element % DGDOFs )
    END DO
    
    MaxEDOFs = 0
    DO i=1, Mesh % NumberOFEdges
      Element => Solver % Mesh % Edges(i)
      MaxEDOFs  = MAX( MaxEDOFs,  Element % BDOFs )
    END DO
    
    MaxFDOFs = 0
    DO i=1, Mesh % NumberOFFaces
      Element => Solver % Mesh % Faces(i)
      MaxFDOFs  = MAX( MaxFDOFs,  Element % BDOFs )
    END DO
    
    GlobalBubbles = ListGetLogical( Params, 'Bubbles in Global System', Found )
    IF (.NOT.Found) GlobalBubbles = .TRUE.
    
    Ndeg = Ndeg + Mesh % NumberOfNodes
    IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Mesh % NumberOFEdges
    IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Mesh % NumberOFFaces
    IF ( GlobalBubbles ) &
        Ndeg = Ndeg + MaxBDOFs * Mesh % NumberOfBulkElements
    IF ( ListGetLogical( Params, 'Discontinuous Galerkin', Found ) ) &
        Ndeg = MAX( NDeg, MaxDGDOFs * ( Mesh % NumberOfBulkElements + &
        Mesh % NumberOfBoundaryElements) )
    
    ALLOCATE( VarPerm(ndeg) )
    VarPerm = 0
    
    solver_id = 0
    DO i = 1, CurrentModel % NumberOfSolvers
      PSolver => CurrentModel % Solvers(i)
      IF( ASSOCIATED( Solver, PSolver ) ) THEN
        solver_id = i
        EXIT
      END IF
    END DO
    
    ALLOCATE(Indexes(Mesh % MaxElementDOFs))
    body_id_prev = -1
    DO t=1,Mesh % NumberOfBulkElements + Mesh % NumberOFBoundaryElements
      Element => Mesh % Elements(t)
      CurrentModel % CurrentElement => Element
      
      body_id = Element % BodyId 
      IF( body_id /= body_id_prev ) THEN
        Hit = .FALSE.
        body_id_prev = body_id
        
        IF( body_id < 1 ) CYCLE
        eq_id = ListGetInteger( CurrentModel % Bodies(body_id) % Values,'Equation')
        IF( eq_id < 1 ) CYCLE
        
        str='Active Variables['//TRIM(i2s(solver_id))//']'            
        ActiveVariables => ListGetIntegerArray(CurrentModel % Equations(eq_id) % Values, str)
        IF(.NOT. ASSOCIATED(ActiveVariables)) THEN
          ActiveVariables => ListGetIntegerArray( CurrentModel % Equations(eq_id) % Values, &
              'Active Variables')
        END IF
        IF( .NOT. ASSOCIATED(ActiveVariables)) CYCLE
        IF( .NOT. ANY(ActiveVariables == VariableNo) )  CYCLE
        Hit = .TRUE.
      END IF
      
      IF( Hit ) THEN
         n=GetElementDOFs(Indexes)
         VarPerm(Indexes(1:n)) = 1
      END IF
    END DO
    
    j = 0
    DO i = 1, SIZE(VarPerm)
      IF( VarPerm(i) > 0 ) THEN
        j = j + 1
        VarPerm(i) = j
      END IF
    END DO
    nsize = j
    
100 IF( nsize == 0 ) THEN
      CALL Fatal('CreateBlockVariable','Variable '//TRIM(VarName)//' cannot be created')      
    END IF

    CALL Info('CreateBlockVariable','Creating variable: '//TRIM(VarName), Level=6 )
    
    CALL VariableAddVector( Mesh % Variables, Mesh, Solver, &
        TRIM(VarName), Dofs, Perm = VarPerm )          
    
    WRITE( Message,'(A,I0,A)') 'Creating variable '//TRIM(VarName)//' with ',Dofs,' dofs'
    CALL Info('BlockSolver',Message)
    
    Var => VariableGet( Mesh % Variables, VarName )         

  END FUNCTION CreateBlockVariable



  !-------------------------------------------------------------------
  !> This subroutine initializes the block matrix structure so that the 
  !> matrices and vectors have a natural location to save.
  !------------------------------------------------------------------
  SUBROUTINE BlockInitMatrix( Solver, BlockMatrix, BlockDofs )
    
    IMPLICIT NONE
    
    TYPE(Solver_t), TARGET :: Solver
    TYPE(BlockMatrix_t) :: BlockMatrix
    INTEGER :: BlockDofs

    TYPE(Solver_t), POINTER :: PSolver
    INTEGER, POINTER :: BlockStruct(:)
    LOGICAL :: GotBlockStruct, Found
    TYPE(Matrix_t), POINTER :: Amat
    INTEGER :: i,j,n,Novar
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=max_name_len) :: VarName, str

    Params => Solver % Values
 
    BlockStruct => ListGetIntegerArray( Params,'Block Structure',GotBlockStruct)
    IF( GotBlockStruct ) THEN
      IF( SIZE( BlockStruct ) /= BlockDofs ) THEN
        CALL Fatal('BlockSolver','Incompatible size of > Block Structure < given!')
      END IF
      IF( MINVAL( BlockStruct ) < 1 .OR. MAXVAL( BlockStruct ) > BlockDofs ) THEN
        CALL Fatal('BlockSolver','Incompatible values in > Block Structure < given!')          
      END IF
      NoVar = MAXVAL( BlockStruct )
      BlockMatrix % BlockStruct => BlockStruct
    ELSE
      NoVar = BlockDofs
    END IF    
    BlockMatrix % GotBlockStruct = GotBlockStruct


    IF( BlockMatrix % NoVar == NoVar ) THEN
      CALL Info('InitializeBlockMatrix','Reusing existing blockmatrix',Level=6)
      RETURN
    ELSE IF( BlockMatrix % Novar /= 0 ) THEN
      CALL Fatal('InitializeBlockMatrix','Currently only one block matrix may exist!')
    ELSE
      CALL Info('InitializeBlockMatrix','Starting',Level=6)
    END IF
    
    BlockMatrix % Solver => Solver
    BlockMatrix % NoVar = NoVar

    ALLOCATE( BlockMatrix % SubMatrix(NoVar,NoVar) )
    DO i=1,NoVar
      DO j=1,NoVar
        Amat => AllocateMatrix()
        CALL ClearMatrix(Amat)
        Amat % ListMatrix => NULL()
        Amat % FORMAT = MATRIX_LIST      
        Amat % NumberOfRows = 0
        BlockMatrix % Submatrix(i,j) % Mat => Amat
        
        ALLOCATE( BlockMatrix % Submatrix(i,j) % PrecMat )
        Amat => BlockMatrix % Submatrix(i,j) % PrecMat
        CALL ClearMatrix( Amat )
      END DO
    END DO
    
    ALLOCATE( BlockMatrix % SubMatrixActive(NoVar,NoVar) )
    BlockMatrix % SubMatrixActive = .FALSE.
    
    ALLOCATE( BlockMatrix % SubVector(NoVar))
    ALLOCATE( BlockMatrix % Offset(NoVar+1))
    BlockMatrix % Offset = 0
    BlockMatrix % maxsize = 0
    
    DO i = 1,NoVar
      WRITE (str,'(A,I0)') 'Variable ',i
      
      VarName = ListGetString( Params, TRIM(str), Found )
      IF(.NOT. Found ) THEN       
        IF( BlockMatrix % GotBlockStruct ) THEN
          WRITE (VarName,'(A,I0)') 'BlockVar ',i
        ELSE
          VarName = ComponentName(Solver % Variable % Name,i)            
        END IF
      END IF
      Var => VariableGet( Solver % Mesh % Variables, VarName )
      
      !-----------------------------------------------------------------------------------
      ! If variable does not exist it will be created. 
      ! Here only normal nodal elements are supported for the moment. 
      ! Then also the creation of permutation vector is straight-forward.
      ! Note that no reordering is currently performed.
      !
      ! There is limitation regarding non-nodal elements which stems partly from the fact
      ! that an elementtype is solver specific while this one solver could have a number of
      ! different elementtypes for different equations.
      !-----------------------------------------------------------------------------------
      IF(ASSOCIATED( Var ) ) THEN
        CALL Info('BlockSolver','Using existing variable > '//TRIM(VarName)//' <')		
      ELSE		
        CALL Info('BlockSolver','Variable > '//TRIM(VarName)//' < does not exist, creating')
        PSolver => Solver
        IF( BlockMatrix % GotBlockStruct ) THEN
          j = COUNT( BlockMatrix % BlockStruct == i ) 
          IF( j == 0 ) THEN
            CALL Fatal('InitializeBlockMatrix','Invalid > Block Structure < given!')
          END IF
          Var => CreateBlockVariable(PSolver, i, VarName, j, Solver % Variable % Perm )
        ELSE
          Var => CreateBlockVariable(PSolver, i, VarName )
        END IF
      END IF
      
      BlockMatrix % SubVector(i) % Var => Var
      n = SIZE( Var % Values )
      
      BlockMatrix % Offset(i+1) = BlockMatrix % Offset(i) + n
      BlockMatrix % MaxSize = MAX( BlockMatrix % MaxSize, n )
    END DO
    
    BlockMatrix % TotSize = BlockMatrix % Offset( NoVar + 1 )
    
    
  END SUBROUTINE BlockInitMatrix
    

  SUBROUTINE BlockPickMatrix( Solver, NoVar )

    TYPE(Solver_t) :: Solver
    INTEGER :: Novar

    INTEGER :: RowVar, ColVar
    TYPE(Matrix_t), POINTER :: SolverMatrix
    TYPE(Matrix_t), POINTER :: Amat
    TYPE(ValueList_t), POINTER :: Params
    LOGICAL :: ReuseMatrix, Found

    SolverMatrix => Solver % Matrix 
    Params => Solver % Values

    ReuseMatrix = ListGetLogical( Params,'Block Matrix Reuse',Found)

    DO RowVar=1,NoVar
      DO ColVar=1,NoVar            
        Amat => TotMatrix % Submatrix(RowVar,ColVar) % Mat          
        IF( TotMatrix % GotBlockStruct) THEN
          CALL CRS_BlockMatrixPick2(SolverMatrix,Amat,TotMatrix % BlockStruct,RowVar,ColVar)
        ELSE
          ! One needs more complicated tests to reuse the matrix structure in a generic case
          !---------------------------------------------------------------------------------
          IF( ReuseMatrix .AND. ( RowVar + ColVar > 2 ) ) THEN
            CALL CRS_CopyMatrixTopology( TotMatrix % Submatrix(1,1) % Mat, Amat )
          END IF
          CALL CRS_BlockMatrixPick(SolverMatrix,Amat,NoVar,RowVar,ColVar)          
        END IF
      END DO
    END DO

  END SUBROUTINE BlockPickMatrix


  SUBROUTINE BlockPrecMatrix( Solver, NoVar )

    TYPE(Solver_t) :: Solver
    INTEGER :: Novar

    INTEGER :: i, RowVar, ColVar
    CHARACTER(LEN=max_name_len) :: str
    REAL(KIND=dp) :: Coeff
    LOGICAL :: GotIt, GotIt2
    INTEGER, POINTER :: VarPerm(:)
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Matrix_t), POINTER :: Amat

    Params => Solver % Values
 
    ! The user may give a user defined preconditioner matrix
    !-----------------------------------------------------------
    DO RowVar=1,NoVar
      i = TotMatrix % Submatrix(RowVar,RowVar) % PrecMat % NumberOfRows 
      IF( i > 0 ) CYCLE
      
      WRITE (str,'(A,I0)') 'Prec Matrix Diffusion ',RowVar
      Coeff = ListGetCReal( Params, TRIM(str), GotIt)
      
      WRITE (str,'(A,I0)') 'Prec Matrix Density ',RowVar
      Coeff = ListGetCReal( Params, TRIM(str), GotIt2)
      
      IF( GotIt .OR. GotIt2 ) THEN
        CALL Info('BlockPrecMatrix','Creating simple preconditioning matrix')
        
        CALL CRS_CopyMatrixTopology( TotMatrix % Submatrix(RowVar,RowVar) % Mat, &
            TotMatrix % Submatrix(RowVar,RowVar) % PrecMat )   
        
        Amat => TotMatrix % Submatrix(RowVar,RowVar) % PrecMat
        VarPerm => TotMatrix % Subvector(RowVar) % Var % Perm
        IF( GotIt ) THEN
          CALL LaplaceMatrixAssembly( Solver, VarPerm, Amat )
          Amat % Values = Coeff * Amat % Values
        ELSE 
          CALL MassMatrixAssembly( Solver, VarPerm, Amat )
          Amat % Values = Coeff * Amat % Values
        END IF
      END IF
    END DO
  END SUBROUTINE BlockPrecMatrix


  !------------------------------------------------------------------------------          
  !> Compute the rhs for the block matrix system which is solved
  !> accounting only the diagonal entries i.e. subtract the non-diagonal 
  !> matrix-vector results from the original r.h.s. vectors.
  !> After this the block diagonal problem Ax=b may be solved.
  !----------------------------------------------------------------------------------
  SUBROUTINE BlockUpdateRhs( BlockMatrix, ThisRow )
    
    TYPE(BlockMatrix_t), TARGET :: BlockMatrix
    INTEGER, OPTIONAL :: ThisRow
    
    TYPE(Matrix_t), POINTER :: A
    INTEGER :: n, NoRow,NoCol, NoVar
    REAL(KIND=dp), POINTER :: x(:),rtmp(:),rhs(:)
    TYPE(Variable_t), POINTER :: Var
    
    CALL Info('BlockUpdateRhs','Computing block r.h.s',Level=5)

    NoVar = BlockMatrix % NoVar
    
    ! The residual is used only as a temporary vector
    ALLOCATE( rtmp(BlockMatrix % MaxSize) )
    
    
    DO NoRow = 1,NoVar 
      
      ! Optionally only one diagonal block may be updated for
      IF( PRESENT( ThisRow ) ) THEN
        IF( NoRow /= ThisRow ) CYCLE 
      END IF
      
      Var => BlockMatrix % SubVector(NoRow) % Var
      x => Var % Values
      n = SIZE( x )
      
      ! The r.h.s. of the initial system is stored in the Matrix
      !-----------------------------------------------------------
      IF(.NOT. ALLOCATED( BlockMatrix % SubVector(NoRow) % rhs )) THEN
        ALLOCATE( BlockMatrix % SubVector(NoRow) % rhs(n) )
        BlockMatrix % SubVector(NoRow) % rhs = 0.0_dp
      END IF
      rhs => BlockMatrix % SubVector(NoRow) % rhs
      
      A => BlockMatrix % SubMatrix( NoRow, NoRow ) % Mat
      rhs = A % rhs
      
      DO NoCol = 1,NoVar           
        ! This ensures that the diagonal itself is not subtracted
        ! Otherwise the linear system should be solved for dx rather than x
        IF( NoCol == NoRow ) CYCLE
        
        Var => BlockMatrix % SubVector(NoCol) % Var
        x => Var % Values
        A => BlockMatrix % SubMatrix( NoRow, NoCol ) % Mat
        IF( A % NumberOfRows == 0 ) CYCLE
        
        rtmp = 0._dp
        CALL CRS_MatrixVectorMultiply( A, x, rtmp)      
        
        rhs(1:n) = rhs(1:n) - rtmp(1:n)
      END DO
    END DO
    
    DEALLOCATE( rtmp )
    
  END SUBROUTINE BlockUpdateRhs
  

!------------------------------------------------------------------------------
!> Perform matrix-vector product for block matrices.
!> Has to be callable outside the module by Krylov methods.
!------------------------------------------------------------------------------
  SUBROUTINE BlockMatrixVectorProd( u,v,ipar )
    INTEGER :: i,j,k,NoVar,ipar(*)
    REAL(KIND=dp) :: u(*),v(*)
    REAL(KIND=dp), ALLOCATABLE :: s(:)
    INTEGER :: maxsize
    INTEGER, POINTER :: Offset(:)
    
    NoVar = TotMatrix % NoVar
    Offset => TotMatrix % Offset
    MaxSize = TotMatrix % MaxSize

    ALLOCATE( s(MaxSize) )

    v(1:offset(NoVar+1)) = 0
    DO i=1,NoVar
      DO j=1,NoVar
        s = 0._dp
        IF (isParallel) THEN
          CALL ParallelMatrixVector( TotMatrix % SubMatrix(i,j) % Mat, &
               u(offset(j)+1:offset(j+1)), s  )
        ELSE
          CALL CRS_MatrixVectorMultiply( TotMatrix % SubMatrix(i,j) % Mat, &
                   u(offset(j)+1:offset(j+1)), s )
        END IF

        DO k=1,offset(i+1)-offset(i)
          v(k+offset(i)) = v(k+offset(i)) + s(k)
        END DO
      END DO
    END DO
  END SUBROUTINE BlockMatrixVectorProd
  

!------------------------------------------------------------------------------
!> Perform block preconditioning by solving all the individual diagonal problems.
!> Has to be called outside the module by Krylov methods.
!------------------------------------------------------------------------------
  SUBROUTINE BlockMatrixPrec( u,v,ipar )    
    REAL(KIND=dp), TARGET :: u(*), v(*)
    INTEGER :: ipar(*)
!---------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: rtmp(:),vtmp(:),b(:), x(:), rhs_save(:)
    INTEGER :: i,j,k,l,NoVar
    TYPE(Solver_t), POINTER :: Solver
    INTEGER, POINTER :: Offset(:)
    TYPE(ValueList_t), POINTER :: Params
    INTEGER, POINTER :: BlockOrder(:)
    TYPE(Matrix_t), POINTER :: A, mat_save
    TYPE(Variable_t), POINTER :: Var, SolverVar

    LOGICAL :: GotOrder, BlockGS, Found, NS, SkipCompChange
    TYPE(Varying_string) :: namesp
    CHARACTER(LEN=MAX_NAME_LEN) :: str
    INTEGER(KIND=AddrInt) :: AddrFunc
    
    CALL Info('BlockMatrixPrec','Starting preconditioning',Level=6)
    
    WRITE(Message,'(A,I0)') 'Number of coupled variables: ',NoVar
    
    Solver => CurrentModel % Solver
    Params => Solver % Values
    
    ! Enable user defined order for the solution of blocks
    !---------------------------------------------------------------
    BlockOrder => ListGetIntegerArray( Params,'Block Order',GotOrder)
    BlockGS = ListGetLogical( Params,'Block Gauss-Seidel',Found)
    
    NoVar = TotMatrix % NoVar
    Solver => TotMatrix % Solver
    offset => TotMatrix % Offset
    SolverVar => Solver % Variable

    NS = ListGetNameSpace(namesp)

    ! Initial guess 
    !-----------------------------------------
    u(1:offset(NoVar+1)) = v(1:offset(NoVar+1))

    IF( BlockGS ) THEN
      ALLOCATE( vtmp(offset(NoVar+1)), rtmp(offset(NoVar+1)) )
      vtmp(1:offset(NoVar+1)) = v(1:offset(NoVar+1))
    END IF


    DO j=1,NoVar
      IF( GotOrder ) THEN
        i = BlockOrder(j)
      ELSE
        i = j
      END IF
      
      WRITE(Message,'(A,I0)') 'Solving block: ',i
      CALL Info('BlockMatrixPrec',Message,Level=6)

      ! Set pointers to the new linear system
      !-------------------------------------------------------------------
      A => TotMatrix % Submatrix(i,i) % PrecMat
      IF( A % NumberOfRows == 0 ) THEN
        A => TotMatrix % Submatrix(i,i) % Mat
      ELSE
        PRINT *,'Using specialized preconditioning block'
      END IF

      x => u(offset(i)+1:offset(i+1))
      Var => TotMatrix % SubVector(i) % Var
      Solver % Variable => Var
      IF( BlockGS ) THEN
        b => vtmp(offset(i)+1:offset(i+1))
      ELSE      
        b => v(offset(i)+1:offset(i+1))
      END IF

      mat_save => Solver % Matrix
      Solver % Matrix => A
      rhs_save => Solver % Matrix % RHS
      Solver % Matrix % RHS => b
    
      ! Reuse block preconditioner from the first block to other components
      !--------------------------------------------------------------------
      IF( ListGetLogical( Params,'Block Prec Reuse',Found) ) THEN
        DO k = 1, NoVar
          IF( k == i ) CYCLE
          IF( CRS_CopyMatrixPrec( TotMatrix % Submatrix(k,k) % Mat, A ) ) EXIT
        END DO
      END IF

      CALL ListSetNameSpace('block '//TRIM(i2s(i))//TRIM(i2s(i))//':')
      SkipCompChange = ListGetLogical( Params,'Skip Compute Nonlinear Change',Found)
      CALL ListAddLogical( Params,'Skip Compute Nonlinear Change',.TRUE.)

      IF (isParallel) THEN
        GlobalData => A % ParMatrix
        GlobalMatrix => GlobalData % SplittedMatrix % InsideMatrix
        GlobalMatrix % MatVecSubr = A % MatVecSubr
        GlobalMatrix % Ematrix => A
        GlobalMatrix % COMPLEX = A % COMPLEX

        CALL IterSolver( GlobalMatrix, x,b, &
            Solver,MatvecF=AddrFunc(SParMatrixVector), &
                DotF=AddrFunc(SParDotProd), NormF=AddrFunc(SParNorm))
      ELSE
        CALL SolveSystem( A, ParMatrix, b, &
            x, Var % Norm, Var % DOFs, Solver )
      END IF

      Solver % Matrix % RHS => rhs_save
      Solver % Matrix => mat_save

      !---------------------------------------------------------------------
      IF( BlockGS ) THEN        
        CALL Info('BlockSolver','Computing block r.h.s',Level=5)
      
        DO l=j+1,NoVar
          IF( GotOrder ) THEN
            k = BlockOrder(l)
          ELSE
            k = l
          END IF
        
          WRITE( str,'(A,I0,I0)') 'Block Gauss-Seidel Passive ',k,i
          IF( ListGetLogical( Params, str, Found ) ) CYCLE
        
          ! The residual is used only as a temporary vector
          !-------------------------------------------------------------
          IF (isParallel) THEN
            CALL ParallelMatrixVector(TotMatrix % SubMatrix(k,i) % Mat,x,rtmp )
          ELSE
            CALL CRS_MatrixVectorMultiply(TotMatrix % SubMatrix(k,i) % Mat,x,rtmp )
          END IF
          vtmp(offset(k)+1:offset(k+1)) = vtmp(offset(k)+1:offset(k+1)) &
                   - rtmp(1:offset(k+1)-offset(k))
        END DO
      END IF
    END DO

    CALL ListSetNameSpace(CHAR(namesp))
    CALL ListAddLogical( Params,'Skip Compute Nonlinear Change',SkipCompChange)
    Solver % Variable => SolverVar

    IF( BlockGS ) THEN
      DEALLOCATE( vtmp, rtmp ) 
    END IF

    CALL Info('BlockMatrixPrec','Finished preconditioning',Level=6)
    
  END SUBROUTINE BlockMatrixPrec


  !-----------------------------------------------------------------
  !> This call takes care of Jacobi & Gauss Seidel block methods. 
  !-----------------------------------------------------------------
  SUBROUTINE BlockStandardIter( Solver, MaxChange )

    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: MaxChange

    INTEGER :: i,j,NoVar,RowVar,iter,LinIter
    INTEGER, POINTER :: BlockOrder(:)
    LOGICAL :: GotIt, GotBlockOrder, SkipCompChange, BlockGS
    REAL(KIND=dp), POINTER :: b(:), rhs_save(:)
    TYPE(Matrix_t), POINTER :: A, mat_save
    TYPE(Variable_t), POINTER :: Var, SolverVar
    REAL(KIND=dp) :: LinTol, TotNorm
    TYPE(ValueList_t), POINTER :: Params
    LOGICAL :: Found

    NoVar = TotMatrix % NoVar
    Params => Solver % Values
    SolverVar => Solver % Variable

    BlockGS = ListGetLogical( Params,'Block Gauss-Seidel',Found)
    BlockOrder => ListGetIntegerArray( Params,'Block Order',GotBlockOrder)
    LinIter = ListGetInteger( Params,'Linear System Max Iterations',GotIt)
    LinTol = ListGetConstReal( Params,'Linear System Convergence Tolerance',GotIt)
    
    DO iter = 1, LinIter
      
      ! In block Jacobi the r.h.s. is not updated during the iteration cycle
      !----------------------------------------------------------------------
      IF( BlockGS ) THEN
        WRITE( Message,'(A,I0)') 'Block Gauss-Seidel iteration: ',iter
      ELSE
        WRITE( Message,'(A,I0)') 'Block Jacobi iteration: ',iter
        CALL BlockUpdateRhs(TotMatrix)
      END IF
      CALL Info('BlockSolver',Message,Level=6)
      MaxChange = 0.0_dp
      
      DO i=1,NoVar
        IF( GotBlockOrder ) THEN
          RowVar = BlockOrder(i)
        ELSE
          RowVar = i
        END IF
        
        ! In gauss-seidel the partial update is immediately taken into account
        !---------------------------------------------------------------------
        IF( BlockGS ) THEN
          CALL BlockUpdateRhs(TotMatrix,RowVar)
        END IF
        
        IF( ListGetLogical( Params,'Block Prec Reuse',GotIt) ) THEN
          DO j = 1, NoVar
            IF( j == RowVar ) CYCLE
            IF( CRS_CopyMatrixPrec( TotMatrix % Submatrix(j,j) % Mat, A ) ) EXIT
          END DO
        END IF
        
        A => TotMatrix % Submatrix(RowVar,RowVar) % Mat
        b => TotMatrix % SubVector(RowVar) % rhs
        Var => TotMatrix % SubVector(RowVar) % Var
        Solver % Variable => Var
        
        mat_Save => Solver % Matrix
        Solver % Matrix => A
        rhs_save => Solver % Matrix % RHS
        Solver % Matrix % RHS => b
        
        ! Solving the subsystem
        !-----------------------------------
        CALL ListSetNameSpace('block '//TRIM(i2s(RowVar))//TRIM(i2s(RowVar))//':')          
        CALL SolveSystem( A, ParMatrix, b, &
            Var % Values, Var % Norm, Var % DOFs, Solver )
        
        Solver % Matrix % RHS => rhs_save
        Solver % Matrix => mat_save
        
        TotNorm = TotNorm + Var % Norm
        MaxChange = MAX( MaxChange, Var % NonlinChange )
      END DO      
    END DO
        
    Solver % Variable => SolverVar

  END SUBROUTINE BlockStandardIter


  !---------------------------------------------------------------------------
  !> This call takes care of the iterative Krylov methods for block systems
  !> which can still be preconditioned by block Jacobi or Gauss-Seidel methods
  !---------------------------------------------------------------------------
  SUBROUTINE BlockKrylovIter( Solver, MaxChange )

    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: MaxChange

    INTEGER(KIND=AddrInt) :: AddrFunc, iterProc,precProc, mvProc,dotProc,nmrProc, zero=0
    REAL(KIND=dp) :: dpar(20), xnorm,prevxnorm
    REAL(KIND=dp), ALLOCATABLE :: x(:),b(:),r(:)
    
    TYPE(Matrix_t), POINTER :: A
    TYPE(Variable_t), POINTER :: SolverVar
    
    INTEGER :: NoVar, ndim, maxsize
    LOGICAL :: Converged, Diverged
    INTEGER :: Rounds, OutputInterval, PolynomialDegree
    INTEGER, POINTER :: Offset(:),poffset(:),BlockStruct(:)
    INTEGER :: i,j,k,l,ia,ib
    LOGICAL :: LS
    TYPE(Varying_string) :: namesp

    Offset => TotMatrix % Offset
    ndim = TotMatrix % TotSize 
    NoVar = TotMatrix % NoVar
    ALLOCATE(x(ndim), b(ndim),r(ndim))
    x=0;b=0;r=0
    
    IF (isParallel) THEN
      DO i=1,NoVar
        DO j=1,NoVar
          IF ( i /= j ) THEN
            CALL ParallelInitSolve( TotMatrix % SubMatrix(i,j) % Mat, &
                r,r,r)
          ELSE 
            x(offset(i)+1:offset(i+1)) = TotMatrix % SubVector(i) % Var % Values
            b(offset(i)+1:offset(i+1)) = TotMatrix % SubMatrix(i,i) % Mat % RHS
            
            CALL ParallelInitSolve( TotMatrix % SubMatrix(i,j) % Mat, &
                x(offset(j)+1:offset(j+1)), b(offset(i)+1:offset(i+1)),r )
          END IF
        END DO
      END DO
    END IF
    
    k=0
    x=0;b=0
    IF (isParallel) ALLOCATE(poffset(NoVar+1))
    DO i=1,NoVar
      IF (.NOT.isParallel) THEN
        x(offset(i)+1:offset(i+1)) = TotMatrix % SubVector(i) % Var % Values
        b(offset(i)+1:offset(i+1)) = TotMatrix % SubMatrix(i,i) % Mat % rhs
      ELSE
        A => TotMatrix % SubMatrix(i,i) % Mat
        poffset(i) = k
        DO j=1,offset(i+1)-offset(i)
          IF ( A % ParallelInfo % NeighbourList(j) % Neighbours(1) == ParEnv % Mype ) THEN
            k=k+1
            x(k) = TotMatrix % SubVector(i) % Var % Values(j)
          END IF
        END DO
        poffset(i+1) = k
      END IF
    END DO
    
    
    IF (isParallel) THEN
      DO i=1,NoVar
        A => TotMatrix % SubMatrix(i,i) % Mat
        b(poffset(i)+1:poffset(i+1)) = A % ParMatrix % SplittedMatrix % InsideMatrix % Rhs
      END DO
      
      ndim = poffset(NoVar+1)
      TotMatrix % Offset => poffset
    END IF
    
    !----------------------------------------------------------------------
    ! Solve matrix equation solver with the redefined block matrix operations
    !----------------------------------------------------------------------
    precProc = AddrFunc(BlockMatrixPrec)
    mvProc = AddrFunc(BlockMatrixVectorProd)

    LS = ListGetNameSpace(namesp)
    CALL ListSetNameSpace('outer:')
    
    prevXnorm = SQRT( SUM( x**2 ) )

    A => TotMatrix % SubMatrix(1,1) % Mat
    IF (isParallel) THEN
      A => A % ParMatrix % SplittedMatrix % InsideMatrix
      CALL IterSolver( A,x,b,&
          Solver,ndim=ndim,MatvecF=mvProc,PrecF=precProc,&
          DotF=AddrFunc(SParDotProd), NormF=AddrFunc(SParNorm))
      
      DO i=1,NoVar
        TotMatrix % SubMatrix(i,i) % Mat % ParMatrix % SplittedMatrix % &
            TmpXvec = x(poffset(i)+1:poffset(i+1))
      END DO
      
      DO i=1,NoVar
        CALL ParallelUpdateResult(TotMatrix % SubMatrix(i,i) % Mat, &
            x(offset(i)+1:offset(i+1)), r )
      END DO
    ELSE
      CALL IterSolver( A,x,b,&
          Solver,ndim=ndim,MatvecF=mvProc,PrecF=precProc )
    END IF
    
    CALL ListSetNameSpace(CHAR(namesp))
    Xnorm = SQRT( SUM( x**2) )
    
    MaxChange = 2*ABS(Xnorm-PrevXnorm)/(Xnorm+PrevXnorm)
    PrevXNorm = Xnorm
    
    DO i=1,NoVar
      TotMatrix % SubVector(i) % Var % Values(1:offset(i+1)-offset(i)) = & 
          x(offset(i)+1:offset(i+1))
    END DO
    TotMatrix % Offset => Offset
      
    ! Copy values back since for nontrivial block-matrix structure the
    ! components do not build the whole solution.
    !-----------------------------------------------------------------
    IF( TotMatrix % GotBlockStruct ) THEN
      SolverVar => CurrentModel % Solver % Variable

      BlockStruct => TotMatrix % BlockStruct
      l = SIZE(BlockStruct) 
      DO j=1,l
        k = BlockStruct(j)
        ia = COUNT( k == BlockStruct(1:l) ) 
        ib = COUNT( k == BlockStruct(1:j) )
        
        DO i=1,SIZE(x)/l
          SolverVar % Values(l*(i-1)+j) = &
              TotMatrix % SubVector(k) % Var % Values( ia*(i-1) + ib )
        END DO
      END DO
    END IF
    
  END SUBROUTINE BlockKrylovIter



!------------------------------------------------------------------------------
!> The FETI main routine: solve x from Ax=b using the F(inite) E(lement)
!> T(earing) and I(nterconnect) method.
!------------------------------------------------------------------------------
  SUBROUTINE BlockSolveInt(A,x,b,Solver)
    ! Just basic feti so far...
    ! -------------------------
!------------------------------------------------------------------------------
    TYPE(Matrix_t), POINTER :: A
    TYPE(Solver_t), TARGET :: Solver
    REAL(KIND=dp) :: x(:),b(:)
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: PSolver
    TYPE(Variable_t), POINTER :: Var, SolverVar
    INTEGER :: i,j,k,l,n,nd,NonLinIter,tests,NoTests,iter
    LOGICAL :: GotIt, GotIt2, BlockPrec, BlockGS
    INTEGER :: ColVar, RowVar, NoVar, BlockDofs

    REAL(KIND=dp) :: NonlinearTol, Norm, PrevNorm, Residual, PrevResidual, &
        TotNorm, MaxChange, alpha, beta, omega, rho, oldrho, s, r, PrevTotNorm, &
        Coeff
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName
    LOGICAL :: Robust, LinearSearch, ErrorReduced, IsProcedure, ScaleSystem,&
        ReuseMatrix, LS
    INTEGER, POINTER :: VarPerm(:)
    
    TYPE (Matrix_t), POINTER :: Amat, SolverMatrix
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: Params
    TYPE(Varying_string) :: namesp

    CALL Info('BlockSolver','---------------------------------------',Level=5)

    Params => Solver % Values
    Mesh => Solver % Mesh
    PSolver => Solver

    isParallel = ParEnv % PEs > 1
    
         
    ! Determine some parameters related to the block strategy
    !------------------------------------------------------------------------------
    BlockPrec = ListGetLogical( Params,'Block Preconditioner',GotIt)
    IF(.NOT. GotIt ) BlockPrec = .TRUE.
    BlockGS = ListGetLogical( Params,'Block Gauss-Seidel',GotIt)    


    BlockDofs = Solver % Variable % Dofs      
    CALL BlockInitMatrix( Solver, TotMatrix, BlockDofs )

    NoVar = TotMatrix % NoVar

    TotMatrix % Solver => Solver
    SolverMatrix => Solver % Matrix
    SolverVar => Solver % Variable
      
    CALL BlockPickMatrix( Solver, NoVar )
    CALL BlockPrecMatrix( Solver, Novar ) 
      
    IF (isParallel) THEN
      DO RowVar=1,NoVar
        DO ColVar=1,NoVar
          CALL ParallelActive( .TRUE.)
          Amat => TotMatrix % SubMatrix(RowVar,ColVar) % Mat
          Amat % Comm = MPI_COMM_WORLD
          Parenv % ActiveComm = Amat % Comm
          Solver % Variable => TotMatrix % SubVector(ColVar) % Var
          CALL ParallelInitMatrix(Solver,Amat)
          
          IF(ASSOCIATED(Amat % ParMatrix )) THEN
            Amat % ParMatrix % ParEnv % ActiveComm = &
                Amat % Comm
            ParEnv = Amat % ParMatrix % ParEnv
          END IF
        END DO
      END DO
    END IF
    
    !------------------------------------------------------------------------------
    ! Finally solve the system using 'outer: ' as the optional namespace
    ! for the linear system setting.
    !------------------------------------------------------------------------------          
      
    TotNorm = 0.0_dp
    MaxChange = 0.0_dp
    
    LS = ListGetNameSpace(namesp)
    CALL ListSetNameSpace('outer:')
    
    ! The case with one block is mainly for testing and developing features
    ! related to nonlinearity and assembly.
    !----------------------------------------------------------------------
    IF( NoVar == 1 ) THEN
      CALL Info('BlockSolver','Solving in standard manner',Level=6)
      
      Solver % Variable => TotMatrix % SubVector(1) % Var
      Solver % Matrix => TotMatrix % Submatrix(1,1) % Mat
      
!      TotNorm = DefaultSolve()
      MaxChange = Solver % Variable % NonlinChange 
      
    ELSE IF( BlockPrec ) THEN
      CALL Info('BlockSolver','Using block precontioning strategy',Level=6)        
      CALL BlockKrylovIter( Solver, MaxChange )
    ELSE
      Solver % Variable => TotMatrix % SubVector(1) % Var
      Solver % Matrix => TotMatrix % Submatrix(1,1) % Mat
      
      CALL Info('BlockSolver','Using block solution strategy',Level=6)
      CALL BlockStandardIter( Solver, MaxChange )
    END IF
    CALL ListSetNameSpace('')

    ! For legacy matrices do the backmapping 
    !------------------------------------------
    Solver % Matrix => SolverMatrix
    Solver % variable => SolverVar
       
    CALL Info('BlockSolver','All done')
    CALL Info('BlockSolver','-------------------------------------------------',Level=5)

  END SUBROUTINE BlockSolveInt


END MODULE BlockSolve


!------------------------------------------------------------------------------
!> Just a handle for SolveLinearSystem():
!------------------------------------------------------------------------------
SUBROUTINE BlockSolveExt(A,x,b,Solver)
!------------------------------------------------------------------------------
    USE BlockSolve

    TYPE(Matrix_t), POINTER :: A
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: x(:),b(:)
!------------------------------------------------------------------------------
    CALL BlockSolveInt(A,x,b,Solver)
!------------------------------------------------------------------------------
END SUBROUTINE BlockSolveExt
!------------------------------------------------------------------------------
