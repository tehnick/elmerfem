!/*****************************************************************************
! *
! *       Elmer, A Computational Fluid Dynamics Program.
! *
! *       Copyright 1st April 1995 -> , CSC - Scientific Computing Ltd, Findland.
! *
! *       All rights reserved. No part of this program may be used,
! *       reproduced or transmitted in any form or by any means
! *       without the written permission of CSC.
! *
! ****************************************************************************/
!
!  Solves the transient/steady state Reynolds Equation that is a dimensinally reduced form of 
!  the Stokes equation in the case of narrow channels. 
!
! *****************************************************************************
! *
! *                   Author: Peter Råback, Antti Pursula
! *
! *                 Address:  CSC - Scientific Computing Ltd.
! *                           Keilaranta 14, P.O. BOX 405
! *                           02101 Espoo, Finland
! *                           Tel. +358 0 457 2080
! *                           EMail: Peter.Raback@csc.fi
! *
! *              Original Date: 23.10.2007
! *
! *                Modified by: Peter Råback
! *
! *       Date of modification: 23.10.2007
! *
! ****************************************************************************/


SUBROUTINE ReynoldsSolver( Model,Solver,dt,TransientSimulation )
 !DEC$ATTRIBUTES DLLEXPORT :: ReynoldsSolver
!------------------------------------------------------------------------------

  USE DefUtils
  USE Types
  USE Lists
  USE Integration
  USE ElementDescription
  USE SolverUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Nodes_t) :: ElementNodes
  TYPE(Element_t),POINTER :: Element, Parent
  TYPE(ValueList_t), POINTER :: Material, Equation, BC 
  TYPE(Variable_t), POINTER :: VarTemp

  INTEGER, PARAMETER :: Compressibility_None = 1, Compressibility_Weak = 2, &
      Compressibility_GasIsothermal = 3, Compressibility_GasAdiabatic = 4
  INTEGER, PARAMETER :: Viscosity_Newtonian = 1, Viscosity_Rarefied = 2

  INTEGER :: iter, i, j, k, l, n, nd, t, istat, mat_id, eq_id, body_id, mat_idold, &
      NoIterations, ViscosityType, CompressibilityType, added, removed
  INTEGER, POINTER :: NodeIndexes(:), PressurePerm(:)

  LOGICAL, POINTER :: PeriodicNodes(:)
  LOGICAL :: GotIt, stat, AllocationsDone = .FALSE., SubroutineVisited = .FALSE., &
      UseVelocity, SideCorrection, Bubbles, PartIntSliding, Cavitation, Converged
  REAL(KIND=dp), POINTER :: Pressure(:), CavitationValues(:), LoadValues(:)
  REAL(KIND=dp) :: Norm, ReferencePressure, NonlinearTol, HeatRatio, BulkModulus, &
      mfp0, Pres, Dens, CavitationPressure
  REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), MASS(:,:), FORCE(:), TimeForce(:), &
      Viscosity(:), GapHeight(:), NormalVelocity(:), Velocity(:,:), &
      Admittance(:), Impedance(:), ElemPressure(:)

  CHARACTER(LEN=MAX_NAME_LEN) :: ViscosityModel, CompressibilityModel

  SAVE ElementNodes, Viscosity, GapHeight, Velocity, NormalVelocity, &
      Admittance, FORCE, STIFF, MASS, TimeForce, ElemPressure, AllocationsDone, &
      PeriodicNodes


  CALL Info('ReynoldsSolver','---------------------------------------',Level=5)
  IF(TransientSimulation) THEN
    CALL Info('ReynoldsSolver','Solving the transient Reynolds equation',Level=5)
  ELSE
    CALL Info('ReynoldsSolver','Solving the steady-state Reynolds equation',Level=5)    
  END IF
  CALL Info('ReynoldsSolver','---------------------------------------',Level=5)

!------------------------------------------------------------------------------
! Get variables needed for solution
!------------------------------------------------------------------------------

  Bubbles = GetLogical( Solver % Values, 'Bubbles', GotIt )
  PartIntSliding = GetLogical(Solver % Values,'Partial Integrate Sliding',GotIt)
  CavitationPressure = GetCReal(Solver % Values,'Cavitation Pressure',Cavitation)
  
  IF ( .NOT. ASSOCIATED( Solver % Matrix ) ) RETURN
  IF(Solver % Variable % Dofs /= 1) THEN
    CALL Fatal('ReynoldsSolver','Impossible number of dofs! (should be 1)')    
  END IF
  Pressure     => Solver % Variable % Values
  PressurePerm => Solver % Variable % Perm
  IF( COUNT( PressurePerm > 0 ) <= 0) RETURN

!------------------------------------------------------------------------------
! Do some initial stuff
!------------------------------------------------------------------------------

  SideCorrection = .FALSE.
  DO i=1,Model % NumberOfBCs
    stat = GetLogical(Model % BCs(i) % Values,'Open Side',gotIt) 
    IF(stat) SideCorrection = .TRUE.
  END DO

  NoIterations = GetInteger( Solver % Values,'Nonlinear System Max Iterations',GotIt)
  IF(.NOT. GotIt) NoIterations = 1
  NonlinearTol = GetCReal( Solver % Values,'Nonlinear System Convergence Tolerance',gotIt)
  
!------------------------------------------------------------------------------
! Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
  IF(Cavitation) THEN
    VarTemp => VariableGet( Model % Mesh % Variables, &
           GetVarName(Solver % Variable) // ' Cavitation' )
    IF (.NOT.ASSOCIATED(VarTemp)) THEN
      WRITE(Message,'(A)') TRIM(ComponentName(Solver % Variable)) // ' Cavitation: not associated'
      CALL FATAL('ReynoldsSolver', Message)
    END IF
    CavitationValues => VarTemp % Values

    ! Initialize this so that an uninitialized defult (zero) is not cavitation
    DO i=1,SIZE(CavitationValues) 
      IF( ABS(CavitationValues(i)) < 1.0d-20 ) CavitationValues(i) = -1.0
    END DO

    VarTemp => VariableGet( Model % Mesh % Variables, &
       GetVarName(Solver % Variable) // ' Loads' )
    IF (.NOT.ASSOCIATED(VarTemp)) THEN
      WRITE(Message,'(A)') GetVarName(Solver % Variable) // ' Loads: not associated'
      CALL FATAL('ReynoldsSolver', Message)
    END IF
    LoadValues => VarTemp % Values
  END IF


  IF ( .NOT. AllocationsDone  ) THEN
    N = Solver % Mesh % MaxElementNodes

    ALLOCATE(ElementNodes % x( N ),  &
        ElementNodes % y( N ),       &
        ElementNodes % z( N ),       &
        Viscosity( N ),              &
        GapHeight(N),          &
        Velocity(3,N),         &
        NormalVelocity(N),     &
        Admittance(N),         &
        FORCE( 2*N ),           &
        STIFF( 2*N, 2*N ), &
        MASS( 2*N, 2*N ), &
        TimeForce( 2*N ), &
        ElemPressure(N), &
        STAT=istat )
    IF ( istat /= 0 ) CALL FATAL('ReynoldsSolver','Memory allocation error')


    IF( Cavitation ) THEN
      ALLOCATE(PeriodicNodes(SIZE(Pressure)))
      PeriodicNodes = .FALSE.
      
      DO t=1, Solver % Mesh % NumberOfBoundaryElements
        Element => GetBoundaryElement(t)
        IF ( .NOT. ActiveBoundaryElement() ) CYCLE
        
        n  = GetElementNOFNodes()
        IF ( GetElementFamily() == 1 ) CYCLE
        
        IF ( ANY( PressurePerm(Element % NodeIndexes(1:n)) == 0 ) ) CYCLE
        
        BC => GetBC()
        IF ( ASSOCIATED( BC ) ) THEN    
          IF( GetLogical(BC,'Periodic BC ' // TRIM(ComponentName(Solver % Variable)),GotIt) ) THEN
            PeriodicNodes( PressurePerm(Element % NodeIndexes(1:n))) = .TRUE.
          END IF
        END IF
      END DO
    END IF

    AllocationsDone = .TRUE.
  END IF


!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
  
  mat_idold = 0

  CALL Info('ReynoldsSolver','-------------------------------------------------',Level=5)

  DO iter = 1,NoIterations

    WRITE(Message,'(A,T35,I5)') 'Reynolds iteration:',iter
    CALL Info('ReynoldsSolver',Message,Level=5)

    CALL DefaultInitialize()

!    Do the bulk assembly:
!    ---------------------

    DO t=1,Solver % NumberOfActiveElements

      Element => GetActiveElement(t)
      n  = GetElementNOFNodes()
      nd = GetElementNOFDOFs()
      
      CALL GetElementNodes( ElementNodes )
      CALL GetScalarLocalSolution( ElemPressure )


      body_id =  Element % Bodyid

      eq_id = ListGetInteger( Model % Bodies(body_id) % Values,'Equation')
      Equation => Model % Equations(eq_id) % Values

      Velocity(1,1:n) = GetReal(Equation,'Surface Velocity 1',UseVelocity)
      Velocity(2,1:n) = GetReal(Equation,'Surface Velocity 2',GotIt)
      UseVelocity = UseVelocity .OR. GotIt
      Velocity(3,1:n) = GetReal(Equation,'Surface Velocity 3',GotIt)
      UseVelocity = UseVelocity .OR. GotIt

      IF(.NOT. UseVelocity) THEN
        Velocity(1,1:n) = GetReal(Equation,'Tangent Velocity 1',GotIt) 
        Velocity(2,1:n) = GetReal(Equation,'Tangent Velocity 2',GotIt)
        Velocity(3,1:n) = GetReal(Equation,'Tangent Velocity 3',GotIt)
        NormalVelocity(1:n) = GetReal(Equation,'Normal Velocity',GotIt)
      END IF     

!------------------------------------------------------------------------------
!       Get material parameters
!------------------------------------------------------------------------------        
      mat_id = GetInteger( Model % Bodies( body_id ) % Values, 'Material')
      Material => Model % Materials(mat_id) % Values
      
      GapHeight(1:n) = GetReal( Material,'Gap Height')
      Viscosity(1:n) = GetReal( Material, 'Viscosity')
      Admittance(1:n) = GetReal( Material, 'Flow Admittance', GotIt)
      
      IF(mat_id /= mat_idold) THEN                  

        mat_idold = mat_id

        ViscosityModel = GetString(Material,'Viscosity Model',GotIt)
        IF(GotIt) THEN
          IF( ViscosityModel == 'newtonian') THEN
            ViscosityType = Viscosity_Newtonian
          ELSE IF( ViscosityModel == 'rarefied') THEN
            ViscosityType = Viscosity_Rarefied
            mfp0 = GetCReal(Material,'Mean Free Path')            
            ReferencePressure = GetCReal( Material,'Reference Pressure')           
          ELSE
            CALL Warn('ReynoldsSolver','Unknown viscosity model')
          END IF
        ELSE
          ViscosityType = Viscosity_Newtonian          
        END IF

        CompressibilityModel = GetString(Material,'Compressibility Model',GotIt)        
        IF(GotIt) THEN
          IF(CompressibilityModel == 'incompressible') THEN
            CompressibilityType = Compressibility_None
          ELSE IF(CompressibilityModel == 'weakly compressible') THEN
            CompressibilityType = Compressibility_Weak
            BulkModulus = GetCReal( Material, 'Bulk Modulus')
          ELSE IF(CompressibilityModel == 'isothermal ideal gas') THEN
            CompressibilityType = Compressibility_GasIsothermal
            ReferencePressure = GetCReal( Material,'Reference Pressure')           
          ELSE IF(CompressibilityModel == 'adiabatic ideal gas') THEN
            CompressibilityType = Compressibility_GasAdiabatic
            HeatRatio = GetCReal( Material, 'Specific Heat Ratio')
            ReferencePressure = GetCReal( Material,'Reference Pressure')                      
          ELSE
            CALL Warn('ReynoldsSolver','Unknown compressibility model')
          END IF
        ELSE          
          CompressibilityType = Compressibility_None
        END IF
      END IF

      STIFF = 0.0d0
      MASS = 0.0d0
      FORCE = 0.0d0
      
      CALL LocalMatrix(   MASS, STIFF, FORCE, Element, n, nd, ElementNodes) 
                    
!------------------------------------------------------------------------------
!  In time dependent simulation add mass matrix to stiff matrix
!------------------------------------------------------------------------------
      TimeForce  = 0.0_dp
      IF ( TransientSimulation ) THEN
        CALL Default1stOrderTime( MASS,STIFF,FORCE)
      END IF

!------------------------------------------------------------------------------
!  Update global matrices from local matrices
!------------------------------------------------------------------------------
      IF (  Bubbles ) THEN
        CALL Condensate( N, STIFF, FORCE, TimeForce )
      END IF

      CALL DefaultUpdateEquations( STIFF, FORCE, BulkUpdate = Cavitation )

!------------------------------------------------------------------------------
    END DO 
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!    Neumann & Newton BCs:
!------------------------------------------------------------------------------

    IF(SideCorrection) THEN
          
     DO t=1, Solver % Mesh % NumberOfBoundaryElements
        Element => GetBoundaryElement(t)
        IF ( .NOT. ActiveBoundaryElement() ) CYCLE

        n  = GetElementNOFNodes()
        nd = GetElementNOFDOFs()
        IF ( GetElementFamily() == 1 ) CYCLE

        BC => GetBC()
        IF ( .NOT. ASSOCIATED( BC ) ) CYCLE

        stat = GetLogical(BC,'Open Side',gotIt) 
        IF(.NOT. stat) CYCLE
!------------------------------------------------------------------------------
        NodeIndexes => Element % NodeIndexes
          
        IF ( ANY( PressurePerm(NodeIndexes(1:n)) == 0 ) ) CYCLE
        
        Parent => Element % BoundaryInfo % Left
        stat = ASSOCIATED( Parent )
        IF ( stat ) stat = stat .AND. ALL(PressurePerm(Parent % NodeIndexes) > 0)
        
        IF(.NOT. stat) THEN
          Parent => ELement % BoundaryInfo % Right            
          stat = ASSOCIATED( Parent )
          IF ( stat ) stat = stat .AND. ALL(PressurePerm(Parent % NodeIndexes) > 0)
          IF ( .NOT. stat )  CALL Fatal( 'ReynoldsSolver', &
              'No proper parent element available for specified boundary' )
        END IF
        
        Model % CurrentElement => Parent
        CALL GetElementNodes( ElementNodes )

        mat_id = GetInteger( Model % Bodies(Parent % BodyId) % Values,'Material')
        Material => Model % Materials(mat_id) % Values
        
        GapHeight(1:n) = GetReal(Material,'Gap Height')
        Viscosity(1:n) = GetReal( Material, 'Viscosity')
        
        STIFF = 0.0d0
        MASS = 0.0d0
        FORCE = 0.0d0
          
!------------------------------------------------------------------------------
!             Get element local matrix and rhs vector
!------------------------------------------------------------------------------

        CALL LocalBoundary( MASS, STIFF, FORCE, Element, n, ElementNodes )
                    
!------------------------------------------------------------------------------
!             Update global matrix and rhs vector from local matrix & vector
!------------------------------------------------------------------------------
        IF ( TransientSimulation ) THEN
          MASS = 0.d0
          CALL Default1stOrderTime( MASS, STIFF, FORCE )
        END IF
        
        CALL DefaultUpdateEquations( STIFF, FORCE, BulkUpdate = Cavitation )

!------------------------------------------------------------------------------
      END DO
!------------------------------------------------------------------------------
    END IF


    CALL DefaultFinishAssembly()
    CALL DefaultDirichletBCs()
    CALL Info( 'ReynoldsSolver', 'Dirichlet conditions done', Level=4 )

!    Solve the system and we are done:
!    ---------------------------------

    Norm = DefaultSolve()

    added = 0
    removed = 0
    IF(Cavitation) THEN
      DO i=1,SIZE(Pressure)
        IF( PeriodicNodes(i)) THEN
          CavitationValues(i) = -1.0
        ELSE IF( CavitationValues(i) > 0.0 ) THEN
          IF( LoadValues(i) > 1.0d-20 ) THEN
            removed = removed + 1
            CavitationValues(i) = -1.0
          END IF
        ELSE
          IF( Pressure(i) < CavitationPressure - 1.0d-6) THEN
            added = added + 1
            CavitationValues(i) = 1.0
          END IF
        END IF
      END DO

      IF(added > 0) THEN
        WRITE(Message,'(A,I7,A)') 'Added',added,' nodes from the cavitation set'
        CALL Info('ReynoldsSolver',Message,Level=5)
      END IF
      IF(removed > 0) THEN
        WRITE(Message,'(A,I5,A)') 'Removed',removed,' nodes from the cavitation set'
        CALL Info('ReynoldsSolver',Message,Level=5)
      END IF      

    END IF

    Converged = (Solver % Variable % NonlinChange < NonlinearTol)
    IF( Converged .AND. (added + removed <= GetInteger(Solver % Values,&
        'Cavitation Set Maximum Change',Stat)) ) EXIT
  END DO
  
  CALL Info('ReynoldsSolver','-------------------------------------------------',Level=5)
  
CONTAINS



!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix(MassMatrix, StiffMatrix, ForceVector, Element, n, nd, Nodes)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: MassMatrix(:,:), StiffMatrix(:,:), ForceVector(:)
    INTEGER :: n, nd
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3), SqrtElementMetric
    REAL(KIND=dp) :: x,y,z,Metric(3,3),SqrtMetric,Symb(3,3,3),dSymb(3,3,3,3)
    REAL(KIND=dp) :: U, V, W, S, MS, MM, L, A, B, HR, SL(3), SLR, SLL(3)
    REAL(KIND=dp) :: Normal(3), Velo(3), NormalVelo, TangentVelo(3), Damp, Pres, TotPres, Gap, &
        Visc, mfp, Kn, Density, DensityDer
    LOGICAL :: Stat
    INTEGER :: i,p,q,t,DIM, NBasis, CoordSys
    TYPE(GaussIntegrationPoints_t) :: IntegStuff

!------------------------------------------------------------------------------
    DIM = CoordinateSystemDimension()
    CoordSys = CurrentCoordinateSystem()

    Metric = 0.0d0
    Metric(1,1) = 1.0d0
    Metric(2,2) = 1.0d0
    Metric(3,3) = 1.0d0

!------------------------------------------------------------------------------
!   Numerical integration
!------------------------------------------------------------------------------

    NBasis = n
    IF ( Bubbles ) THEN
      NBasis = 2*n
      IntegStuff = GaussPoints( Element, Element % TYPE % GaussPoints2 )
    ELSE
      NBasis = nd
      IntegStuff = GaussPoints( Element )
    END IF

!------------------------------------------------------------------------------
    DO t=1,IntegStuff % n

      U = IntegStuff % u(t)
      V = IntegStuff % v(t)
      W = IntegStuff % w(t)
      S = IntegStuff % s(t)

!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element, Nodes, U, V, W, SqrtElementMetric, &
          Basis, dBasisdx, Bubbles = Bubbles)
    
      s = s * SqrtElementMetric
      IF ( CoordSys /= Cartesian ) THEN
        X = SUM( Nodes % X(1:n) * Basis(1:n) )
        Y = SUM( Nodes % Y(1:n) * Basis(1:n) )
        Z = SUM( Nodes % Z(1:n) * Basis(1:n) )
        CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,X,Y,Z )
        s = s * SqrtMetric
      END IF

!------------------------------------------------------------------------------
!      Parameters at integration point
!------------------------------------------------------------------------------

      IF(UseVelocity) THEN
        IF( ASSOCIATED( Element % BoundaryInfo)) THEN
          Normal = NormalVector( Element,Nodes,u,v,.TRUE. )
        ELSE
          Normal = NormalVector( Element,Nodes,u,v,.FALSE. )
        END IF
        DO i=1,3
          Velo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
        END DO
        NormalVelo = SUM( Normal * Velo)
        TangentVelo = Velo - NormalVelo * Normal
      ELSE
        NormalVelo = SUM( Basis(1:n) * NormalVelocity(1:n) )
        DO i=1,3
          TangentVelo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
        END DO
      END IF

      Damp = SUM(Basis(1:n) * Admittance(1:n))
      Pres = SUM(Basis(1:n) * ElemPressure(1:n))
      Gap = SUM(Basis(1:n) * GapHeight(1:n))
      TotPres = ReferencePressure + Pres

!------------------------------------------------------------------------------
!  Different material models. The "density" is used only as a functional form,
!  not as absolute value.
!------------------------------------------------------------------------------

      SELECT CASE (ViscosityType)

      CASE (Viscosity_Newtonian)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
       
      CASE (Viscosity_Rarefied)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
        mfp = mfp0 * ReferencePressure / TotPres
        Kn = mfp / ABS(Gap)
        Visc = Visc / (1+9.638_dp*Kn**1.159_dp)

      END SELECT

!------------------------------------------------------------------------------

      SELECT CASE (CompressibilityType) 

      CASE (Compressibility_None)
        Density = 1.0d0
        DensityDer = 0.0d0
        
      CASE (Compressibility_Weak)
        Density = EXP(TotPres/BulkModulus)
        DensityDer = Density / BulkModulus
        
      CASE (Compressibility_GasIsothermal)         
        Density = TotPres 
        DensityDer = 1.0d0
        
      CASE(Compressibility_GasAdiabatic) 
        Density = TotPres ** (1.0_dp/HeatRatio)
        DensityDer = (1/HeatRatio) * TotPres ** (1.0_dp/HeatRatio - 1.0_dp)
        
      END SELECT
      
!------------------------------------------------------------------------------
!  Coefficients of the differential equation at integration point
!------------------------------------------------------------------------------

      ! Multipliers of p: Stiffness matrix 
      MS = -Density * Gap**3 / (12 * Visc)
      HR = -Damp * Density

      ! Multipliers of dp/dt: Mass matrix 
      MM = -DensityDer * Gap
      
      ! right-hand-side: Force vector 
      L = Density * NormalVelo

      ! tangential velocity part of rhs. This is integrated by parts for simplicity.
      SL = 0.0d0
      SLR = 0.0d0
      SLL = 0.0d0

      IF(PartIntSliding) THEN
        SL = -0.5_dp * Density * Gap * TangentVelo 
      ELSE
        DO i=1,dim
           ! The plane element automatically omits the derivative in normal direction
           SLR = SLR + 0.5_dp * Density * SUM( dBasisdx(1:n,i) * Velocity(i,1:n) * GapHeight(1:n)) 
        END DO
         ! Implicit part: coefficient of the pressure gradient
        SLL = -0.5_dp* DensityDer * Gap * Velo 
      END IF

!------------------------------------------------------------------------------
!      The Reynolds equation
!------------------------------------------------------------------------------
      DO p=1,NBasis
        DO q=1,NBasis
          A = HR * Basis(q) * Basis(p) 
          B = MM * Basis(q) * Basis(p)
          
          DO i=1,DIM
            DO j=1,DIM
              A = A + MS * Metric(i,j) * dBasisdx(q,i) * dBasisdx(p,j)
              A = A + SLL(j) * Metric(i,j) * dBasisdx(q,i) * Basis(p)
            END DO
          END DO
          
          StiffMatrix(p,q) = StiffMatrix(p,q) + s * A 
          MassMatrix(p,q)  = MassMatrix(p,q)  + s * B
        END DO
        
        ForceVector(p) = ForceVector(p) + s * Basis(p) * L
        ForceVector(p) = ForceVector(p) + s * Basis(p) * SLR         

        DO i=1,DIM
          ForceVector(p) = ForceVector(p) + s * dBasisdx(p,i) * SL(i)         
        END DO
        
      END DO
    END DO

!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE LocalBoundary(MassMatrix, StiffMatrix, ForceVector, Element, n, Nodes)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: MassMatrix(:,:), StiffMatrix(:,:), ForceVector(:)
    INTEGER :: n
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    COMPLEX(KIND=dp) :: Impedance 
    REAL(KIND=dp) :: SqrtElementMetric,U,V,W,S
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),X,Y,Z
    REAL(KIND=dp) :: Visc, dl, mfp, Kn, Damp, TotPres, Pres, Density, Gap, A
    LOGICAL :: Stat
    INTEGER :: i,p,q,t,DIM,CoordSys
    TYPE(GaussIntegrationPoints_t) :: IntegStuff
!------------------------------------------------------------------------------
    DIM = CoordinateSystemDimension()
    CoordSys = CurrentCoordinateSystem()

!------------------------------------------------------------------------------
!   Numerical integration
!------------------------------------------------------------------------------
    IntegStuff = GaussPoints( Element )
!------------------------------------------------------------------------------
    DO t=1,IntegStuff % n
      U = IntegStuff % u(t)
      V = IntegStuff % v(t)
      W = IntegStuff % w(t)
      S = IntegStuff % s(t)
!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element, Nodes, U, V, W, SqrtElementMetric, &
          Basis, dBasisdx )
      
      s = s * SqrtElementMetric
      
      Gap = SUM( GapHeight(1:n) * Basis(1:n) )
      Pres = SUM( ElemPressure(1:n) * Basis(1:n))
      TotPres = ReferencePressure + Pres
      
      SELECT CASE (ViscosityType)
        
      CASE (Viscosity_Newtonian)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
        dl = 0.8488_dp
        
      CASE (Viscosity_Rarefied)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
        mfp = mfp0 * ReferencePressure / TotPres
        Kn = mfp / ABS(Gap)
        Visc = Visc / (1+9.638_dp*Kn**1.159_dp)
        dl = 0.8488_dp*(1+2.676_dp*Kn**0.659_dp)
      END SELECT
      
      Damp = Gap / (12 * dl * Visc)
      
!------------------------------------------------------------------------------
       
      SELECT CASE (CompressibilityType) 
        
      CASE (Compressibility_None)
        Density = 1.0d0
        
      CASE (Compressibility_Weak)
        Density = EXP(Pres/BulkModulus)
        
      CASE (Compressibility_GasIsothermal)         
        Density = TotPres 
        
      CASE(Compressibility_GasAdiabatic) 
        Density = TotPres ** (1.0/HeatRatio)
        
      END SELECT

!------------------------------------------------------------------------------       
       A = -Damp * Gap * Density
!------------------------------------------------------------------------------
       DO p=1,n
         DO q=1,n
           StiffMatrix(p,q) = StiffMatrix(p,q) + s * Basis(q) * Basis(p) * A
         END DO
       END DO
!------------------------------------------------------------------------------
     END DO
!------------------------------------------------------------------------------
   END SUBROUTINE LocalBoundary
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
END SUBROUTINE ReynoldsSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ReynoldsHeatingSolver_Init( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
    USE DefUtils

    TYPE(Model_t)  :: Model
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: DT
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: SolverParams
    INTEGER :: dim
!------------------------------------------------------------------------------
    SolverParams => GetSolverParams()
    dim = CoordinateSystemDimension()

    IF ( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
      CALL ListAddInteger( SolverParams, 'Variable DOFs', 1 )
      CALL ListAddString( SolverParams, 'Variable','Film Heating' )
    END IF
    CALL ListAddInteger( SolverParams, 'Time derivative order', 0 )

    ! Add linear system defaults: cg+diagonal
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Solver')) &
      CALL ListAddString(SolverParams,'Linear System Solver','Iterative')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Iterative Method')) &
      CALL ListAddString(SolverParams,'Linear System Iterative Method','cg')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Preconditioning')) &
      CALL ListAddString(SolverParams,'Linear System Preconditioning','diagonal')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Max Iterations')) &
      CALL ListAddInteger(SolverParams,'Linear System Max Iterations',500)
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Residual Output')) &
      CALL ListAddInteger(SolverParams,'Linear System Residual Output',10)
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Convergence Tolerance')) &
      CALL ListAddConstReal(SolverParams,'Linear System Convergence Tolerance',1.0e-10_dp)

!------------------------------------------------------------------------------
  END SUBROUTINE ReynoldsHeatingSolver_Init
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
SUBROUTINE ReynoldsHeatingSolver( Model,Solver,dt,TransientSimulation )
 !DEC$ATTRIBUTES DLLEXPORT :: ReynoldsHeatingSolver
!------------------------------------------------------------------------------

  USE DefUtils
  USE Types
  USE Lists
  USE Integration
  USE ElementDescription
  USE SolverUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  TYPE(Variable_t), POINTER :: PressureVar
  TYPE(Nodes_t) :: ElementNodes
  TYPE(Element_t),POINTER :: Element, Parent
  TYPE(ValueList_t), POINTER :: Material

  INTEGER, PARAMETER :: Viscosity_Newtonian = 1, Viscosity_Rarefied = 2

  INTEGER :: iter, i, j, k, l, n, nd, t, istat, mat_id, mat_idold, ViscosityType
  INTEGER, POINTER :: NodeIndexes(:), PressurePerm(:)

  LOGICAL :: GotIt, stat, UseVelocity, AllocationsDone = .FALSE.

  REAL(KIND=dp), POINTER :: Pressure(:)
  REAL(KIND=dp) :: Norm, ReferencePressure, mfp0, HeatSlide, HeatPres, HeatTotal, &
      Pforce(3), Vforce(3), TotForce
  REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:), Viscosity(:), GapHeight(:), &
      Velocity(:,:), ElemPressure(:)
  CHARACTER(LEN=MAX_NAME_LEN) :: ViscosityModel, PressureName


  SAVE ElementNodes, Viscosity, Velocity, &
      GapHeight, FORCE, STIFF, ElemPressure, AllocationsDone

 
!------------------------------------------------------------------------------
!    Check if version number output is requested
!------------------------------------------------------------------------------

  CALL Info('ReynoldsHeatingSolver','------------------------------------------------',Level=5)
  CALL Info('ReynoldsHeatingSolver','Solving for viscous heating of Reynolds equation',Level=5)
  CALL Info('ReynoldsHeatingSolver','------------------------------------------------',Level=5)

!------------------------------------------------------------------------------
! Get variables needed for solution
!------------------------------------------------------------------------------

  IF ( .NOT. ASSOCIATED( Solver % Matrix ) ) RETURN
  IF(Solver % Variable % Dofs /= 1) THEN
    CALL Fatal('ReynoldsHeatingSolver','Impossible number of dofs! (should be 1)')    
  END IF

  PressureName = GetString(Solver % Values,'Reynolds Pressure Variable Name',GotIt)
  IF(.NOT. GotIt) PressureName = 'FilmPressure'

  PressureVar => VariableGet( Solver % Mesh % Variables, PressureName)
  IF(.NOT. ASSOCIATED(PressureVar)) THEN
    CALL Warn('ReynoldsHeatingSolver','Could not get variable: '//TRIM(PressureName))
    RETURN
  END IF

  Pressure => PressureVar % Values
  PressurePerm => PressureVar % Perm
  IF( COUNT( PressurePerm > 0 ) <= 0) RETURN
  
!------------------------------------------------------------------------------
! Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
  IF ( .NOT. AllocationsDone  ) THEN
    N = Solver % Mesh % MaxElementNodes

    ALLOCATE(ElementNodes % x( N ),  &
        ElementNodes % y( N ),       &
        ElementNodes % z( N ),       &
        Viscosity( N ),              &
        GapHeight(N),          &
        Velocity(3,N),         &
        FORCE( N ),           &
        STIFF( N, N ), &
        ElemPressure(N), &
        STAT=istat )

    IF ( istat /= 0 ) CALL FATAL('ReynoldsHeatingSolver','Memory allocation error')    
    AllocationsDone = .TRUE.
  END IF 

!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
  
  mat_idold = 0
  HeatSlide = 0.0d0
  HeatPres = 0.0d0
  Pforce = 0.0d0
  Vforce = 0.0d0

  CALL DefaultInitialize()

!    Do the bulk assembly:
!    ---------------------

  DO t=1,Solver % NumberOfActiveElements
    
    Element => GetActiveElement(t)
    n  = GetElementNOFNodes()
    nd = GetElementNOFDOFs()
    
    CALL GetElementNodes( ElementNodes )

    NodeIndexes => Element % NodeIndexes         
    ElemPressure(1:n) = Pressure(PressurePerm(NodeIndexes(1:n)))
      
!------------------------------------------------------------------------------
!       Get material parameters
!------------------------------------------------------------------------------        
    mat_id = GetInteger( Model % Bodies( Element % Bodyid ) % Values, 'Material')
    Material => Model % Materials(mat_id) % Values
    
    GapHeight(1:n) = GetReal(Material,'Gap Height')
    Viscosity(1:n) = GetReal( Material, 'Viscosity')

    Velocity(1,1:n) = GetReal(Material,'Surface Velocity 1',UseVelocity)
    Velocity(2,1:n) = GetReal(Material,'Surface Velocity 2',GotIt)
    UseVelocity = UseVelocity .OR. GotIt
    Velocity(3,1:n) = GetReal(Material,'Surface Velocity 3',GotIt)
    UseVelocity = UseVelocity .OR. GotIt
    
    IF(.NOT. UseVelocity) THEN
      Velocity(1,1:n) = GetReal(Material,'Tangent Velocity 1',GotIt) 
      Velocity(2,1:n) = GetReal(Material,'Tangent Velocity 2',GotIt)
      Velocity(3,1:n) = GetReal(Material,'Tangent Velocity 3',GotIt)
    END IF
    
    IF(mat_id /= mat_idold) THEN                  
      
      mat_idold = mat_id
      
      ViscosityModel = GetString(Material,'Viscosity Model',GotIt)
      IF(GotIt) THEN
        IF( ViscosityModel == 'newtonian') THEN
          ViscosityType = Viscosity_Newtonian
        ELSE IF( ViscosityModel == 'rarefied') THEN
          ViscosityType = Viscosity_Rarefied
          mfp0 = GetCReal(Material,'Mean Free Path')            
          ReferencePressure = GetCReal( Material,'Reference Pressure')           
        ELSE
          CALL Warn('ReynoldsHeatingSolver','Unknown viscosity model')
        END IF
      ELSE
        ViscosityType = Viscosity_Newtonian          
      END IF
    END IF
    
    STIFF = 0.0d0
    FORCE = 0.0d0
    
    CALL LocalMatrix( STIFF, FORCE, Element, n, nd, ElementNodes) 
    CALL DefaultUpdateEquations( STIFF, FORCE )
  END DO
    
!------------------------------------------------------------------------------

  CALL DefaultFinishAssembly()

!    Solve the system and we are done:
!    ---------------------------------

 
  Norm = DefaultSolve()
  
  HeatTotal = HeatPres + HeatSlide
  WRITE(Message,'(A,T35,ES15.4)') 'Pressure heating (W): ',HeatPres
  CALL Info('ReynoldsHeatingSolver',Message,Level=5)
  WRITE(Message,'(A,T35,ES15.4)') 'Sliding heating (W): ',HeatSlide
  CALL Info('ReynoldsHeatingSolver',Message,Level=5)
  WRITE(Message,'(A,T35,ES15.4)') 'Reynolds heating (W): ',HeatTotal
  CALL Info('ReynoldsHeatingSolver',Message,Level=5)

  TotForce = SQRT( SUM((Pforce + Vforce)**2) )
  DO i=1,3
    IF(Pforce(i) > 1.0e-6 * TotForce) THEN
      WRITE(Message,'(A,I1,A,T35,ES15.4)') 'Pressure force ',i,' (N):',Pforce(i)
      CALL Info('ReynoldsHeatingSolver',Message,Level=5)
    END IF
    IF(Vforce(i) > 1.0e-6 * TotForce) THEN
      WRITE(Message,'(A,I1,A,T35,ES15.4)') 'Sliding force ',i,' (N):',Vforce(i)
      CALL Info('ReynoldsHeatingSolver',Message,Level=5)
    END IF
  END DO

  CALL ListAddConstReal( Model % Simulation,'res: Reynolds heating',HeatTotal)
  CALL ListAddConstReal( Model % Simulation,'res: Reynolds force',TotForce)

  CALL Info('ReynoldsHeatingSolver','-------------------------------------------------',Level=5)
  
CONTAINS



!------------------------------------------------------------------------------
  SUBROUTINE LocalMatrix(StiffMatrix, ForceVector, Element, n, nd, Nodes)
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: StiffMatrix(:,:), ForceVector(:)
    INTEGER :: n, nd
    TYPE(Nodes_t) :: Nodes
    TYPE(Element_t), POINTER :: Element
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3), SqrtElementMetric
    REAL(KIND=dp) :: x,y,z,Metric(3,3),SqrtMetric,Symb(3,3,3),dSymb(3,3,3,3)
    REAL(KIND=dp) :: U, V, W, S, A, LV, LS
    REAL(KIND=dp) :: Normal(3), Velo(3), TangentVelo(3), Pres, Gap, GradPres(3), &
        Visc, mfp, Kn, TotPres
    LOGICAL :: Stat
    INTEGER :: i,p,q,t,DIM, NBasis, CoordSys
    TYPE(GaussIntegrationPoints_t) :: IntegStuff

!------------------------------------------------------------------------------
    DIM = CoordinateSystemDimension()
    CoordSys = CurrentCoordinateSystem()

    Metric = 0.0d0
    Metric(1,1) = 1.0d0
    Metric(2,2) = 1.0d0
    Metric(3,3) = 1.0d0

!------------------------------------------------------------------------------
!   Numerical integration
!------------------------------------------------------------------------------

    NBasis = nd
    IntegStuff = GaussPoints( Element )

!------------------------------------------------------------------------------
    DO t=1,IntegStuff % n

      U = IntegStuff % u(t)
      V = IntegStuff % v(t)
      W = IntegStuff % w(t)
      S = IntegStuff % s(t)

!------------------------------------------------------------------------------
!      Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
      stat = ElementInfo( Element, Nodes, U, V, W, SqrtElementMetric, &
          Basis, dBasisdx)
    
      s = s * SqrtElementMetric
      IF ( CoordSys /= Cartesian ) THEN
        X = SUM( Nodes % X(1:n) * Basis(1:n) )
        Y = SUM( Nodes % Y(1:n) * Basis(1:n) )
        Z = SUM( Nodes % Z(1:n) * Basis(1:n) )
        CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,X,Y,Z )
        s = s * SqrtMetric
      END IF

!------------------------------------------------------------------------------
!      Parameters at integration point
!------------------------------------------------------------------------------

      IF(UseVelocity) THEN
        IF( ASSOCIATED( Element % BoundaryInfo)) THEN
          Normal = NormalVector( Element,Nodes,u,v,.TRUE. )
        ELSE
          Normal = NormalVector( Element,Nodes,u,v,.FALSE. )
        END IF
        DO i=1,3
          Velo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
        END DO
        TangentVelo = Velo - SUM(Normal * Velo) * Normal
      ELSE
         DO i=1,3
          TangentVelo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
        END DO
      END IF

      Pres = SUM(Basis(1:n) * ElemPressure(1:n))
      TotPres = ReferencePressure + Pres
      Gap = SUM(Basis(1:n) * GapHeight(1:n))
      DO i=1,dim
        GradPres(i) = SUM(dBasisdx(1:n,i) * ElemPressure(1:n))
      END DO

!------------------------------------------------------------------------------
!  Different viscosity models. Should be consistant with the main solver.
!------------------------------------------------------------------------------

      SELECT CASE (ViscosityType)

      CASE (Viscosity_Newtonian)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
       
      CASE (Viscosity_Rarefied)
        Visc = SUM(Basis(1:n) * Viscosity(1:n))
        mfp = mfp0 * ReferencePressure / TotPres
        Kn = mfp / ABS(Gap)
        Visc = Visc / (1+9.638_dp*Kn**1.159_dp)

      END SELECT
      
!------------------------------------------------------------------------------
!  Coefficients of the differential equation at integration point
!------------------------------------------------------------------------------
      
      ! heating effect of pressure flow
      LV = (Gap**3 / (12 * Visc) ) * SUM(GradPres(1:dim)*GradPres(1:dim))
      HeatPres = HeatPres + s * LV

      ! effect of sliding
      LS = (Visc / Gap) * SUM(TangentVelo(1:dim) * TangentVelo(1:dim)) 
      HeatSlide = HeatSlide + s * LS

      Pforce = Pforce + s * Pres * Normal
      Vforce = Vforce + s * Visc * TangentVelo / Gap

      DO p=1,NBasis
        DO q=1,NBasis
          A = Basis(q) * Basis(p)           
          StiffMatrix(p,q) = StiffMatrix(p,q) + s * A 
        END DO
        
        ForceVector(p) = ForceVector(p) + s * Basis(p) * (LV + LS)
      END DO
    END DO

!------------------------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
END SUBROUTINE ReynoldsHeatingSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ReynoldsFluxSolver_Init( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
    USE DefUtils

    TYPE(Model_t)  :: Model
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: DT
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    TYPE(ValueList_t), POINTER :: SolverParams
    INTEGER :: dim
!------------------------------------------------------------------------------
    SolverParams => GetSolverParams()
    dim = CoordinateSystemDimension()

    IF ( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
      CALL ListAddInteger( SolverParams, 'Variable DOFs', 1 )
      CALL ListAddString( SolverParams, 'Variable','-nooutput flux_temp' )
      CALL ListAddString(SolverParams, 'Flux Result Variable','F')
      IF(dim == 2) THEN
         CALL ListAddString(SolverParams, 'Exported Variable 1','F[Film Flux:2]')
      ELSE IF(dim == 3) THEN
         CALL ListAddString(SolverParams, 'Exported Variable 1','F[Film Flux:3]')
      ELSE
         CALL Fatal('VortictySolver_init','Flux computation makes sense only in 2D and 3D')
      END IF
    END IF

    IF(.NOT. ListCheckPresent(SolverParams,'Flux Variable')) &
      CALL ListAddString(SolverParams,'Flux Variable','FilmPressure')

    CALL ListAddInteger( SolverParams, 'Time derivative order', 0 )

    ! Add linear system defaults: cg+diagonal
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Solver')) &
      CALL ListAddString(SolverParams,'Linear System Solver','Iterative')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Iterative Method')) &
      CALL ListAddString(SolverParams,'Linear System Iterative Method','cg')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Preconditioning')) &
      CALL ListAddString(SolverParams,'Linear System Preconditioning','diagonal')
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Max Iterations')) &
      CALL ListAddInteger(SolverParams,'Linear System Max Iterations',500)
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Residual Output')) &
      CALL ListAddInteger(SolverParams,'Linear System Residual Output',10)
    IF(.NOT. ListCheckPresent(SolverParams,'Linear System Convergence Tolerance')) &
      CALL ListAddConstReal(SolverParams,'Linear System Convergence Tolerance',1.0e-10_dp)

!------------------------------------------------------------------------------
  END SUBROUTINE ReynoldsFluxSolver_Init
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE ReynoldsFluxSolver( Model,Solver,dt,Transient )
    !DEC$ATTRIBUTES DLLEXPORT :: ReynoldsFluxSolver
!------------------------------------------------------------------------------

    USE CoordinateSystems
    USE DefUtils
    
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Model_t)  :: Model
    TYPE(Solver_t), TARGET :: Solver
    LOGICAL ::  Transient
    REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
    INTEGER, PARAMETER :: Viscosity_Newtonian = 1, Viscosity_Rarefied = 2
    TYPE(ValueList_t),POINTER :: SolverParams
    CHARACTER(LEN=MAX_NAME_LEN) :: VarName
    INTEGER :: i,j,dim,DOFs, ViscosityType
    LOGICAL :: ConstantBulkMatrix, ConstantBulkMatrixInUse, CSymmetry
    LOGICAL :: GotIt
    REAL(KIND=dp) :: Unorm, Totnorm
    REAL(KIND=dp), POINTER :: ForceVector(:,:), SaveRHS(:)
    REAL(KIND=dp) :: at0,at1,at2,CPUTime,RealTime
    TYPE(Variable_t), POINTER :: FluxSol
 
    CALL Info( 'ReynoldsFluxSolver', '-------------------------------------',Level=4 )
    CALL Info( 'ReynoldsFluxSolver','Computing the flux',Level=4 )
    CALL Info( 'ReynoldsFluxSolver', '-------------------------------------',Level=4 )
    
    dim = CoordinateSystemDimension()
!------------------------------------------------------------------------------
!    Get variables needed for solution
!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Solver % Matrix ) ) RETURN
    IF ( COUNT( Solver % Variable % Perm > 0 ) <= 0 ) RETURN
    
    SolverParams => GetSolverParams()
    VarName = GetString(SolverParams,'Flux Result Variable',GotIt )
    IF(.NOT. gotIt) VarName = 'Film Flux'
    FluxSol => VariableGet( Solver % Mesh % Variables, VarName )
    IF(ASSOCIATED(FluxSol)) THEN
       Dofs = FluxSol % DOFs
       IF(Dofs /= DIM) THEN
          CALL Fatal('ReynoldsFluxSolver','The flux should have DOFs equal to DIM')
       END IF
    ELSE
       CALL Fatal('ReynoldsFluxSolver','Flux Result Variable is missing: '//TRIM(VarName))      
    END IF
    
    CSymmetry = CurrentCoordinateSystem() == AxisSymmetric .OR. &
         CurrentCoordinateSystem() == CylindricSymmetric
 
    VarName = GetString(SolverParams,'Flux Variable')
    
    at0 = RealTime()
    
    ConstantBulkMatrix = GetLogical( SolverParams, 'Constant Bulk Matrix', GotIt )
    ConstantBulkMatrixInUse = ConstantBulkMatrix .AND. &
         ASSOCIATED(Solver % Matrix % BulkValues)
    
    IF ( ConstantBulkMatrixInUse ) THEN
       Solver % Matrix % Values = Solver % Matrix % BulkValues        
       Solver % Matrix % rhs = 0.0_dp
    ELSE
       CALL DefaultInitialize()
    END IF
    
    ALLOCATE(ForceVector(Dofs-1,SIZE(Solver % Matrix % RHS)))  
    ForceVector = 0.0_dp
    SaveRHS => Solver % Matrix % RHS
    
    CALL BulkAssembly()
    CALL DefaultFinishAssembly()
    
    at1 = RealTime()
    WRITE(Message,* ) 'Assembly Time: ',at1-at0
    CALL Info( 'ReynoldsFluxSolver', Message, Level=5 )

!------------------------------------------------------------------------------     

    TotNorm = 0.0_dp
    DO i=1,Dofs
       IF(i==1) THEN
          Solver % Matrix % RHS => SaveRHS
       ELSE
          Solver % Matrix % RHS => ForceVector(i-1,:)
       END IF
       
       ! The solution of the linear equation
       !------------------------------------
       UNorm = DefaultSolve()
       
       TotNorm = TotNorm + Unorm ** 2
       DO j=1,Solver % Matrix % NumberOfRows
          FluxSol % Values(DOFs*(j-1)+i) = Solver % Variable % Values(j)
       END DO
    END DO

    DEALLOCATE( ForceVector )  
    Solver % Matrix % RHS => SaveRHS
    TotNorm = SQRT(TotNorm)
    Solver % Variable % Norm = Totnorm

!------------------------------------------------------------------------------     

    at2 = RealTime()
    WRITE(Message,* ) 'Solution Time: ',at2-at1
    CALL Info( 'ReynoldsFluxSolver', Message, Level=5 )
    
    WRITE( Message, * ) 'Result Norm: ',TotNorm
    CALL Info( 'ReynoldsFluxSolver', Message, Level=4 )
    
    CALL Info('ReynoldsFluxSolver','-------------------------------------------------',Level=5)

    
  CONTAINS


!------------------------------------------------------------------------------
    SUBROUTINE BulkAssembly()
!------------------------------------------------------------------------------
       
      INTEGER :: istat,elem,t,i,j,p,q,n,nd,mat_idold,mat_id
      REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:,:)
      TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
      TYPE(Nodes_t) :: Nodes
      TYPE(Element_t), POINTER :: Element
      REAL(KIND=dp) :: u,v,w,weight,detJ,Normal(3)
      REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:)
      REAL(KIND=dp), ALLOCATABLE :: Viscosity(:), GapHeight(:), Velocity(:,:), ElemPressure(:)
      REAL(KIND=dp) :: ReferencePressure, HeatRatio, BulkModulus, Visc, &
           mfp0, mfp, Pres, Dens, Kn, LS, LV, Gap, TotPres, TangentVelo(3), Velo(3), GradPres(3)
      CHARACTER(LEN=MAX_NAME_LEN) :: ViscosityModel, PressureName
      LOGICAL :: Found, UseVelocity
      TYPE(ValueList_t), POINTER :: Material
      
      SAVE Nodes, Viscosity, Velocity, &
           GapHeight, FORCE, STIFF, ElemPressure


      n = MAX( Solver % Mesh % MaxElementDOFs, Solver % Mesh % MaxElementNodes )

      ALLOCATE( STIFF(n,n), &
           FORCE(dim,n), &
           Viscosity( N ),              &
           GapHeight(N),          &
           Velocity(3,N),         &
           ElemPressure(N), &
           Basis(n), &
           dBasisdx(n,3), &
           STAT=istat )
      
      DO elem = 1,Solver % NumberOFActiveElements
         
         ! Element information
         ! ---------------------
         Element => GetActiveElement(elem)
         CALL GetElementNodes( Nodes )
         nd = GetElementNOFDOFs()
         n  = GetElementNOFNodes()
         
         CALL GetScalarLocalSolution( ElemPressure, VarName )

      !------------------------------------------------------------------------------
      !       Get material parameters
      !------------------------------------------------------------------------------        
         mat_id = GetInteger( Model % Bodies( Element % Bodyid ) % Values, 'Material')
         Material => Model % Materials(mat_id) % Values
         
         GapHeight(1:n) = GetReal(Material,'Gap Height')
         Viscosity(1:n) = GetReal( Material, 'Viscosity')
         
         Velocity(1,1:n) = GetReal(Material,'Surface Velocity 1',UseVelocity)
         Velocity(2,1:n) = GetReal(Material,'Surface Velocity 2',GotIt)
         UseVelocity = UseVelocity .OR. GotIt
         Velocity(3,1:n) = GetReal(Material,'Surface Velocity 3',GotIt)
         UseVelocity = UseVelocity .OR. GotIt
         
         IF(.NOT. UseVelocity) THEN
            Velocity(1,1:n) = GetReal(Material,'Tangent Velocity 1',GotIt) 
            Velocity(2,1:n) = GetReal(Material,'Tangent Velocity 2',GotIt)
            Velocity(3,1:n) = GetReal(Material,'Tangent Velocity 3',GotIt)
         END IF
         
         IF(mat_id /= mat_idold) THEN                  
            
            mat_idold = mat_id
            
            ViscosityModel = GetString(Material,'Viscosity Model',GotIt)
            IF(GotIt) THEN
               IF( ViscosityModel == 'newtonian') THEN
                  ViscosityType = Viscosity_Newtonian
               ELSE IF( ViscosityModel == 'rarefied') THEN
                  ViscosityType = Viscosity_Rarefied
                  mfp0 = GetCReal(Material,'Mean Free Path')            
                  ReferencePressure = GetCReal( Material,'Reference Pressure')           
               ELSE
                  CALL Warn('ReynoldsHeatingSolver','Unknown viscosity model')
               END IF
            ELSE
               ViscosityType = Viscosity_Newtonian          
            END IF
         END IF
         
         ! Integrate local stresses:
         ! -------------------------
         IntegStuff = GaussPoints( Element )
         STIFF  = 0.0_dp
         FORCE  = 0.0_dp
         
         DO t=1,IntegStuff % n
            u = IntegStuff % u(t)
            v = IntegStuff % v(t)
            w = IntegStuff % w(t)

            Found = ElementInfo( Element, Nodes, u, v, w, detJ, Basis, dBasisdx )
            
            Weight = IntegStuff % s(t) * detJ
            IF ( CSymmetry ) Weight = Weight * SUM( Basis(1:n) * Nodes % x(1:n) )
            
            IF(UseVelocity) THEN
               IF( ASSOCIATED( Element % BoundaryInfo)) THEN
                  Normal = NormalVector( Element,Nodes,u,v,.TRUE. )
               ELSE
                  Normal = NormalVector( Element,Nodes,u,v,.FALSE. )
               END IF
               DO i=1,3
                  Velo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
               END DO
               TangentVelo = Velo - SUM(Normal * Velo) * Normal
            ELSE
               DO i=1,3
                  TangentVelo(i) = SUM( Basis(1:n) * Velocity(i,1:n) )
               END DO
            END IF
         
            Pres = SUM(Basis(1:n) * ElemPressure(1:n))
            TotPres = ReferencePressure + Pres
            Gap = SUM(Basis(1:n) * GapHeight(1:n))
            DO i=1,dim
               GradPres(i) = SUM(dBasisdx(1:n,i) * ElemPressure(1:n))
            END DO
        
!------------------------------------------------------------------------------
!  Different viscosity models. Should be consistant with the main solver.
!------------------------------------------------------------------------------

            SELECT CASE (ViscosityType)
               
            CASE (Viscosity_Newtonian)
               Visc = SUM(Basis(1:n) * Viscosity(1:n))
               
            CASE (Viscosity_Rarefied)
               Visc = SUM(Basis(1:n) * Viscosity(1:n))
               mfp = mfp0 * ReferencePressure / TotPres
               Kn = mfp / ABS(Gap)
               Visc = Visc / (1+9.638_dp*Kn**1.159_dp)
               
            END SELECT
            
!------------------------------------------------------------------------------
!  Coefficients of the mass matrix
!------------------------------------------------------------------------------

            IF ( .NOT. ConstantBulkMatrixInUse ) THEN
               DO p=1,nd
                  DO q=1,nd
                     STIFF(p,q) = STIFF(p,q) + Weight * Basis(q) * Basis(p)
                  END DO
               END DO
            END IF

!------------------------------------------------------------------------------
!  Coefficients of the flux
!------------------------------------------------------------------------------
          
            DO i=1,dim	
               ! heating effect of pressure flow
               LV = - (Gap**3 / (12 * Visc) ) * GradPres(i)
               
               ! effect of sliding
               LS = Gap * TangentVelo(i) / 2
               
               FORCE(i,1:nd) = FORCE(i,1:nd) + Weight * Basis(1:nd) * (LV + LS)
            END DO
            
         END DO

!------------------------------------------------------------------------------
!      Update global matrices from local matrices 
!------------------------------------------------------------------------------

         IF ( .NOT. ConstantBulkMatrixInUse ) THEN
            Solver % Matrix % RHS => SaveRHS
            CALL DefaultUpdateEquations( STIFF, FORCE(1,1:nd), &
                 BulkUpdate=ConstantBulkMatrix )
         ELSE
            CALL DefaultUpdateForce( FORCE(1,1:nd) )       
         END IF
     
         DO i=2,Dofs
            Solver % Matrix % RHS => ForceVector(i-1,:)
            CALL DefaultUpdateForce( FORCE(i,1:nd) )
         END DO
      END DO

      DEALLOCATE( Viscosity, Velocity, &
           GapHeight, FORCE, STIFF, ElemPressure, Basis, dBasisdx  )
      
!------------------------------------------------------------------------------
    END SUBROUTINE BulkAssembly
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
END SUBROUTINE ReynoldsFluxSolver
!------------------------------------------------------------------------------


