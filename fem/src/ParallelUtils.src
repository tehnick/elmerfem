!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Parallel solver utilities for *Solver - routines
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 02 Apr 2001
! *
! *****************************************************************************/

MODULE ParallelUtils

     USE SparIterSolve

     IMPLICIT NONE

CONTAINS

#define PARALLEL_FOR_REAL
!-------------------------------------------------------------------------------
  FUNCTION ParallelInit() RESULT ( ParallelEnv )
!-------------------------------------------------------------------------------
    TYPE (ParEnv_t), POINTER :: ParallelEnv
                                                                                                                               
#ifdef PARALLEL_FOR_REAL
    ParallelEnv => ParCommInit( )
#else
    ParEnv % MyPE = 0
    ParEnv % PEs  = 1
    ParallelEnv => ParEnv
#endif
!-------------------------------------------------------------------------------
  END FUNCTION ParallelInit
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
  SUBROUTINE ParallelFinalize()
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
    CALL ParEnvFinalize()
#endif
!-------------------------------------------------------------------------------
  END SUBROUTINE ParallelFinalize
!-------------------------------------------------------------------------------
                                                                                                                               
!--------------------------------'-----------------------------------------------
    SUBROUTINE ParallelInitMatrix( Solver, Matrix )
!-------------------------------------------------------------------------------
       TYPE(Solver_t) :: Solver
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
       TYPE(ParallelInfo_t), POINTER :: MatrixPI, MeshPI
       INTEGER :: i, j, k, l, m, n, DOFs
       LOGICAL :: DGSolver, Found
       TYPE(Mesh_t), POINTER :: Mesh
       TYPE(Element_t), POINTER :: Element
       TYPE(NeighbourList_t), POINTER :: MtrxN, MeshN
!-------------------------------------------------------------------------------

#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs <= 1 .OR. .NOT. ASSOCIATED(Solver % Matrix) ) RETURN
       Mesh => Solver % Mesh
       DOFs = Solver % Variable % DOFs
       n = SIZE(Solver % Variable % Perm)

       ALLOCATE( Matrix % Perm(DOFs*n), Matrix % InvPerm(DOFs*n)  )
       Matrix % Perm    = 0
       Matrix % INVPerm = 0

       DO i=1,n
          IF ( Solver % Variable % Perm(i) /= 0 )  THEN
             DO j=1,DOFs
                Matrix % Perm( (i-1)*DOFs+j ) = &
                   DOFs * (Solver % Variable % Perm(i)-1) + j
             END DO
          END IF
       END DO

       DO i=1,DOFs*n
          IF ( Matrix % Perm(i) /= 0 ) THEN
             Matrix % INVPerm(Matrix % Perm(i)) = i
          END IF
       END DO

       IF ( .NOT. Matrix % DGMatrix ) THEN
         n = Solver % Mesh % NumberOfNodes
         ALLOCATE( Matrix % ParallelInfo )
         ALLOCATE( Matrix % ParallelInfo % NeighbourList(DOFs*n) )
         CALL AllocateVector( Matrix % ParallelInfo % Interface, DOFs*n)
         CALL AllocateVector( Matrix % ParallelInfo % GlobalDOFs, DOFs*n)

         DO i=1,n
            DO j=1,DOFs
               k = (i-1)*DOFs+j
               Matrix % ParallelInfo % GlobalDOFs(k) = &
                 DOFs*(Solver % Mesh % ParallelInfo % GlobalDOFs(i)-1)+j
               Matrix % ParallelInfo % Interface(k) = &
                 Solver % Mesh % ParallelInfo % Interface(i)
               ALLOCATE( Matrix % ParallelInfo % NeighbourList(k) % Neighbours(SIZE( &
                    Solver % Mesh % ParallelInfo % NeighbourList(i) % Neighbours)) )
               Matrix % ParallelInfo % NeighbourList(k) % Neighbours = &
                 Solver % Mesh % ParallelInfo % NeighbourList(i) % Neighbours
            END DO
         END DO
       ELSE
         MeshPI => Solver % Mesh % ParallelInfo

         ALLOCATE( Matrix % ParallelInfo )
         MatrixPI => Matrix % ParallelInfo

         n = 0
         DO i=1,Mesh % NumberOfBulkElements
           Element => Mesh % Elements(i)
           IF ( .NOT. ASSOCIATED(Element % DGIndexes) ) CYCLE
           n = MAX(n,MAXVAL(Element % DGIndexes))
         END DO

         ALLOCATE( MatrixPI % GlobalDOFs(n) )

         DO i=1,Mesh % NumberOfBulkElements
           Element => Mesh % Elements(i)
           IF ( .NOT. ASSOCIATED(Element % DGIndexes) ) CYCLE
           DO j=1,SIZE(Element % DGIndexes)
             k = Element % DGIndexes(j)
             MatrixPI % GlobalDOFs(k) = 8*(Element % ElementIndex-1)+j
           END DO
         END DO
         ALLOCATE( MatrixPI % Interface(n), MatrixPI % NeighbourList(n) )

         MatrixPI % Interface = .FALSE.
         DO i=1,n
           MtrxN => MatrixPI % NeighbourList(i)
           MtrxN % Neighbours => NULL()
         END DO

         DO i=1,Mesh % NumberOfBulkElements
           Element => Mesh % Elements(i)
           IF ( .NOT. ASSOCIATED(Element % DGIndexes) ) CYCLE
           IF ( ALL(MeshPI % Interface(Element % NodeIndexes)) ) THEN
             DO j=1,Element % Type % NumberOfNodes
                K = Element % DGIndexes(j)
                L = Element % Nodeindexes(j)

                MeshN => MeshPI % NeighbourList(L)
                MtrxN => MatrixPI % NeighbourList(K)

                MatrixPI % Interface(k) = .TRUE.

                CALL AllocateVector( MtrxN % Neighbours, &
                      SIZE(MeshN % Neighbours) )
                MtrxN % Neighbours = MeshN % Neighbours
                DO m=1,SIZE(MeshN % Neighbours)
                 IF ( MeshN % Neighbours(m) == Element % PartIndex ) THEN
                   MtrxN % Neighbours(1) = MeshN % Neighbours(m)
                   MtrxN % Neighbours(m) = MeshN % Neighbours(1)
                   EXIT
                 END IF
                END DO
             END DO
           END IF
         END DO
         DO i=1,n
           MtrxN => MatrixPI % NeighbourList(i)
           IF ( .NOT.ASSOCIATED( MtrxN % Neighbours) ) THEN
             CALL AllocateVector(MtrxN % Neighbours,1)
             MtrxN % Neighbours(1) = ParEnv % myPE
           END IF
         END DO
       END IF

       Matrix % ParMatrix => &
          ParInitMatrix( Matrix, Matrix % ParallelInfo )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelInitMatrix
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelInitSolve( Matrix, x, b, r, Update )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: x(:), b(:), r(:)
       LOGICAL, OPTIONAL :: Update
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
       LOGICAL :: Upd
#ifdef PARALLEL_FOR_REAL
       Upd = .TRUE.
       IF ( PRESENT(Update) ) Upd=Update
       CALL SParInitSolve( Matrix, x, b, r, Matrix % ParallelInfo, Upd )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelInitSolve
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
    SUBROUTINE ParallelSumVector( Matrix, x )
!-------------------------------------------------------------------------------
       TYPE(Matrix_t) :: Matrix
       REAL(KIND=dp) :: x(:)
!-------------------------------------------------------------------------------

       GlobalData     => Matrix % ParMatrix
       ParEnv         =  GlobalData % ParEnv

       CALL ExchangeSourceVec( Matrix, Matrix % ParMatrix % SplittedMatrix, &
              Matrix % ParallelInfo, x )
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelSumVector
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelUpdateSolve( Matrix, x, r )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: x(:), r(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParUpdateSolve( Matrix, x, r )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelUpdateSolve
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelMatrixVector( Matrix, x, b, Update, UseMassVals )
!-------------------------------------------------------------------------------
      REAL(KIND=dp) :: x(:), b(:)
      LOGICAL, OPTIONAL :: Update, UseMassVals
      TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
      INTEGER :: i,ipar(1)
      REAL(KIND=dp), POINTER :: Mx(:), Mr(:), Mb(:), r(:)

      TYPE(SplittedMatrixT), POINTER :: SP
      TYPE(Matrix_t), POINTER :: SavePtrIF(:), SavePtrNB(:), SavePtrIN
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
      GlobalData => Matrix % ParMatrix
      IF ( PRESENT( Update ) ) THEN
         IF ( Update ) THEN
            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN

                  SP => GlobalData % SplittedMatrix
                  ALLOCATE( SavePtrIF( ParEnv % PEs ) )
                  ALLOCATE( SavePtrNB( ParEnv % PEs ) )
                  ALLOCATE( SavePtrIn )
                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                       SavePtrIF(i) % Values => SP % IfMatrix(i) % Values
                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                       SavePtrNB(i) % Values => SP % NbsIfMatrix(i) % Values
                  END DO
                  SavePtrIN % Values => SP % InsideMatrix % Values

                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                      SP % IfMatrix(i) % Values => SP % IfMatrix(i) % MassValues

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                       SP % NbsIfMatrix(i) % Values => SP % NbsIfMatrix(i) % MassValues 
                  END DO
                  SP % InsideMatrix % Values => SP % InsideMatrix % MassValues
               END IF

               Mx => GlobalData % SplittedMatrix % TmpXVec 
               Mr => GlobalData % SplittedMatrix % TmpRVec 
               CALL SParMatrixVector( Mx, Mr, ipar )
               CALL SParUpdateResult( Matrix, x, b, .FALSE. )
            ELSE
               Mx => GlobalData % SplittedMatrix % TmpXVec 
               Mr => GlobalData % SplittedMatrix % TmpRVec 
               CALL SParMatrixVector( Mx, Mr, ipar )
               CALL SParUpdateResult( Matrix, x, b, .FALSE. )
            END IF

            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN
                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                       SP % IfMatrix(i) % Values =>  SavePtrIF(i) % Values

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                       SP % NbsIfMatrix(i) % Values =>  SavePtrNB(i) % Values 
                  END DO
                  SP % InsideMatrix % Values => SavePtrIN % Values 
                  DEALLOCATE( SavePtrIF )
                  DEALLOCATE( SavePtrNB )
                  DEALLOCATE( SavePtrIn )
               END IF
            END IF
         ELSE
            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN
                  SP => Matrix % ParMatrix % SplittedMatrix
                  ALLOCATE( SavePtrIF( ParEnv % PEs ) )
                  ALLOCATE( SavePtrNB( ParEnv % PEs ) )
                  ALLOCATE( SavePtrIn )
                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                       SavePtrIF(i) % Values => SP % IfMatrix(i) % Values

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                       SavePtrNB(i) % Values => SP % NbsIfMatrix(i) % Values
                  END DO
                  SavePtrIN % Values => SP % InsideMatrix % Values

                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                       SP % IfMatrix(i) % Values => SP % IfMatrix(i) % MassValues

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                       SP % NbsIfMatrix(i) % Values => SP % NbsIfMatrix(i) % MassValues 
                  END DO
                  SP % InsideMatrix % Values => SP % InsideMatrix % MassValues
               END IF
            END IF

            CALL SParMatrixVector( x, b, ipar )

            IF ( PRESENT(UseMassVals) ) THEN
              IF ( UseMassVals ) THEN
                DO i=1,ParEnv % PEs
                  IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) &
                     SP % IfMatrix(i) % Values =>  SavePtrIF(i) % Values

                  IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) &
                     SP % NbsIfMatrix(i) % Values =>  SavePtrNB(i) % Values 
                END DO
                SP % InsideMatrix % Values => SavePtrIN % Values 
                DEALLOCATE( SavePtrIF )
                DEALLOCATE( SavePtrNB )
                DEALLOCATE( SavePtrIN )
              END IF
            END IF
         END IF
      ELSE
         CALL SParMatrixVector( x, b, ipar )
      END IF
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelMatrixVector
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelUpdateResult( Matrix, x, r )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: x(:), r(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParUpdateResult( Matrix, x, r, .TRUE. )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelUpdateResult
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelUpdateRHS( Matrix, b )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: b(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParUpdateRHS( Matrix, b, Matrix % ParallelInfo )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelUpdateRHS
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------

    FUNCTION ParallelMatrix( A,x,b,r ) RESULT(M)
!-------------------------------------------------------------------------------
       TYPE(Matrix_t), POINTER :: A, M
       REAL(KIND=dp),  POINTER, OPTIONAL :: x(:),b(:),r(:)
!-------------------------------------------------------------------------------
       M => NULL()
#ifdef PARALLEL_FOR_REAL
       M => A % ParMatrix % SplittedMatrix % InsideMatrix
       IF ( PRESENT(x) ) THEN
          b => M % RHS
          x => A % ParMatrix % SplittedMatrix % TmpXVec
          r => A % ParMatrix % SplittedMatrix % TmpRVec
       END IF
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelMatrix
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    FUNCTION ParallelNorm( n, x ) RESULT(s)
!-------------------------------------------------------------------------------
      INTEGER :: n
      REAL(KIND=dp) :: x(:),s
!-------------------------------------------------------------------------------
      s = 0.0d0
#ifdef PARALLEL_FOR_REAL
      s = SParNorm( n, x, 1 )
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelNorm
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    FUNCTION ParallelDOT( n, x, y ) RESULT(s)
!-------------------------------------------------------------------------------
      INTEGER :: n
      REAL(KIND=dp) :: x(:),y(:),s
!-------------------------------------------------------------------------------
      s = 0.0d0
#ifdef PARALLEL_FOR_REAL
      s = SParDotProd( n, x, 1, y, 1 )
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelDOT
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelGlobalNumbering(Mesh,NewNodes,IntCnts,IntArray,Reorder)
!-------------------------------------------------------------------------------
       TYPE(Mesh_t) :: Mesh
       INTEGER :: NewNodes,IntCnts(:),IntArray(:),Reorder(:)
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
        CALL SparGlobalNumbering( Mesh,NewNodes,IntCnts,IntArray,Reorder )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelGlobalNumbering
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
    SUBROUTINE ParallelIter( SourceMatrix, ParallelInfo, DOFs, XVec, &
              RHSVec, Solver, SParMatrixDesc )
!-------------------------------------------------------------------------------
       TYPE (Matrix_t) :: SourceMatrix
       TYPE (ParallelInfo_t) :: ParallelInfo
       INTEGER :: DOFs
       REAL(KIND=dp), DIMENSION(:) :: XVec, RHSVec
       TYPE (Solver_t) :: Solver
       TYPE (SParIterSolverGlobalD_t), POINTER :: SParMatrixDesc
                                                                                                                               
#ifdef PARALLEL_FOR_REAL
       CALL SParIterSolver( SourceMatrix, ParallelInfo, XVec, &
                 RHSVec, Solver, SParMatrixDesc )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelIter
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelActive( L )
!-------------------------------------------------------------------------------
      LOGICAL :: L
#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs > 1) THEN
         CALL SParIterBarrier
         CALL SParIterActive(L)
       END IF
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelActive
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelAllReduceAnd( L )
!-------------------------------------------------------------------------------
      LOGICAL :: L
#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs > 1) CALL SParIterAllReduceAnd(L)
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelAllReduceAnd
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    FUNCTION ParallelReduction(R,oper_arg) RESULT(rsum)
!-------------------------------------------------------------------------------
      REAL(KIND=dp) :: R, rsum
      INTEGER, OPTIONAL :: oper_arg
!-------------------------------------------------------------------------------
      INTEGER :: oper
!-------------------------------------------------------------------------------
      rsum = r
#ifdef PARALLEL_FOR_REAL
      IF ( ParEnv % PEs>1) THEN
        oper = 0
        IF (PRESENT(oper_arg)) THEN
          oper=oper_arg
        ELSE
          oper = 0
        END IF
        CALL SparActiveSUM(rsum,oper)
      END IF
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelReduction
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelBarrier
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs > 1) CALL SParIterBarrier
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelBarrier
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelActiveBarrier
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs > 1 ) CALL SParIterActiveBarrier
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelActiveBarrier
!-------------------------------------------------------------------------------

END MODULE ParallelUtils
