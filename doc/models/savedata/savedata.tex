\Chapter{Save Data}

\noindent
\modinfo{Module name}{\Idx{SaveData}}
\modinfo{Module subroutines}{\Idx{SaveScalars}, \Idx{SaveLine}, \Idx{SaveMaterials}, \Idx{SaveBoundaryValues}}
\begin{versiona}
\modinfo{Module authors}{Peter Råback, Ville Savolainen, Thomas Zwinger}
\modinfo{Document authors}{Peter Råback}
\modinfo{Document created}{Oct 3rd 2002}
\modinfo{Document updated}{January 8th 2008}

\section{Introduction}

This module does not include any physical models per se.
The module includes utilities for computing derived quantities and 
saving scalars as well as  
lines in matrix format. Scalars are saved with the subroutine 
\texttt{SaveScalars} and lines with the subroutine 
\texttt{SaveLine}, correspondingly.
The results are easily 
then utilized by MatLab, Excel or any other program that can 
read ASCII data. In addition to the number values also
an additional file with the suffix \texttt{.name} is saved. 
It tells what variables are at each column.
In addition there is a utility called \texttt{SaveMaterials} 
that may be used to create additional
field variables from the material parameters. A similar procedure \texttt{SaveBoundaryValues} stores parameters defined on boundaries as variables for the whole mesh. This can be of help if a boundary condition that is not directly accessible from the variables (like a normal component of a vector field) should be evaluated in the post-processing step.

\section{Theory}

The theoretical problem in saving data comes from the fact that
often the data should be saved in points or lines that were not 
a priori defined. 

If there are relatively few points the dummy algorithm
where each element is checked for including the 
node may be used. For the lines, however, this algorithm
might become quite expensive as there may be many points
that constitute the line. Therefore we only look for intersections
of element faces and the lines. Each element face is divided into triangles.
The triangle has points $\vec{e}_1$, $\vec{e}_2$ and $\vec{e}_3$. The
line is drawn between points $\vec{r}_1$ and $\vec{r}_2$.
Therefore the line goes through the point only if
\begin{equation}
   \vec{r}_1 + a (\vec{r}_2 - \vec{r}_1) = 
\vec{e}_1 + b (\vec{e}_2 - \vec{e}_1) +  c (\vec{e}_3 - \vec{e}_1)
\end{equation}
has a solution for which $0\le a, b, c \le 1$. This 
results to a matrix equation
\begin{equation}
\begin{pmatrix}
r_{2x} - r_{1x} & e_{1x}-e_{2x} & e_{1x}-e_{3x} \\
r_{2y} - r_{1y} & e_{1y}-e_{2y} & e_{1y}-e_{3y} \\
r_{2z} - r_{1z} & e_{1z}-e_{2z} & e_{1z}-e_{3z}
\end{pmatrix}
\begin{pmatrix}
a \\
b \\
c 
\end{pmatrix}
=
\begin{pmatrix}
e_{1x} - r_{1x} \\
e_{1y} - r_{1y} \\
e_{1z} - r_{1z} 
\end{pmatrix}
\end{equation}
which may be easily solved with standard methods linear algebra.
Because the face element is a triangle there is an additional 
condition that $b+c \le 1$.

When saving statistical information there are two possibilities. We may use normal number statistics
where each node is given an equal weight. Then, for example the mean becomes,
\begin{equation}
  <f> = \frac{\sum_{i=1}^n f_i}{n}.
\end{equation}
The other possibility is to treat the variable as a continuous function and 
compute the statistical values as averages over the domain. Now the 
mean is 
\begin{equation}
  <f> = \frac{\int f \, d\Omega}{\int d\Omega}.
\end{equation}
In addition to the mean we may compute the mean
deviation, $<|f-<f>|>$.and 
the variance
  $\delta f = \sqrt{ <f^2> - <f>^2} $.

It is possible to compute energy type of lumped quantities
by integrating over the domain. The energy of the field $f$ resulting 
from a diffusion equation is 
\begin{equation}
  E_{diff} = \frac{1}{2} \int_\Omega \nabla f \cdot c \nabla f \, d\Omega,
\end{equation}
where $c$ may a tensor or a scalar.
 Kinetic energy related to convection is of type
\begin{equation}
  E_{con} = \frac{1}{2} \int_\Omega c \vec{v} \cdot \vec{v}  \, d\Omega,
\end{equation}
and potential type of energy
\begin{equation}
  E_{pot} = \int_\Omega c f \, d\Omega.
\end{equation}

Sometimes it may be interesting to compute the fluxes through surfaces.
The values may be used in evaluating the accuracy of the results --
what goes in should in steady state also come out. 
There are two different fluxes that may be
computed. For convective field the flux is of type
\begin{equation}
  F_{con} = \int_\Gamma c \vec{v} \cdot \vec{n} \, d\Gamma, 
\end{equation}
where $\vec{n}$ is the surface normal. Diffusive fluxes may be computed from
\begin{equation}
  F_{diff} = \int_\Gamma c \nabla f \cdot \vec{n} \, d\Gamma , 
\end{equation}
where $c$ may also be a tensor.


\section{Keywords}
\end{versiona}

\subsection*{Keywords of solver SaveScalars}

\sifbegin
\sifitemnt{Solver}{solver id}
\sifbegin
\sifitemnt{Procedure}{File "SaveData"\ "SaveScalars"}
\sifitem{Filename}{String}
Name of the file where results are to be saved, the default is {\tt scalars.dat}.
\sifitem{Scalars Prefix}{String}
Save constants starting with this prefix. The default is {\tt res:}.
\sifitem{Variable i}{String}
The names of the variables to be saved. There can be up to 
99 variables. In addition to field variables there are some special variables.
The scalar variables. e.g. \texttt{Time}, are saved as is. There are also
variables \texttt{CPU Time} and \texttt{CPU Memory} that may be used to save 
execution details.  
%
\sifitem{Save Points(n)}{Integer}
Save the specified degrees of freedom in the $n$ nodes specified.
%
\sifitem{Save Coordinates(n,DIM)}{Real}
Save the degrees of freedom in the nodes nearest 
to the given $n$ coordinates.
%
\sifitem{Exact Coordinates}{Logical}
When this keyword is true the coordinates will be looked in an exact manner.
Then the degrees of freedom are linear combinations of the node values 
of the element that the point belongs to.
%
\sifitem{Moving Mesh}{Logical}
If this parameter is \texttt{True} the saved points will be defined every time the subroutine
is visited. The default is \texttt{False}.
\sifitem{File Append}{Logical}
If the results from consecutive rounds should be appended to the file
this flag should be set to \texttt{True}. The default is {\tt False}.
%
\sifitem{Save Eigenvalues}{Logical}
Save the eigenvalues found in any of the variables.
%
\sifitem{Save Eigenfrequencies}{Logical}
Save the frequencies computed from the eigenvalues found in any of the variables.
%
\sifitem{Operator i}{String}
There are different operators that may be performed on all the
given variables. These include operators working on the set of numbers, 
\texttt{max, min, max abs, min abs, mean, variance} and \texttt{deviation}.
There are also a few operators that use statistics over the volume,
\texttt{int mean} and \texttt{int variance}.
The volume used by a given variable is obtained by
operator \texttt{volume}. If a name for the coefficient, is given for the 
operator, the integral is taken over the coefficient. One can for example
obtain the weight from a integral over \texttt{Density}.

There are also a number of similar operators that only operate on the boundary.
These are invoked by \texttt{boundary sum}, \texttt{boundary dofs}, \texttt{boundary mean},
\texttt{boundary max}, \texttt{boundary min}, 
\texttt{boundary max abs}, and \texttt{boundary min abs}.

Three different energy type of quantities may be computed by 
\Idx{domain integral} operators
\texttt{diffusive energy, convective energy, potential energy}. 
Finally, also \Idx{boundary integral}s are possible using operators
\texttt{diffusive flux}, \texttt{convective flux} and \texttt{area}. 
These require that in the boundary conditions 
the active boundaries are defined. Also here there may be an optional 
coefficient.

Some operators do not work on the solution itself but use other info related to that.
Operator \texttt{dofs} simply returns the length of 
the variable under study. Operator \texttt{norm} returns the last computed norm of the 
field variable, and operators \texttt{nonlinear change} and \texttt{steady state change} return
the last computed convergence measures at the nonlinear and steady state levels. 

There may be up to 99 different operators.
If the variable is a vector the statistics is performed on its length.
%
\sifitem{Coefficient i}{String}
Even though only limited number of operators are given 
almost any energy or flux kind of quantity may be computed since 
the coefficient $c$ may be defined by the user.
The idea is that the same data that is already used as a material
parameter can be simple referred to by its name.
The coefficient may be,
\texttt{Heat Conductivity}, \texttt{Permittivity}, \texttt{Density}, 
for example. Usually the coefficient is the same that was used in computing
the field variable under integration.
For the \texttt{diffusive energy} and \texttt{diffusive flux} 
the coefficient may even be a matrix. 
This parameter is optional and the default is one.
%
\sifitem{Polyline Coordinates(n,DIM)}{Real}
This keyword may be used to create line segments that are defined by
points $x_1$, $y_1$, $x_2$, and $y_2$. For each line different
kinds of fluxes trough the elements may be computed.
This makes it possible, for example, to check the mass flux 
even though no boundary has a priori been defined.  
\sifend

\sifitemnt{Boundary Condition}{bc id}
\sifbegin
\sifitem{Save Scalars}{Logical}
The flag activates the computation of boundary related information.
The results are treated independently for each boundary.
The keyword replaces the previously used \texttt{Flux Integrate}. 
\sifend
\sifend



\subsection*{Keywords of subroutine SaveLine}

\sifbegin
\sifitemnt{Solver}{solver id}
\sifbegin
\sifitemnt{Procedure}{File "SaveData"\ "SaveLine"}
\sifitem{Filename}{String}
Name of the file where results are to be saved, the default is 
{\tt sides.dat}. 
\sifitem{File Append}{Logical}
If the results from consecutive rounds should be appended to the file
this flag should be set to {\tt True}. The default is {\tt False}.

\sifitem{Save Axis}{Logical}
Save all the principal axis. Also keywords {\tt Save Axis i} exist, where
{\tt i}=1,2,3 defines the axis. 
%
\sifitem{Polyline Coordinates(n,DIM)}{Real}
Save the line consisting of line segments defined by two points ($n=2$). 
There can be more than one set of points ($n=2,4,6,\ldots$) but as a line segment is 
defined by two points there must be an even number of points.
%
\sifitem{Variable i}{String} 
By default \texttt{SaveLine} saves all the active variables. However, it is possible to
save only a specified list of variables given by this keyword where {tt i}=1,2,3,\ldots
This may be particularly useful if one wants to save a table of linear dependece, for example 
Temperature along $x$-direction, to be used as a boundary condition in consecutive Elmer runs
with a different mesh.


\sifitem{Save Flux}{Logical}
Saves a flux resulting from a gradient of a field by the model
$h=-\kappa \partial T/\partial n$. This may only be applied 
to existing boundaries, not lines defined by points.
%
\sifitem{Flux Variable}{String}
The name of the field variable (default $T$ is {\tt Temperature}).
\sifitem{Flux Coefficient}{String}
The diffusion constant (by default $\kappa$ is {\tt Heat Conductivity})

\sifitem{Save Mask}{String}a
By default SaveLine saves only the values that are on boundary marked with 
\texttt{Save Line} flag. If the user wants several instances of the SaveLine subroutine,
for saving different buondaries to different files, the mask name may be defined by this keyword.
The correspondingly one should use the same flag in the \texttt{Boundary Condition} and 
{Body} section.


\sifend

\sifitemnt{Boundary Condition}{bc id}
\sifbegin
\sifitem{Save Line}{Logical}
The flag activates the saving of the boundary condition as a line.
The subroutine tries to save the finite-element lines as a chain of points
to enable nice preprocessing with MatLab or similar tools.
The flux may only be saved on lines defined by boundary conditions.
\sifend
\sifend


\subsection*{Keywords of subroutine SaveMaterials}

\sifbegin
\sifitemnt{Solver}{solver id}
\sifbegin
\sifitemnt{Procedure}{File "SaveData"\ "SaveMaterials"}
\sifitem{Parameter i}{String}
The user may choose a number of parameters (i=1,\ldots,99) which
will be save as variables. This may be particularly handy if one wants to
visualize how the parameters depend on the position over the domain. Values in bodies with the assigned material list not containing the keyword of the parameter are set to zero by default.
\sifend
\sifend

\subsection*{Keywords of subroutine SaveBoundaryValues}

\sifbegin
\sifitemnt{Solver}{solver id}
\sifbegin
\sifitemnt{Procedure}{File "SaveData"\ "SaveBoundaryValues"}
\sifitem{Variable}{String -nooutput dummyvar}
a dummy variable for the solver that does not show up
\sifitem{Variable DOFs} {Integer  1}
\sifitem{Parameter i}{String}
The user may choose a number of parameters (i=1,\ldots,99) which
will be save as variables. These parameters will then be stored as variables with the values assigned as they were found on the specific boundary. Bulk values and values on boundaries with the parameter not being defined are set to zero by default.
\sifend
\sifend
